{
  "models": {
    "fact_ai_intent_engine": {
      "name": "fact_ai_intent_engine",
      "filePath": "fact_tables/fact_ai_intent_engine.sqlx",
      "type": "table",
      "schema": "fact_tables_dev",
      "tags": [
        "fact_tables",
        "intent_engine",
        "ai_offers"
      ],
      "description": "Fact table for AI intent engine frontend events, enriched with campaign/offer data from mapping",
      "config": {
        "type": "table",
        "schema": "fact_tables_dev",
        "tags": [
          "fact_tables",
          "intent_engine",
          "ai_offers"
        ],
        "description": "Fact table for AI intent engine frontend events, enriched with campaign/offer data from mapping",
        "bigquery": {
          "partitionBy": "DATE(event_ts)",
          "clusterBy": [
            "action",
            "campaign_id",
            "merchant_id"
          ]
        }
      },
      "sqlContent": "\n\n-- Fact table for AI Intent Engine frontend events only\nSELECT\n  -- Timestamps\n  TIMESTAMP_MILLIS(ae.timestamp_ms) AS event_ts,\n  m.backend_ts,\n  UNIX_MILLIS(m.backend_ts) AS timestamp_ms,\n  \n  -- Action mapping for funnel\n  CASE\n    WHEN ae.action IN ('show', 'view') THEN 'impression'\n    WHEN ae.action = 'click' THEN 'click'\n    WHEN ae.action = 'close' THEN 'dismissal'\n    ELSE COALESCE(ae.action, 'unknown')\n  END AS action,\n  \n  ae.action AS original_action,\n  \n  -- Core identifiers\n  ae.request_id,\n  ae.offer_id,\n  \n  -- From mapping\n  m.campaign_id,\n  m.merchant_id,\n  m.device_id,\n  \n  -- User identifiers\n  COALESCE(m.user_id, ae.user_id) AS user_id,\n  ae.id AS anonymous_id,\n  \n  -- Source info\n  m.intent_engine_type,\n  'ai' AS source_type,\n  \n  -- Tenant fields\n  ae.tenant_id,\n  ae.tenant_client_id,\n  ae.tenant_rewards_enabled,\n  \n  -- AI-specific fields\n  ae.outbound_url,\n  ae.surface,\n  ae.is_rewards,\n  ae.user_agent,\n  ae.tag_id,\n  \n  -- From mapping\n  m.req_offer,\n  m.top_offer,\n  m.offer_award,\n  m.offer_content,\n  m.offer_cta,\n  m.campaign_boost,\n  m.campaign_active,\n  m.campaign_state,\n  m.campaign_budget,\n  m.offergroup_id,\n  m.offergroup_min_bid,\n  m.offergroup_max_bid,\n  m.offergroup_bid_type\n\nFROM `piedotorg-production.backend_analytics.ai_intent_engine_offer` ae\nLEFT JOIN `piedotorg-production.fact_tables_dev.request_offer_campaign_mapping` m\n  ON ae.request_id = m.request_id\n  AND ae.offer_id = m.offer_id\n  -- Match on tenant_client_id for AI offers\n  AND ae.tenant_client_id = m.tenant_client_id",
      "dependencies": [
        "ai_intent_engine_offer",
        "request_offer_campaign_mapping"
      ]
    },
    "fact_ext_intent_engine_offer": {
      "name": "fact_ext_intent_engine_offer",
      "filePath": "fact_tables/fact_ext_intent_engine_offer.sqlx",
      "type": "table",
      "schema": "fact_tables_dev",
      "tags": [
        "fact_tables",
        "intent_engine",
        "ext_offers"
      ],
      "description": "Fact table for extension intent engine frontend events, enriched with campaign/offer data from mapping",
      "config": {
        "type": "table",
        "schema": "fact_tables_dev",
        "tags": [
          "fact_tables",
          "intent_engine",
          "ext_offers"
        ],
        "description": "Fact table for extension intent engine frontend events, enriched with campaign/offer data from mapping",
        "bigquery": {
          "partitionBy": "DATE(event_ts)",
          "clusterBy": [
            "action",
            "campaign_id",
            "merchant_id"
          ]
        }
      },
      "sqlContent": "\n\n-- Fact table for Extension Intent Engine frontend events only\nSELECT\n  -- Timestamps\n  ee.timestamp AS event_ts,\n  m.backend_ts,\n  UNIX_MILLIS(m.backend_ts) AS timestamp_ms,\n  \n  -- Action mapping for funnel\n  CASE\n    WHEN ee.action IN ('show', 'view') THEN 'impression'\n    WHEN ee.action = 'click' THEN 'click'\n    WHEN ee.action = 'close' THEN 'dismissal'\n    ELSE COALESCE(ee.action, 'unknown')\n  END AS action,\n  \n  ee.action AS original_action,\n  \n  -- Core identifiers\n  ee.request_id,\n  ee.offer_id,\n  \n  -- From mapping\n  m.campaign_id,\n  m.merchant_id,\n  m.device_id,\n  \n  -- User identifiers\n  COALESCE(m.user_id, ee.user_id) AS user_id,\n  ee.anonymous_id,\n  \n  -- Source info\n  m.intent_engine_type,\n  'ext' AS source_type,\n  \n  -- Extension-specific fields\n  ee.surface,\n  ee.is_rewards,\n  ee.ext_tag_id,\n  ee.platform,\n  ee.referer_url,\n  \n  -- From mapping\n  m.req_offer,\n  m.top_offer,\n  m.offer_award,\n  m.offer_content,\n  m.offer_cta,\n  m.campaign_boost,\n  m.campaign_active,\n  m.campaign_state,\n  m.campaign_budget,\n  m.offergroup_id,\n  m.offergroup_min_bid,\n  m.offergroup_max_bid,\n  m.offergroup_bid_type,\n  \n  -- Tenant fields from mapping (extension doesn't have its own tenant fields)\n  m.tenant_id,\n  m.tenant_client_id\n\nFROM `piedotorg-production.shopping_extension_production.ext_intent_engine_offer` ee\nLEFT JOIN `piedotorg-production.fact_tables_dev.request_offer_campaign_mapping` m\n  ON ee.request_id = m.request_id\n  AND ee.offer_id = m.offer_id",
      "dependencies": [
        "ext_intent_engine_offer",
        "request_offer_campaign_mapping"
      ]
    },
    "fact_intent_engine_offer_group_match": {
      "name": "fact_intent_engine_offer_group_match",
      "filePath": "fact_tables/fact_intent_engine_offer_group_match.sqlx",
      "type": "table",
      "schema": "fact_tables_dev",
      "tags": [
        "fact_tables",
        "backend",
        "intent_engine",
        "offers"
      ],
      "description": "Backend offer matching events enriched with campaign data from mapping table",
      "config": {
        "type": "table",
        "schema": "fact_tables_dev",
        "tags": [
          "fact_tables",
          "backend",
          "intent_engine",
          "offers"
        ],
        "description": "Backend offer matching events enriched with campaign data from mapping table",
        "bigquery": {
          "partitionBy": "DATE(backend_ts)",
          "clusterBy": [
            "campaign_id",
            "merchant_id",
            "request_id"
          ]
        }
      },
      "sqlContent": "\n\n-- Fact table for backend offer matching events\nSELECT\n  -- Timestamps\n  TIMESTAMP_MILLIS(og.timestamp_ms) AS backend_ts,\n  og.timestamp_ms,\n  \n  -- Action\n  'consideration' AS action,\n  \n  -- Request level\n  og.request_id,\n  og.device_id,\n  og.user_id,\n  \n  -- Offer level  \n  og.offer_id,\n  og.offer_content,\n  og.offer_click_url,\n  og.offer_cta,\n  og.offer_award,\n  og.offer_distribution,\n  og.top_offer,\n  \n  -- From mapping\n  m.campaign_id,\n  m.campaign_boost,\n  m.campaign_active,\n  m.campaign_state,\n  m.campaign_budget,\n  \n  -- Merchant level\n  og.merchant_id,\n  \n  -- Offer group level\n  og.offergroup_id,\n  og.offergroup_min_bid,\n  og.offergroup_max_bid,\n  og.offergroup_bid_type,\n  \n  -- Tenant level\n  og.tenant_id,\n  og.tenant_client_id,\n  \n  -- Source info\n  og.intent_engine_type,\n  og.client,\n  \n  -- From mapping\n  m.req_offer,\n  \n  -- Placement fields from mapping\n  m.first_placement_template,\n  m.first_placement_id,\n  m.first_placement_match,\n  m.first_placement_hostname,\n  m.placement_count,\n  \n  -- Search context\n  og.keywords\n\nFROM `piedotorg-production.backend_analytics.intent_engine_offer_group_match` og\nLEFT JOIN `piedotorg-production.fact_tables_dev.request_offer_campaign_mapping` m\n  ON og.request_id = m.request_id\n  AND og.offer_id = m.offer_id",
      "dependencies": [
        "intent_engine_offer_group_match",
        "request_offer_campaign_mapping"
      ]
    },
    "fact_offer_attribution_models": {
      "name": "fact_offer_attribution_models",
      "filePath": "fact_tables/fact_offer_attribution_models.sqlx",
      "type": "table",
      "schema": "fact_tables_dev",
      "tags": [
        "fact_tables",
        "attribution",
        "transactions"
      ],
      "description": "Multi-model attribution table with 5 attribution models. Only includes transactions that successfully match at least one attribution model. Creates rows for ALL matching attribution models per transaction.",
      "config": {
        "type": "table",
        "schema": "fact_tables_dev",
        "tags": [
          "fact_tables",
          "attribution",
          "transactions"
        ],
        "description": "Multi-model attribution table with 5 attribution models. Only includes transactions that successfully match at least one attribution model. Creates rows for ALL matching attribution models per transaction.",
        "bigquery": {
          "partitionBy": "DATE(transaction_ts)",
          "clusterBy": [
            "attribution_model",
            "campaign_id",
            "merchant_id"
          ]
        }
      },
      "sqlContent": "\n\n-- Multi-model attribution fact table\n-- Creates one row per transaction per attribution model\nWITH \n-- Base transaction data (AFFILIATE only)\ntransaction_base AS (\n  SELECT\n    DATETIME(created_coalesce_ts) AS transaction_ts,\n    transactionId AS transaction_id,\n    anonymous_id,\n    userId AS user_id,\n    CASE WHEN merchantId = 'logitechg' THEN 'logitech' ELSE merchantId END AS merchant_id,\n    CASE \n      WHEN merchantId = 'verizon' AND IFNULL(externalSaleValue, 0) = 0 \n      THEN externalCommission \n      ELSE externalSaleValue \n    END AS external_sale_value_cents,\n    externalCommission AS external_commission_cents,\n    millipoints,\n    type AS transaction_type,\n    ext_tag_id,\n    campaignId AS direct_campaign_id -- For direct AD_OFFER transactions\n  FROM `piedotorg-production.data_science_dev.transactions_expanded_view`\n  WHERE type = 'AFFILIATE'  -- Only AFFILIATE transactions for attribution\n    AND created_coalesce_ts IS NOT NULL\n    AND merchantId IS NOT NULL\n),\n\n-- Get all click events from enriched int_fe_offer table\nclick_events AS (\n  SELECT\n    event_ts,\n    campaign_id,\n    merchant_id,\n    offer_id,\n    request_id,\n    user_id,\n    anonymous_id,\n    device_id,\n    source_type,\n    intent_engine_type,\n    req_offer,\n    tenant_id,\n    offer_award,\n    offer_content,\n    COALESCE(ext_tag_id, tag_id) AS ext_tag_id,  -- Use ext_tag_id for Extension, tag_id for AI\n    first_placement_template,\n    first_placement_id,\n    first_placement_match,\n    first_placement_hostname,\n    placement_count\n  FROM `piedotorg-production.fact_tables_dev.int_fe_offer`\n  WHERE action = 'click'\n    AND campaign_id IS NOT NULL\n    AND merchant_id IS NOT NULL\n),\n\n-- Get all impression events from enriched int_fe_offer table\nimpression_events AS (\n  SELECT\n    event_ts,\n    campaign_id,\n    merchant_id,\n    offer_id,\n    request_id,\n    user_id,\n    anonymous_id,\n    device_id,\n    source_type,\n    intent_engine_type,\n    req_offer,\n    tenant_id,\n    offer_award,\n    offer_content,\n    COALESCE(ext_tag_id, tag_id) AS ext_tag_id,  -- Use ext_tag_id for Extension, tag_id for AI\n    first_placement_template,\n    first_placement_id,\n    first_placement_match,\n    first_placement_hostname,\n    placement_count\n  FROM `piedotorg-production.fact_tables_dev.int_fe_offer`\n  WHERE action = 'impression'\n    AND campaign_id IS NOT NULL\n    AND merchant_id IS NOT NULL\n),\n\n-- 1. Tag ID Attribution (Deterministic)\ntag_id_attribution AS (\n  SELECT\n    tb.transaction_ts,\n    tb.transaction_id,\n    'tag_id' AS attribution_model,\n    TRUE AS attributed,\n    'deterministic' AS attribution_confidence,\n    \n    -- Transaction details\n    tb.merchant_id,\n    ce.campaign_id,\n    ce.offer_id,\n    ce.request_id,\n    ce.req_offer,\n    \n    -- User identifiers\n    COALESCE(tb.user_id, ce.user_id) AS user_id,\n    COALESCE(tb.anonymous_id, ce.anonymous_id) AS anonymous_id,\n    ce.device_id,\n    \n    -- Transaction metrics\n    tb.transaction_type,\n    tb.external_sale_value_cents / 100 AS external_sale_value_dollars,\n    tb.external_commission_cents / 100 AS external_commission_dollars,\n    tb.millipoints,\n    \n    -- Attribution event details\n    ce.event_ts AS attribution_event_ts,\n    'click' AS attribution_event_action,\n    ce.source_type AS attribution_event_source,\n    NULL AS attribution_window_hours, -- Deterministic, no window\n    DATETIME_DIFF(tb.transaction_ts, DATETIME(ce.event_ts), HOUR) AS time_to_conversion_hours,\n    \n    -- Tag-specific fields\n    tb.ext_tag_id,\n    \n    -- Campaign metadata\n    ce.intent_engine_type,\n    ce.source_type,\n    ce.tenant_id,\n    ce.offer_award,\n    ce.offer_content,\n    \n    -- Placement fields\n    ce.first_placement_template,\n    ce.first_placement_id,\n    ce.first_placement_match,\n    ce.first_placement_hostname,\n    ce.placement_count\n    \n  FROM transaction_base tb\n  INNER JOIN click_events ce\n    ON tb.ext_tag_id = ce.ext_tag_id\n    AND tb.merchant_id = ce.merchant_id\n    AND (\n      -- Primary: match on user_id if both have it\n      (tb.user_id IS NOT NULL AND ce.user_id = tb.user_id)\n      -- Fallback: match on anonymous_id if user_id is NULL\n      OR (tb.user_id IS NULL AND tb.anonymous_id IS NOT NULL AND ce.anonymous_id = tb.anonymous_id)\n    )\n    AND DATETIME(ce.event_ts) <= tb.transaction_ts  -- Click must be before transaction\n  WHERE tb.ext_tag_id IS NOT NULL\n    AND ce.ext_tag_id IS NOT NULL\n),\n\n-- 2. Click 24h Last-Touch Attribution\nclick_24h_attribution AS (\n  SELECT \n    transaction_ts,\n    transaction_id,\n    attribution_model,\n    attributed,\n    attribution_confidence,\n    merchant_id,\n    campaign_id,\n    offer_id,\n    request_id,\n    req_offer,\n    user_id,\n    anonymous_id,\n    device_id,\n    transaction_type,\n    external_sale_value_dollars,\n    external_commission_dollars,\n    millipoints,\n    attribution_event_ts,\n    attribution_event_action,\n    attribution_event_source,\n    attribution_window_hours,\n    time_to_conversion_hours,\n    ext_tag_id,\n    intent_engine_type,\n    source_type,\n    tenant_id,\n    offer_award,\n    offer_content,\n    first_placement_template,\n    first_placement_id,\n    first_placement_match,\n    first_placement_hostname,\n    placement_count\n  FROM (\n    SELECT\n      tb.transaction_ts,\n      tb.transaction_id,\n      'click_24h' AS attribution_model,\n      TRUE AS attributed,\n      'last_touch' AS attribution_confidence,\n      \n      -- Transaction details\n      tb.merchant_id,\n      ce.campaign_id,\n      ce.offer_id,\n      ce.request_id,\n      ce.req_offer,\n      \n      -- User identifiers\n      COALESCE(tb.user_id, ce.user_id) AS user_id,\n      COALESCE(tb.anonymous_id, ce.anonymous_id) AS anonymous_id,\n      ce.device_id,\n      \n      -- Transaction metrics\n      tb.transaction_type,\n      tb.external_sale_value_cents / 100 AS external_sale_value_dollars,\n      tb.external_commission_cents / 100 AS external_commission_dollars,\n      tb.millipoints,\n      \n      -- Attribution event details\n      ce.event_ts AS attribution_event_ts,\n      'click' AS attribution_event_action,\n      ce.source_type AS attribution_event_source,\n      24 AS attribution_window_hours,\n      DATETIME_DIFF(tb.transaction_ts, DATETIME(ce.event_ts), HOUR) AS time_to_conversion_hours,\n      \n      -- Tag-specific fields\n      tb.ext_tag_id,\n      \n      -- Campaign metadata\n      ce.intent_engine_type,\n      ce.source_type,\n      ce.tenant_id,\n      ce.offer_award,\n      ce.offer_content,\n      \n      -- Placement fields\n      ce.first_placement_template,\n      ce.first_placement_id,\n      ce.first_placement_match,\n      ce.first_placement_hostname,\n      ce.placement_count,\n      \n      -- Rank for last-touch logic\n      ROW_NUMBER() OVER (\n        PARTITION BY tb.transaction_id \n        ORDER BY DATETIME(ce.event_ts) DESC\n      ) AS click_rank\n      \n    FROM transaction_base tb\n    INNER JOIN click_events ce\n      ON tb.merchant_id = ce.merchant_id\n      AND (\n        -- Primary: match on user_id if both have it\n        (tb.user_id IS NOT NULL AND ce.user_id = tb.user_id)\n        -- Fallback: match on anonymous_id if user_id is NULL\n        OR (tb.user_id IS NULL AND tb.anonymous_id IS NOT NULL AND ce.anonymous_id = tb.anonymous_id)\n      )\n      AND DATETIME(ce.event_ts) <= tb.transaction_ts\n      AND DATETIME_DIFF(tb.transaction_ts, DATETIME(ce.event_ts), HOUR) <= 24\n  )\n  WHERE click_rank = 1  -- Last touch only\n),\n\n-- 3. Click 7d Last-Touch Attribution  \nclick_7d_attribution AS (\n  SELECT \n    transaction_ts,\n    transaction_id,\n    attribution_model,\n    attributed,\n    attribution_confidence,\n    merchant_id,\n    campaign_id,\n    offer_id,\n    request_id,\n    req_offer,\n    user_id,\n    anonymous_id,\n    device_id,\n    transaction_type,\n    external_sale_value_dollars,\n    external_commission_dollars,\n    millipoints,\n    attribution_event_ts,\n    attribution_event_action,\n    attribution_event_source,\n    attribution_window_hours,\n    time_to_conversion_hours,\n    ext_tag_id,\n    intent_engine_type,\n    source_type,\n    tenant_id,\n    offer_award,\n    offer_content,\n    first_placement_template,\n    first_placement_id,\n    first_placement_match,\n    first_placement_hostname,\n    placement_count\n  FROM (\n    SELECT\n      tb.transaction_ts,\n      tb.transaction_id,\n      'click_7d' AS attribution_model,\n      TRUE AS attributed,\n      'last_touch' AS attribution_confidence,\n      \n      -- Transaction details\n      tb.merchant_id,\n      ce.campaign_id,\n      ce.offer_id,\n      ce.request_id,\n      ce.req_offer,\n      \n      -- User identifiers\n      COALESCE(tb.user_id, ce.user_id) AS user_id,\n      COALESCE(tb.anonymous_id, ce.anonymous_id) AS anonymous_id,\n      ce.device_id,\n      \n      -- Transaction metrics\n      tb.transaction_type,\n      tb.external_sale_value_cents / 100 AS external_sale_value_dollars,\n      tb.external_commission_cents / 100 AS external_commission_dollars,\n      tb.millipoints,\n      \n      -- Attribution event details\n      ce.event_ts AS attribution_event_ts,\n      'click' AS attribution_event_action,\n      ce.source_type AS attribution_event_source,\n      168 AS attribution_window_hours, -- 7 days * 24 hours\n      DATETIME_DIFF(tb.transaction_ts, DATETIME(ce.event_ts), HOUR) AS time_to_conversion_hours,\n      \n      -- Tag-specific fields\n      tb.ext_tag_id,\n      \n      -- Campaign metadata\n      ce.intent_engine_type,\n      ce.source_type,\n      ce.tenant_id,\n      ce.offer_award,\n      ce.offer_content,\n      \n      -- Placement fields\n      ce.first_placement_template,\n      ce.first_placement_id,\n      ce.first_placement_match,\n      ce.first_placement_hostname,\n      ce.placement_count,\n      \n      -- Rank for last-touch logic\n      ROW_NUMBER() OVER (\n        PARTITION BY tb.transaction_id \n        ORDER BY DATETIME(ce.event_ts) DESC\n      ) AS click_rank\n      \n    FROM transaction_base tb\n    INNER JOIN click_events ce\n      ON tb.merchant_id = ce.merchant_id\n      AND (\n        -- Primary: match on user_id if both have it\n        (tb.user_id IS NOT NULL AND ce.user_id = tb.user_id)\n        -- Fallback: match on anonymous_id if user_id is NULL\n        OR (tb.user_id IS NULL AND tb.anonymous_id IS NOT NULL AND ce.anonymous_id = tb.anonymous_id)\n      )\n      AND DATETIME(ce.event_ts) <= tb.transaction_ts\n      AND DATETIME_DIFF(tb.transaction_ts, DATETIME(ce.event_ts), HOUR) <= 168 -- 7 days\n  )\n  WHERE click_rank = 1  -- Last touch only\n),\n\n-- 4. View 24h Last-Touch Attribution (independent of click attribution)\nview_24h_attribution AS (\n  SELECT \n    transaction_ts,\n    transaction_id,\n    attribution_model,\n    attributed,\n    attribution_confidence,\n    merchant_id,\n    campaign_id,\n    offer_id,\n    request_id,\n    req_offer,\n    user_id,\n    anonymous_id,\n    device_id,\n    transaction_type,\n    external_sale_value_dollars,\n    external_commission_dollars,\n    millipoints,\n    attribution_event_ts,\n    attribution_event_action,\n    attribution_event_source,\n    attribution_window_hours,\n    time_to_conversion_hours,\n    ext_tag_id,\n    intent_engine_type,\n    source_type,\n    tenant_id,\n    offer_award,\n    offer_content,\n    first_placement_template,\n    first_placement_id,\n    first_placement_match,\n    first_placement_hostname,\n    placement_count\n  FROM (\n    SELECT\n      tb.transaction_ts,\n      tb.transaction_id,\n      'view_24h' AS attribution_model,\n      TRUE AS attributed,\n      'view_assist' AS attribution_confidence,\n      \n      -- Transaction details\n      tb.merchant_id,\n      ie.campaign_id,\n      ie.offer_id,\n      ie.request_id,\n      ie.req_offer,\n      \n      -- User identifiers\n      COALESCE(tb.user_id, ie.user_id) AS user_id,\n      COALESCE(tb.anonymous_id, ie.anonymous_id) AS anonymous_id,\n      ie.device_id,\n      \n      -- Transaction metrics\n      tb.transaction_type,\n      tb.external_sale_value_cents / 100 AS external_sale_value_dollars,\n      tb.external_commission_cents / 100 AS external_commission_dollars,\n      tb.millipoints,\n      \n      -- Attribution event details\n      ie.event_ts AS attribution_event_ts,\n      'impression' AS attribution_event_action,\n      ie.source_type AS attribution_event_source,\n      24 AS attribution_window_hours,\n      DATETIME_DIFF(tb.transaction_ts, DATETIME(ie.event_ts), HOUR) AS time_to_conversion_hours,\n      \n      -- Tag-specific fields\n      tb.ext_tag_id,\n      \n      -- Campaign metadata\n      ie.intent_engine_type,\n      ie.source_type,\n      ie.tenant_id,\n      ie.offer_award,\n      ie.offer_content,\n      \n      -- Placement fields\n      ie.first_placement_template,\n      ie.first_placement_id,\n      ie.first_placement_match,\n      ie.first_placement_hostname,\n      ie.placement_count,\n      \n      -- Rank for last-touch logic\n      ROW_NUMBER() OVER (\n        PARTITION BY tb.transaction_id \n        ORDER BY DATETIME(ie.event_ts) DESC\n      ) AS impression_rank\n      \n    FROM transaction_base tb\n    INNER JOIN impression_events ie\n      ON tb.merchant_id = ie.merchant_id\n      AND (\n        -- Primary: match on user_id if both have it\n        (tb.user_id IS NOT NULL AND ie.user_id = tb.user_id)\n        -- Fallback: match on anonymous_id if user_id is NULL\n        OR (tb.user_id IS NULL AND tb.anonymous_id IS NOT NULL AND ie.anonymous_id = tb.anonymous_id)\n      )\n      AND DATETIME(ie.event_ts) <= tb.transaction_ts\n      AND DATETIME_DIFF(tb.transaction_ts, DATETIME(ie.event_ts), HOUR) <= 24\n  )\n  WHERE impression_rank = 1  -- Last touch only\n),\n\n-- 5. View 7d Last-Touch Attribution (independent of click attribution)\nview_7d_attribution AS (\n  SELECT \n    transaction_ts,\n    transaction_id,\n    attribution_model,\n    attributed,\n    attribution_confidence,\n    merchant_id,\n    campaign_id,\n    offer_id,\n    request_id,\n    req_offer,\n    user_id,\n    anonymous_id,\n    device_id,\n    transaction_type,\n    external_sale_value_dollars,\n    external_commission_dollars,\n    millipoints,\n    attribution_event_ts,\n    attribution_event_action,\n    attribution_event_source,\n    attribution_window_hours,\n    time_to_conversion_hours,\n    ext_tag_id,\n    intent_engine_type,\n    source_type,\n    tenant_id,\n    offer_award,\n    offer_content,\n    first_placement_template,\n    first_placement_id,\n    first_placement_match,\n    first_placement_hostname,\n    placement_count\n  FROM (\n    SELECT\n      tb.transaction_ts,\n      tb.transaction_id,\n      'view_7d' AS attribution_model,\n      TRUE AS attributed,\n      'view_assist' AS attribution_confidence,\n      \n      -- Transaction details\n      tb.merchant_id,\n      ie.campaign_id,\n      ie.offer_id,\n      ie.request_id,\n      ie.req_offer,\n      \n      -- User identifiers\n      COALESCE(tb.user_id, ie.user_id) AS user_id,\n      COALESCE(tb.anonymous_id, ie.anonymous_id) AS anonymous_id,\n      ie.device_id,\n      \n      -- Transaction metrics\n      tb.transaction_type,\n      tb.external_sale_value_cents / 100 AS external_sale_value_dollars,\n      tb.external_commission_cents / 100 AS external_commission_dollars,\n      tb.millipoints,\n      \n      -- Attribution event details\n      ie.event_ts AS attribution_event_ts,\n      'impression' AS attribution_event_action,\n      ie.source_type AS attribution_event_source,\n      168 AS attribution_window_hours, -- 7 days * 24 hours\n      DATETIME_DIFF(tb.transaction_ts, DATETIME(ie.event_ts), HOUR) AS time_to_conversion_hours,\n      \n      -- Tag-specific fields\n      tb.ext_tag_id,\n      \n      -- Campaign metadata\n      ie.intent_engine_type,\n      ie.source_type,\n      ie.tenant_id,\n      ie.offer_award,\n      ie.offer_content,\n      \n      -- Placement fields\n      ie.first_placement_template,\n      ie.first_placement_id,\n      ie.first_placement_match,\n      ie.first_placement_hostname,\n      ie.placement_count,\n      \n      -- Rank for last-touch logic\n      ROW_NUMBER() OVER (\n        PARTITION BY tb.transaction_id \n        ORDER BY DATETIME(ie.event_ts) DESC\n      ) AS impression_rank\n      \n    FROM transaction_base tb\n    INNER JOIN impression_events ie\n      ON tb.merchant_id = ie.merchant_id\n      AND (\n        -- Primary: match on user_id if both have it\n        (tb.user_id IS NOT NULL AND ie.user_id = tb.user_id)\n        -- Fallback: match on anonymous_id if user_id is NULL\n        OR (tb.user_id IS NULL AND tb.anonymous_id IS NOT NULL AND ie.anonymous_id = tb.anonymous_id)\n      )\n      AND DATETIME(ie.event_ts) <= tb.transaction_ts\n      AND DATETIME_DIFF(tb.transaction_ts, DATETIME(ie.event_ts), HOUR) <= 168 -- 7 days\n  )\n  WHERE impression_rank = 1  -- Last touch only\n)\n\n-- Union all attribution models (only attributed transactions)\nSELECT * FROM tag_id_attribution\nUNION ALL\nSELECT * FROM click_24h_attribution\nUNION ALL  \nSELECT * FROM click_7d_attribution\nUNION ALL\nSELECT * FROM view_24h_attribution\nUNION ALL\nSELECT * FROM view_7d_attribution",
      "dependencies": [
        "transactions_expanded_view",
        "int_fe_offer"
      ]
    },
    "fact_web_intent_engine_offer": {
      "name": "fact_web_intent_engine_offer",
      "filePath": "fact_tables/fact_web_intent_engine_offer.sqlx",
      "type": "table",
      "schema": "fact_tables_dev",
      "tags": [
        "fact_tables",
        "intent_engine",
        "web_offers"
      ],
      "description": "Fact table for web intent engine frontend events, enriched with campaign/offer data from mapping",
      "config": {
        "type": "table",
        "schema": "fact_tables_dev",
        "tags": [
          "fact_tables",
          "intent_engine",
          "web_offers"
        ],
        "description": "Fact table for web intent engine frontend events, enriched with campaign/offer data from mapping",
        "bigquery": {
          "partitionBy": "DATE(event_ts)",
          "clusterBy": [
            "action",
            "campaign_id",
            "merchant_id"
          ]
        }
      },
      "sqlContent": "\n\n-- Fact table for Web Intent Engine frontend events only\nSELECT\n  -- Timestamps\n  we.timestamp AS event_ts,\n  m.backend_ts,\n  UNIX_MILLIS(m.backend_ts) AS timestamp_ms,\n  \n  -- Action mapping for funnel\n  CASE\n    WHEN we.action IN ('show', 'view') THEN 'impression'\n    WHEN we.action = 'click' THEN 'click'\n    WHEN we.action = 'close' THEN 'dismissal'\n    ELSE COALESCE(we.action, 'unknown')\n  END AS action,\n  \n  we.action AS original_action,\n  \n  -- Core identifiers\n  we.request_id,\n  we.offer_id,\n  \n  -- From mapping\n  m.campaign_id,\n  m.merchant_id,\n  m.device_id,\n  \n  -- User identifiers\n  COALESCE(m.user_id, we.user_id) AS user_id,\n  we.anonymous_id,\n  \n  -- Source info\n  m.intent_engine_type,\n  'web' AS source_type,\n  \n  -- Web-specific fields\n  we.surface,\n  we.is_rewards,\n  we.context_locale,\n  we.context_device_type,\n  \n  -- From mapping\n  m.req_offer,\n  m.top_offer,\n  m.offer_award,\n  m.offer_content,\n  m.offer_cta,\n  m.campaign_boost,\n  m.campaign_active,\n  m.campaign_state,\n  m.campaign_budget,\n  m.offergroup_id,\n  m.offergroup_min_bid,\n  m.offergroup_max_bid,\n  m.offergroup_bid_type,\n  \n  -- Tenant fields from mapping (web doesn't have its own tenant fields)\n  m.tenant_id,\n  m.tenant_client_id\n\nFROM `piedotorg-production.website_production.web_intent_engine_offer` we\nLEFT JOIN `piedotorg-production.fact_tables_dev.request_offer_campaign_mapping` m\n  ON we.request_id = m.request_id\n  AND we.offer_id = m.offer_id",
      "dependencies": [
        "web_intent_engine_offer",
        "request_offer_campaign_mapping"
      ]
    },
    "int_fe_offer": {
      "name": "int_fe_offer",
      "filePath": "fact_tables/int_fe_offer.sqlx",
      "type": "table",
      "schema": "fact_tables_dev",
      "tags": [
        "fact_tables",
        "frontend_offers",
        "enriched"
      ],
      "description": "Intermediate table that unions all frontend offer events (AI, Extension, Web) with backend mapping data. Single source of truth for enriched frontend events with campaign/offer metadata.",
      "config": {
        "type": "table",
        "schema": "fact_tables_dev",
        "tags": [
          "fact_tables",
          "frontend_offers",
          "enriched"
        ],
        "description": "Intermediate table that unions all frontend offer events (AI, Extension, Web) with backend mapping data. Single source of truth for enriched frontend events with campaign/offer metadata.",
        "bigquery": {
          "partitionBy": "DATE(event_ts)",
          "clusterBy": [
            "source_type",
            "action",
            "campaign_id",
            "merchant_id"
          ]
        }
      },
      "sqlContent": "\n\n-- Unified frontend offer events with backend mapping enrichment\n-- Combines all frontend sources (AI, Extension, Web) with request_offer_campaign_mapping\nWITH unified_frontend AS (\n  -- AI events\n  SELECT\n    request_id,\n    offer_id,\n    TIMESTAMP_MILLIS(timestamp_ms) AS event_ts,\n    CASE\n      WHEN action IN ('show', 'view') THEN 'impression'\n      WHEN action = 'click' THEN 'click'\n      WHEN action = 'close' THEN 'dismissal'\n      ELSE COALESCE(action, 'unknown')\n    END AS action,\n    action AS original_action,\n    user_id,\n    id AS anonymous_id,\n    'ai' AS source_type,\n    surface,\n    is_rewards,\n    outbound_url,\n    user_agent,\n    tag_id,\n    NULL AS ext_tag_id,\n    tenant_id,\n    tenant_client_id,\n    tenant_rewards_enabled,\n    NULL AS platform,\n    NULL AS referer_url,\n    NULL AS context_locale,\n    NULL AS context_device_type,\n    NULL AS context_app_name,\n    NULL AS context_app_version,\n    NULL AS context_browser,\n    NULL AS context_browser_version,\n    NULL AS context_device_id,\n    NULL AS context_id,\n    NULL AS context_ip,\n    NULL AS context_library_name,\n    NULL AS context_library_version,\n    NULL AS context_os_os,\n    NULL AS context_os_version,\n    NULL AS context_os_name,\n    NULL AS context_time_zone,\n    NULL AS event,\n    NULL AS event_text,\n    NULL AS loaded_at,\n    NULL AS original_timestamp,\n    NULL AS received_at,\n    NULL AS sent_at,\n    NULL AS uuid_ts\n  FROM `piedotorg-production.backend_analytics.ai_intent_engine_offer`\n  \n  UNION ALL\n  \n  -- Extension events\n  SELECT\n    request_id,\n    offer_id,\n    timestamp AS event_ts,\n    CASE\n      WHEN action IN ('show', 'view') THEN 'impression'\n      WHEN action = 'click' THEN 'click'\n      WHEN action = 'close' THEN 'dismissal'\n      ELSE COALESCE(action, 'unknown')\n    END AS action,\n    action AS original_action,\n    user_id,\n    anonymous_id,\n    'ext' AS source_type,\n    surface,\n    is_rewards,\n    NULL AS outbound_url,\n    context_user_agent AS user_agent,\n    NULL AS tag_id,\n    ext_tag_id,\n    NULL AS tenant_id,\n    NULL AS tenant_client_id,\n    NULL AS tenant_rewards_enabled,\n    platform,\n    referer_url,\n    context_locale,\n    context_device_type,\n    context_app_name,\n    context_app_version,\n    context_browser,\n    context_browser_version,\n    context_device_id,\n    context_id,\n    context_ip,\n    context_library_name,\n    context_library_version,\n    context_os_os,\n    context_os_version,\n    context_os_name,\n    context_time_zone,\n    event,\n    event_text,\n    loaded_at,\n    original_timestamp,\n    received_at,\n    sent_at,\n    uuid_ts\n  FROM `piedotorg-production.shopping_extension_production.ext_intent_engine_offer`\n  \n  UNION ALL\n  \n  -- Web events\n  SELECT\n    request_id,\n    offer_id,\n    timestamp AS event_ts,\n    CASE\n      WHEN action IN ('show', 'view') THEN 'impression'\n      WHEN action = 'click' THEN 'click'\n      WHEN action = 'close' THEN 'dismissal'\n      ELSE COALESCE(action, 'unknown')\n    END AS action,\n    action AS original_action,\n    user_id,\n    anonymous_id,\n    'web' AS source_type,\n    surface,\n    is_rewards,\n    NULL AS outbound_url,\n    context_user_agent AS user_agent,\n    NULL AS tag_id,\n    NULL AS ext_tag_id,\n    NULL AS tenant_id,\n    NULL AS tenant_client_id,\n    NULL AS tenant_rewards_enabled,\n    NULL AS platform,\n    NULL AS referer_url,\n    context_locale,\n    context_device_type,\n    NULL AS context_app_name,\n    NULL AS context_app_version,\n    NULL AS context_browser,\n    NULL AS context_browser_version,\n    NULL AS context_device_id,\n    NULL AS context_id,\n    NULL AS context_ip,\n    NULL AS context_library_name,\n    NULL AS context_library_version,\n    NULL AS context_os_os,\n    NULL AS context_os_version,\n    NULL AS context_os_name,\n    context_timezone AS context_time_zone,\n    event,\n    event_text,\n    loaded_at,\n    original_timestamp,\n    received_at,\n    sent_at,\n    uuid_ts\n  FROM `piedotorg-production.website_production.web_intent_engine_offer`\n)\n\n-- Join frontend events with backend mapping data\nSELECT\n  -- Core identifiers\n  fe.request_id,\n  fe.offer_id,\n  \n  -- Timestamps\n  fe.event_ts,\n  m.backend_ts,\n  UNIX_MILLIS(m.backend_ts) AS timestamp_ms,\n  \n  -- Actions\n  fe.action,\n  fe.original_action,\n  \n  -- User identifiers\n  COALESCE(m.user_id, fe.user_id) AS user_id,\n  fe.anonymous_id,\n  m.device_id,\n  \n  -- Source identification\n  fe.source_type,\n  m.intent_engine_type,\n  fe.surface,\n  fe.is_rewards,\n  \n  -- Campaign/Offer metadata from mapping\n  m.campaign_id,\n  m.merchant_id,\n  m.req_offer,\n  m.top_offer,\n  m.offer_award,\n  m.offer_content,\n  m.offer_cta,\n  m.campaign_boost,\n  m.campaign_active,\n  m.campaign_state,\n  m.campaign_budget,\n  m.offergroup_id,\n  m.offergroup_min_bid,\n  m.offergroup_max_bid,\n  m.offergroup_bid_type,\n  \n  -- Placement fields from mapping\n  m.first_placement_template,\n  m.first_placement_id,\n  m.first_placement_match,\n  m.first_placement_hostname,\n  m.placement_count,\n  \n  -- Search context from mapping\n  m.keywords,\n  \n  -- Source-specific fields from frontend\n  fe.outbound_url,\n  fe.user_agent,\n  fe.tag_id,\n  fe.ext_tag_id,\n  COALESCE(fe.tenant_id, m.tenant_id) AS tenant_id,\n  COALESCE(fe.tenant_client_id, m.tenant_client_id) AS tenant_client_id,\n  fe.tenant_rewards_enabled,\n  fe.platform,\n  fe.referer_url,\n  fe.context_locale,\n  fe.context_device_type,\n  \n  -- Context fields from frontend\n  fe.context_app_name,\n  fe.context_app_version,\n  fe.context_browser,\n  fe.context_browser_version,\n  fe.context_device_id,\n  fe.context_id,\n  fe.context_ip,\n  fe.context_library_name,\n  fe.context_library_version,\n  fe.context_os_os,\n  fe.context_os_version,\n  fe.context_os_name,\n  fe.context_time_zone,\n  fe.event,\n  fe.event_text,\n  fe.loaded_at,\n  fe.original_timestamp,\n  fe.received_at,\n  fe.sent_at,\n  fe.uuid_ts\n\nFROM unified_frontend fe\nLEFT JOIN `piedotorg-production.fact_tables_dev.request_offer_campaign_mapping` m\n  ON fe.request_id = m.request_id\n  AND fe.offer_id = m.offer_id\n  -- Special matching for AI offers using tenant_client_id (handle NULL values)\n  AND (fe.source_type != 'ai' OR COALESCE(fe.tenant_client_id, '') = COALESCE(m.tenant_client_id, ''))",
      "dependencies": [
        "ai_intent_engine_offer",
        "ext_intent_engine_offer",
        "web_intent_engine_offer",
        "request_offer_campaign_mapping"
      ]
    },
    "request_offer_campaign_mapping": {
      "name": "request_offer_campaign_mapping",
      "filePath": "fact_tables/request_offer_campaign_mapping.sqlx",
      "type": "table",
      "schema": "fact_tables_dev",
      "tags": [
        "fact_tables",
        "mapping",
        "intent_engine"
      ],
      "description": "Mapping table that joins backend offer data with campaign and tenant information. Provides a clean reference for request-offer-campaign relationships without event duplication.",
      "config": {
        "type": "table",
        "schema": "fact_tables_dev",
        "tags": [
          "fact_tables",
          "mapping",
          "intent_engine"
        ],
        "description": "Mapping table that joins backend offer data with campaign and tenant information. Provides a clean reference for request-offer-campaign relationships without event duplication.",
        "bigquery": {
          "partitionBy": "DATE(backend_ts)",
          "clusterBy": [
            "campaign_id",
            "merchant_id",
            "offer_id"
          ]
        }
      },
      "sqlContent": "\n\n-- Request-Offer-Campaign mapping table\n-- This provides a clean reference without event duplication\nWITH backend_offers AS (\n  SELECT DISTINCT\n    -- Request level\n    request_id,\n    TIMESTAMP_MILLIS(timestamp_ms) AS backend_ts,\n    device_id,\n    user_id,\n    placement_hashes,\n    \n    -- Offer level  \n    offer_id,\n    offer_content,\n    offer_click_url,\n    offer_cta,\n    offer_award,\n    offer_distribution,\n    top_offer,\n    \n    -- Campaign level (from backend)\n    campaign_id,\n    campaign_boost,\n    \n    -- Merchant level\n    merchant_id,\n    \n    -- Offer group level\n    offergroup_id,\n    offergroup_min_bid,\n    offergroup_max_bid,\n    offergroup_bid_type,\n    \n    -- Tenant level\n    tenant_id,\n    tenant_client_id,\n    \n    -- Source info\n    intent_engine_type,\n    client,\n    \n    -- Search context\n    keywords,\n    \n    -- Composite key\n    CONCAT(request_id, '|', offer_id) AS req_offer\n    \n  FROM `piedotorg-production.backend_analytics.intent_engine_offer_group_match`\n  WHERE request_id IS NOT NULL\n    AND offer_id IS NOT NULL\n),\n\n-- Get placement data\nplacement_data AS (\n  SELECT DISTINCT\n    placementHash,\n    template,\n    placementId,\n    match,\n    hostname,\n    offerGroupId\n  FROM `piedotorg-production.analytics_etl.campaigns_placements`\n),\n\n-- Get campaign metadata\ncampaign_data AS (\n  SELECT \n    campaignId,\n    merchantId,\n    budget,\n    TIMESTAMP_MILLIS(created) AS campaign_created_ts,\n    COALESCE(TIMESTAMP_MILLIS(updated), TIMESTAMP_MILLIS(created)) AS campaign_updated_ts,\n    CASE \n      WHEN endDate IS NOT NULL THEN TIMESTAMP_MILLIS(endDate)\n      WHEN state IN ('PAUSED', 'ENDED', 'CANCELLED', 'ARCHIVED') THEN COALESCE(TIMESTAMP_MILLIS(updated), TIMESTAMP_MILLIS(created))\n      ELSE NULL \n    END AS campaign_ended_ts,\n    CASE WHEN state = 'ACTIVE' THEN true ELSE false END AS campaign_active,\n    state AS campaign_state,\n    CASE WHEN startDate IS NOT NULL THEN TIMESTAMP_MILLIS(startDate) ELSE TIMESTAMP_MILLIS(created) END AS campaign_start_ts\n  FROM `piedotorg-production.analytics_etl.campaigns_campaigns`\n)\n\nSELECT\n  -- Request level\n  bo.request_id,\n  bo.backend_ts,\n  bo.device_id,\n  bo.user_id,\n  bo.placement_hashes,\n  \n  -- Offer level\n  bo.offer_id,\n  bo.offer_content,\n  bo.offer_click_url,\n  bo.offer_cta,\n  bo.offer_award,\n  bo.offer_distribution,\n  bo.top_offer,\n  \n  -- Campaign level (merged)\n  bo.campaign_id,\n  bo.campaign_boost,\n  cd.campaign_active,\n  cd.campaign_state,\n  cd.budget AS campaign_budget,\n  cd.campaign_created_ts,\n  cd.campaign_updated_ts,\n  cd.campaign_ended_ts,\n  cd.campaign_start_ts,\n  \n  -- Merchant level\n  bo.merchant_id,\n  \n  -- Offer group level\n  bo.offergroup_id,\n  bo.offergroup_min_bid,\n  bo.offergroup_max_bid,\n  bo.offergroup_bid_type,\n  \n  -- Tenant level\n  bo.tenant_id,\n  bo.tenant_client_id,\n  \n  -- Source info\n  bo.intent_engine_type,\n  bo.client,\n  \n  -- Composite key\n  bo.req_offer,\n  \n  -- Placement fields (from first matching placement)\n  pd.template AS first_placement_template,\n  pd.placementId AS first_placement_id,\n  pd.match AS first_placement_match,\n  pd.hostname AS first_placement_hostname,\n  ARRAY_LENGTH(bo.placement_hashes) AS placement_count,\n  \n  -- Search context\n  bo.keywords\n\nFROM backend_offers bo\nLEFT JOIN campaign_data cd\n  ON bo.campaign_id = cd.campaignId\n  AND bo.merchant_id = cd.merchantId\n  -- Only join campaigns that were active during the offer\n  AND DATE(bo.backend_ts) >= DATE(cd.campaign_start_ts)\n--  AND (cd.campaign_ended_ts IS NULL OR DATE(bo.backend_ts) <= DATE(cd.campaign_ended_ts))\nLEFT JOIN placement_data pd\n  ON pd.placementHash = bo.placement_hashes[SAFE_OFFSET(0)]  -- Join on first placement hash\n  AND pd.offerGroupId = bo.offergroup_id",
      "dependencies": [
        "intent_engine_offer_group_match",
        "campaigns_placements",
        "campaigns_campaigns"
      ]
    },
    "all_campaigns": {
      "name": "all_campaigns",
      "filePath": "growth/all_campaigns.sqlx",
      "type": "table",
      "schema": "growth_marketing",
      "tags": [
        "growth",
        "campaigns",
        "daily",
        "marketing"
      ],
      "description": "Consolidated campaign data from all marketing channels including paid campaigns, influencer spend, and manual CPM data",
      "config": {
        "type": "table",
        "schema": "growth_marketing",
        "tags": [
          "growth",
          "campaigns",
          "daily",
          "marketing"
        ],
        "description": "Consolidated campaign data from all marketing channels including paid campaigns, influencer spend, and manual CPM data",
        "bigquery": {
          "partitionBy": "date",
          "clusterBy": [
            "source",
            "placement",
            "puci"
          ]
        }
      },
      "sqlContent": "\n\nWITH\n  \n  influencer_data AS (\n    SELECT\n      influencer_name,\n      vanity_url,\n      puci,\n      cost,\n      SAFE_CAST(start_date AS DATE) start_date,\n      amortize_days\n    FROM `piedotorg-production.growth_marketing.dpr_manual_spend`\n  ),\n  \n  publisher_cpms AS (\n    SELECT \n      NET.REG_DOMAIN(website) AS domain,\n      concept,\n      puci,\n      cpm,\n      SAFE_CAST(start_date AS DATE) start_date,\n      SAFE_CAST(end_date AS DATE) end_date\n    FROM `piedotorg-production.growth_marketing.dpr_manual_publisher_cpms`\n    where puci is not null\n  ),\n  \n  expanded_data AS (\n    SELECT\n      influencer_name,\n      vanity_url,\n      puci,\n      cost,\n      amortize_days,\n      DATE_ADD(start_date, INTERVAL day_offset DAY) AS date,\n      cost / amortize_days AS daily_cost\n    FROM\n      influencer_data,\n      UNNEST(GENERATE_ARRAY(0, amortize_days - 1)) AS day_offset\n  ),\n  \n  influencer_daily AS (\n    SELECT\n      date,\n      'infl' AS source,\n      influencer_name AS campaign_name,\n      puci,\n      CAST(NULL AS STRING) AS ad_set_name,\n      NULL AS impressions,\n      NULL AS clicks,\n      daily_cost AS cost,\n      NULL AS conversions_app_installs,\n      NULL AS conversions_ext_installs\n    FROM expanded_data\n  ),\n  \n  apple_campaigns AS (\n    SELECT\n      date,\n      'apple' AS source,\n      campaign_name,\n      puci,\n      CAST(NULL AS STRING) AS ad_set_name,\n      impressions,\n      clicks,\n      cost,\n      conversions_app_installs,\n      NULL AS conversions_ext_installs\n    FROM `piedotorg-production.growth_marketing.apple_search_campaign_funnel`\n  ),\n  \n  google_campaigns AS (\n    SELECT\n      date,\n      'google' AS source,\n      campaign_name,\n      -- temp hack to get pmax\n      IF(SPLIT(campaign_name, '_')[SAFE_OFFSET(3)] IN (\"pmax\", \"pmax-desktop\", \"pmax-mobile\"), \n         campaign_name, puci) AS puci,\n      CAST(NULL AS STRING) AS ad_set_name,\n      impressions,\n      clicks,\n      cost,\n      NULL AS conversions_app_installs,\n      conversions_ext_installs\n    FROM `piedotorg-production.growth_marketing.google_campaign_funnel`\n  ),\n  \n  msft_campaigns AS (\n    SELECT\n      date,\n      'microsoft' AS source,\n      campaign_name,\n      ad_group_name AS puci,\n      ad_group_name AS ad_set_name,\n      impressions,\n      clicks,\n      cost,\n      NULL AS conversions_app_installs,\n      conversions AS conversions_ext_installs\n    FROM `piedotorg-production.growth_marketing.msft_campaign_funnel`\n  ),\n  \n  amazon_campaigns AS (\n    SELECT\n      date,\n      'amazon_dsp' AS source,\n      campaign_name,\n      ad_name AS puci,\n      ad_group_name AS ad_set_name,\n      impressions,\n      clicks,\n      cost,\n      NULL AS conversions_app_installs,\n      conversions AS conversions_ext_installs\n    FROM `piedotorg-production.growth_marketing.amazon_dsp_campaign_funnel`\n  ),\n  \n  meta_campaigns AS (\n    SELECT\n      date,\n      'meta' AS source,\n      campaign_name,\n      puci,\n      ad_set_name,\n      impressions,\n      clicks,\n      costs AS cost,\n      NULL AS conversions_app_installs,\n      NULL AS conversions_ext_installs\n    FROM `piedotorg-production.growth_marketing.meta_campaign_funnel`\n  ),\n  \n  tik_tok_campaigns AS (\n    SELECT\n      date,\n      'tiktok' AS source,\n      campaign_name,\n      puci,\n      ad_group_name AS ad_set_name,\n      impressions,\n      clicks,\n      cost,\n      conversions_app_installs,\n      NULL AS conversions_ext_installs\n    FROM `piedotorg-production.growth_marketing.tiktok_ads_campaign_funnel`\n  ),\n  \n  bizdev AS (\n    SELECT\n      date,\n      'bizdev_manual' AS source,\n      CAST(NULL AS STRING) AS campaign_name,\n      puci,\n      CAST(NULL AS STRING) AS ad_set_name,\n      NULL AS impressions,\n      NULL AS clicks,\n      SUM(payout_total) AS cost,\n      NULL AS conversions_app_installs,\n      NULL AS conversions_ext_installs\n    FROM `piedotorg-production.growth_marketing_dev.bizdev_spend`\n    WHERE cpi > 0  -- Only include countries with actual CPI rates for cost calculations\n    GROUP BY date, puci\n  ),\n  \n  impression_cost AS (\n    -- Step 1: count events per pixel and cap at 2\n    WITH pixel_daily AS (\n      SELECT\n        DATE(TIMESTAMP_MILLIS(timestamp), 'America/Los_Angeles') AS date,\n        NET.REG_DOMAIN(url) AS domain,\n        pixel_id,\n        COUNT(*) AS ev_count\n      FROM `piedotorg-production.backend_analytics.pixel`\n      WHERE source = 'wall_view'\n      GROUP BY date, domain, pixel_id\n    )\n    -- Step 2: sum the capped impressions per day/domain\n    SELECT\n      a.date,\n      'manual_cpms' AS source,\n      CAST(NULL AS STRING) AS campaign_name,\n      publisher_cpms.puci,\n      CAST(NULL AS STRING) AS ad_set_name,\n      a.pxid_impressions AS impressions,\n      NULL AS clicks,\n      a.pxid_impressions *\n        IF((a.date BETWEEN publisher_cpms.start_date AND publisher_cpms.end_date)\n           OR (a.date >= publisher_cpms.start_date AND publisher_cpms.end_date IS NULL),\n           publisher_cpms.cpm, 0) / 1000 AS cost,\n      NULL AS conversions_app_installs,\n      NULL AS conversions_ext_installs\n    FROM (\n      SELECT\n        date,\n        domain,\n        SUM(LEAST(ev_count, 2)) AS pxid_impressions\n      FROM pixel_daily\n      GROUP BY date, domain\n    ) AS a\n    LEFT JOIN publisher_cpms ON a.domain = publisher_cpms.domain\n    WHERE publisher_cpms.puci IS NOT NULL\n  ),\n  \n  -- Combine all campaign sources\n  all_campaigns_union AS (\n    SELECT * FROM apple_campaigns\n    UNION ALL\n    SELECT * FROM google_campaigns\n    UNION ALL\n    SELECT * FROM amazon_campaigns\n    UNION ALL\n    SELECT * FROM meta_campaigns\n    UNION ALL\n    SELECT * FROM tik_tok_campaigns\n    UNION ALL\n    SELECT * FROM influencer_daily\n    UNION ALL\n    SELECT * FROM bizdev\n    UNION ALL\n    SELECT * FROM msft_campaigns \n    UNION ALL\n    SELECT * FROM impression_cost\n  ),\n  \n  -- Add PUCI parsing and aggregation to prevent duplicates\n  final AS (\n    SELECT\n      date,\n      source,\n      campaign_name,\n      puci,\n      ad_set_name,\n      SUM(impressions) AS impressions,\n      SUM(clicks) AS clicks,\n      SUM(cost) AS cost,\n      SUM(conversions_app_installs) AS conversions_app_installs,\n      SUM(conversions_ext_installs) AS conversions_ext_installs,\n      SPLIT(puci, '_')[SAFE_OFFSET(2)] AS puci_geo,\n      SPLIT(puci, '_')[SAFE_OFFSET(3)] AS placement,\n      `piedotorg-production.data_science.TopN`(puci, '_', 16) AS puci_16,\n      `piedotorg-production.data_science.TopN`(puci, '_', 8) AS puci_8\n    FROM all_campaigns_union\n    GROUP BY date, source, campaign_name, puci, ad_set_name, puci_geo, placement, puci_16, puci_8\n  )\n\nSELECT\n  final.*,\n  mapping.platform,\n  mapping.media_source,\n  mapping.spend_type,\n  mapping.funnel,\n  mapping.device_target\nFROM final\nLEFT JOIN `piedotorg-production.growth_marketing.dpr_manual_mapping` mapping\n  USING (placement)",
      "dependencies": [
        "dpr_manual_spend",
        "dpr_manual_publisher_cpms",
        "apple_search_campaign_funnel",
        "google_campaign_funnel",
        "msft_campaign_funnel",
        "amazon_dsp_campaign_funnel",
        "meta_campaign_funnel",
        "tiktok_ads_campaign_funnel",
        "bizdev_spend",
        "dpr_manual_mapping"
      ]
    },
    "bizdev_spend": {
      "name": "bizdev_spend",
      "filePath": "growth/bizdev_spend.sqlx",
      "type": "table",
      "schema": "growth_marketing_dev",
      "tags": [
        "growth",
        "bizdev",
        "daily"
      ],
      "description": "Business development spend calculations based on CPI rates and extension install data",
      "config": {
        "type": "table",
        "schema": "growth_marketing_dev",
        "tags": [
          "growth",
          "bizdev",
          "daily"
        ],
        "description": "Business development spend calculations based on CPI rates and extension install data",
        "bigquery": {
          "partitionBy": "date",
          "clusterBy": [
            "puci",
            "placement",
            "product"
          ]
        }
      },
      "sqlContent": "\n\nWITH\n  cpi_manual AS (\n    SELECT\n      geo,\n      placement,\n      puci,\n      cpi, \n      CAST(start_date AS DATE) start_date,\n      ifnull(CAST(end_date AS DATE), current_date(\"America/Los_Angeles\")) end_date\n    FROM\n      `piedotorg-production.growth_marketing.dpr_manual_external`\n  ),\n  \n  adblock_installs AS (\n    SELECT\n      DATE(timestamp, 'America/Los_Angeles') AS date,\n      context_locale,\n      anonymous_id AS ext_anonymous_id,\n      extension_type,\n      context_country,\n      puci, -- this accounts for pre 1.1.1 pucis in the installs_base logic\n      placement,\n      product,\n      CASE\n        WHEN context_country IS NOT NULL THEN context_country\n        WHEN context_locale IN ('en-US', 'es-US') THEN 'US'\n        WHEN context_locale IN ('en-AU') THEN 'AU'\n        WHEN context_locale IN ('en-CA', 'fr-CA') THEN 'CA'\n        WHEN context_locale IN ('en-GB', 'en-GB-oxendict', 'en') THEN 'GB'\n        WHEN context_locale IN ('en-DE', 'de', 'de-DE') THEN 'DE'\n        ELSE \"OTHER_LOCALE\" -- this is for pre 2/25 context_country being added\n      END AS country_coalesce\n    FROM `piedotorg-production.growth_marketing.installs_base_w_reinstall`\n    WHERE\n      extension_type IN ('adblock', 'adblocker') \n      AND IFNULL(NOT is_synced_install, is_first_install)\n      AND puci IS NOT NULL\n      AND placement IS NOT NULL\n      AND product IS NOT NULL\n  ),\n  \n  base AS (\n    SELECT\n      date,\n      adblock_installs.placement,\n      product,\n      adblock_installs.puci,\n      country_coalesce,\n      MAX(IF(date BETWEEN start_date AND end_date, cpi, 0)) as cpi, -- get the actual CPI rate\n      FORMAT_DATE('%Y-%m', date) AS year_month,\n      COUNT(DISTINCT ext_anonymous_id) AS extension_install_count\n    FROM\n      adblock_installs\n    LEFT JOIN\n      cpi_manual\n    ON\n      cpi_manual.geo = adblock_installs.country_coalesce\n      AND adblock_installs.placement = cpi_manual.placement\n      AND ((cpi_manual.puci IS NOT NULL AND adblock_installs.puci = cpi_manual.puci)\n           OR (cpi_manual.puci IS NULL))\n    GROUP BY date, placement, product, puci, country_coalesce, year_month\n  )\n\nSELECT\n  date,\n  country_coalesce,\n  placement,\n  puci,\n  product,\n  extension_install_count,\n  cpi,\n  cpi AS payout_amount,\n  cpi * extension_install_count AS payout_total,\n  year_month\nFROM base",
      "dependencies": [
        "dpr_manual_external",
        "installs_base_w_reinstall"
      ]
    },
    "int_publisher_cpms": {
      "name": "int_publisher_cpms",
      "filePath": "growth_int/int_publisher_cpms.sqlx",
      "type": "view",
      "schema": "growth_int_dev",
      "tags": [
        "growth",
        "intermediate"
      ],
      "config": {
        "type": "view",
        "schema": "growth_int_dev",
        "tags": [
          "growth",
          "intermediate"
        ]
      },
      "sqlContent": "-- int_publisher_cpms.sqlx\n-- Intermediate view for publisher_cpms logic from the original query\n-- Dataset: growth_int\n-- Debug: This view extracts publisher CPM data for further processing\n\n\n\nselect\n  net.reg_domain(website) as domain,\n  concept,\n  puci,\n  cpm,\n  SAFE_CAST(start_date AS date) as start_date,\n  SAFE_CAST(end_date as date) as end_date\nfrom\n    `piedotorg-production.growth_marketing.dpr_manual_publisher_cpms` l\n-- Debug: End of int_publisher_cpms view ",
      "dependencies": [
        "dpr_manual_publisher_cpms"
      ]
    },
    "offer_campaign_ir_base": {
      "name": "offer_campaign_ir_base",
      "filePath": "intent_engine/offer_campaign_ir_base.sqlx",
      "type": "table",
      "schema": "intent_engine_dev",
      "tags": [
        "campaign_analytics"
      ],
      "description": "Base table for offer campaign metrics using GROUPING SETS for multi-grain aggregation - single source of truth. In dev environments, filters to last 7 days of offer data and 30 days of transaction data for faster processing. Fixed Cartesian product issue. Includes consideration metrics for AI offers.",
      "config": {
        "type": "table",
        "schema": "intent_engine_dev",
        "tags": [
          "campaign_analytics"
        ],
        "description": "Base table for offer campaign metrics using GROUPING SETS for multi-grain aggregation - single source of truth. In dev environments, filters to last 7 days of offer data and 30 days of transaction data for faster processing. Fixed Cartesian product issue. Includes consideration metrics for AI offers.",
        "bigquery": {
          "partitionBy": "DATE(dt)",
          "clusterBy": [
            "period",
            "campaign_id",
            "merchant_id"
          ]
        }
      },
      "sqlContent": "\n\n\n\n-- Base Campaign Analytics using ROLLUP/GROUPING SETS for multi-grain aggregation\nWITH \n-- Base data from offer_expanded_view\noffer_base AS (\n  SELECT\n    DATETIME(oe.ts) AS ts,\n    DATETIME_TRUNC(DATETIME(oe.ts), HOUR) AS dt_hour,\n    oe.campaign_id,\n    oe.merchant_id,\n    oe.anonymous_id,\n    oe.user_id,\n    oe.request_id,\n    oe.offer_id,\n    oe.action,\n    oe.surface,\n    oe.offer_presented,\n    oe.source_type,\n    oe.intent_engine_type,\n    oe.req_offer\n  FROM `piedotorg-production.intent_engine_dev.offer_expanded_view` oe\n  WHERE oe.campaign_id IS NOT NULL\n    AND oe.merchant_id IS NOT NULL\n    -- Include both frontend events (with actions) and backend-only events (considerations without frontend)\n    AND (oe.action IN ('show', 'view', 'click', 'close', 'redeem') OR oe.action IS NULL)\n    AND DATE(oe.ts) >= '1970-01-01'\n),\n\n-- Campaign metadata\ncampaign_data AS (\n  SELECT \n    campaignId,\n    budget,\n    merchantId,\n    DATETIME(TIMESTAMP_MILLIS(created)) AS campaign_created_ts,\n    DATETIME(COALESCE(TIMESTAMP_MILLIS(updated), TIMESTAMP_MILLIS(created))) AS campaign_updated_ts,\n    CASE \n      WHEN endDate IS NOT NULL THEN DATETIME(TIMESTAMP_MILLIS(endDate))\n      WHEN state IN ('PAUSED', 'ENDED', 'CANCELLED', 'ARCHIVED') THEN DATETIME(COALESCE(TIMESTAMP_MILLIS(updated), TIMESTAMP_MILLIS(created)))\n      ELSE NULL \n    END AS campaign_ended_ts,\n    CASE WHEN state = 'ACTIVE' THEN true ELSE false END AS active,\n    state AS campaign_state,\n    CASE WHEN startDate IS NOT NULL THEN DATETIME(TIMESTAMP_MILLIS(startDate)) ELSE DATETIME(TIMESTAMP_MILLIS(created)) END AS campaign_start_ts\n  FROM `piedotorg-production.analytics_etl.campaigns_campaigns`\n),\n\n-- Transaction data for affiliate attribution\ntransactions_base AS (\n  SELECT\n    DATETIME(created_coalesce_ts) AS created_ts,\n    transactionId,\n    anonymous_id,\n    CASE \n      WHEN merchantId = 'verizon' AND IFNULL(externalSaleValue, 0) = 0 \n      THEN externalCommission \n      ELSE externalSaleValue \n    END AS externalSaleValue,\n    externalCommission,\n    CASE WHEN merchantId = 'logitechg' THEN 'logitech' ELSE merchantId END AS merchantId,\n    adOfferId,\n    campaignId AS adoffercampaignId,\n    subsrc,\n    userId,\n    type,\n    balance_burned_millipoints,\n    millipoints,\n    LOWER(adOfferType) AS transaction_type\n  FROM `piedotorg-production.data_science_dev.transactions_expanded_view`\n  WHERE (\n    -- AD_OFFER transactions need campaignId (direct offer claims)\n    (type = 'AD_OFFER' AND campaignId IS NOT NULL)\n    OR \n    -- AFFILIATE transactions can have NULL campaignId (attribution-based)\n    (type = 'AFFILIATE')\n  )\n  AND DATE(created_coalesce_ts) >= '1970-01-01'\n),\n\n-- Direct affiliate transactions - DAILY ONLY (no hourly breakdown needed)\ndirect_transactions AS (\n  SELECT\n    DATETIME_TRUNC(aff.created_ts, DAY) AS dt_day,\n    aff.adoffercampaignId AS campaign_id,\n    aff.merchantId AS merchant_id,\n    COUNT(*) AS offer_aff_trx,\n    COUNT(DISTINCT aff.anonymous_id) AS trx_anonymous_ids,\n    COUNT(DISTINCT aff.userId) AS trx_devices, -- Using userId as device proxy\n    COUNT(DISTINCT aff.transactionId) AS dist_trx_offer_aff,\n    SUM(aff.externalSaleValue) / 100 AS gmv_dollars,\n    SUM(aff.externalCommission) / 100 AS commission_dollars\n  FROM transactions_base aff\n  INNER JOIN transactions_base offer \n    ON aff.userId = offer.userId \n    AND aff.merchantId = offer.merchantId\n    AND aff.created_ts BETWEEN offer.created_ts AND COALESCE(\n      -- Use campaign end logic similar to old version\n      DATETIME_ADD(offer.created_ts, INTERVAL 30 DAY), \n      CURRENT_DATETIME()\n    )\n  WHERE aff.type = 'AFFILIATE'\n    AND offer.type = 'AD_OFFER'\n    AND aff.subsrc IN ('pie_offer_search', 'pie_offer_retargeting', 'pie_offer_login_search')\n  GROUP BY dt_day, campaign_id, merchant_id\n),\n\n-- Budget and awards tracking - DAILY ONLY (no hourly breakdown needed)\nbudget_awards AS (\n  SELECT\n    DATETIME_TRUNC(created_ts, DAY) AS dt_day,\n    adoffercampaignId AS campaign_id,\n    merchantId AS merchant_id,\n    SUM(millipoints) / 100000 AS dollars_awarded,\n    SUM(balance_burned_millipoints) / 1000 / 100 AS budget_usedindollars,\n    SUM(balance_burned_millipoints) AS budget_usedinmillipoints,\n    SUM(millipoints) AS millipoints_awarded,\n    COUNT(*) AS unique_awards,\n    COUNT(DISTINCT userId) AS awarded_devices,\n    COUNT(DISTINCT anonymous_id) AS awarded_anonymous_ids,\n    ARRAY_AGG(DISTINCT adOfferId IGNORE NULLS) AS award_offer_ids\n  FROM transactions_base\n  WHERE type = 'AD_OFFER'\n    AND adoffercampaignId IS NOT NULL\n  GROUP BY dt_day, campaign_id, merchant_id\n),\n\n-- Click attribution 24h - affiliate transactions attributed to click events within 24h\nclick_attribution_24h AS (\n  SELECT\n    DATETIME_TRUNC(aff.created_ts, HOUR) AS dt_hour,\n    DATETIME_TRUNC(aff.created_ts, DAY) AS dt_day,\n    click_events.campaign_id,\n    aff.merchantId AS merchant_id,\n    COUNT(*) AS click_transactions_24h,\n    COUNT(DISTINCT aff.anonymous_id) AS click_anonymous_ids_24h,\n    COUNT(DISTINCT aff.userId) AS click_devices_24h,\n    SUM(aff.externalSaleValue) / 100 AS click_gmv_dollars_24h,\n    SUM(aff.externalCommission) / 100 AS click_commission_dollars_24h\n  FROM transactions_base aff\n  INNER JOIN (\n    -- Get click events from our offer_base data\n    SELECT DISTINCT\n      anonymous_id,\n      campaign_id,\n      merchant_id,\n      ts\n    FROM offer_base\n    WHERE action = 'click'\n      AND campaign_id IS NOT NULL\n  ) click_events\n    ON aff.anonymous_id = click_events.anonymous_id\n    AND aff.merchantId = click_events.merchant_id\n    AND DATETIME_DIFF(aff.created_ts, click_events.ts, HOUR) BETWEEN 0 AND 24\n    AND aff.created_ts >= click_events.ts\n  WHERE aff.type = 'AFFILIATE'\n  GROUP BY dt_hour, dt_day, campaign_id, merchant_id\n),\n\n-- Click attribution 7d - affiliate transactions attributed to click events within 7d\nclick_attribution_7d AS (\n  SELECT\n    DATETIME_TRUNC(aff.created_ts, HOUR) AS dt_hour,\n    DATETIME_TRUNC(aff.created_ts, DAY) AS dt_day,\n    click_events.campaign_id,\n    aff.merchantId AS merchant_id,\n    COUNT(*) AS click_transactions_7d,\n    COUNT(DISTINCT aff.anonymous_id) AS click_anonymous_ids_7d,\n    COUNT(DISTINCT aff.userId) AS click_devices_7d,\n    SUM(aff.externalSaleValue) / 100 AS click_gmv_dollars_7d,\n    SUM(aff.externalCommission) / 100 AS click_commission_dollars_7d\n  FROM transactions_base aff\n  INNER JOIN (\n    -- Get click events from our offer_base data\n    SELECT DISTINCT\n      anonymous_id,\n      campaign_id,\n      merchant_id,\n      ts\n    FROM offer_base\n    WHERE action = 'click'\n      AND campaign_id IS NOT NULL\n  ) click_events\n    ON aff.anonymous_id = click_events.anonymous_id\n    AND aff.merchantId = click_events.merchant_id\n    AND DATETIME_DIFF(aff.created_ts, click_events.ts, DAY) BETWEEN 0 AND 7\n    AND aff.created_ts >= click_events.ts\n  WHERE aff.type = 'AFFILIATE'\n  GROUP BY dt_hour, dt_day, campaign_id, merchant_id\n),\n\n-- View attribution 24h - affiliate transactions attributed to show events within 24h\nview_attribution_24h AS (\n  SELECT\n    DATETIME_TRUNC(aff.created_ts, HOUR) AS dt_hour,\n    DATETIME_TRUNC(aff.created_ts, DAY) AS dt_day,\n    view_events.campaign_id,\n    aff.merchantId AS merchant_id,\n    COUNT(*) AS view_transactions_24h,\n    COUNT(DISTINCT aff.anonymous_id) AS view_anonymous_ids_24h,\n    COUNT(DISTINCT aff.userId) AS view_devices_24h,\n    SUM(aff.externalSaleValue) / 100 AS view_gmv_dollars_24h,\n    SUM(aff.externalCommission) / 100 AS view_commission_dollars_24h\n  FROM transactions_base aff\n  INNER JOIN (\n    -- Get show events from our offer_base data\n    SELECT DISTINCT\n      anonymous_id,\n      campaign_id,\n      merchant_id,\n      ts\n    FROM offer_base\n    WHERE action IN ('show', 'view')\n      AND campaign_id IS NOT NULL\n  ) view_events\n    ON aff.anonymous_id = view_events.anonymous_id\n    AND aff.merchantId = view_events.merchant_id\n    AND DATETIME_DIFF(aff.created_ts, view_events.ts, HOUR) BETWEEN 0 AND 24\n    AND aff.created_ts >= view_events.ts\n  WHERE aff.type = 'AFFILIATE'\n  GROUP BY dt_hour, dt_day, campaign_id, merchant_id\n),\n\n-- View attribution 7d - affiliate transactions attributed to show events within 7d\nview_attribution_7d AS (\n  SELECT\n    DATETIME_TRUNC(aff.created_ts, HOUR) AS dt_hour,\n    DATETIME_TRUNC(aff.created_ts, DAY) AS dt_day,\n    view_events.campaign_id,\n    aff.merchantId AS merchant_id,\n    COUNT(*) AS view_transactions_7d,\n    COUNT(DISTINCT aff.anonymous_id) AS view_anonymous_ids_7d,\n    COUNT(DISTINCT aff.userId) AS view_devices_7d,\n    SUM(aff.externalSaleValue) / 100 AS view_gmv_dollars_7d,\n    SUM(aff.externalCommission) / 100 AS view_commission_dollars_7d\n  FROM transactions_base aff\n  INNER JOIN (\n    -- Get show events from our offer_base data\n    SELECT DISTINCT\n      anonymous_id,\n      campaign_id,\n      merchant_id,\n      ts\n    FROM offer_base\n    WHERE action IN ('show', 'view')\n      AND campaign_id IS NOT NULL\n  ) view_events\n    ON aff.anonymous_id = view_events.anonymous_id\n    AND aff.merchantId = view_events.merchant_id\n    AND DATETIME_DIFF(aff.created_ts, view_events.ts, DAY) BETWEEN 0 AND 7\n    AND aff.created_ts >= view_events.ts\n  WHERE aff.type = 'AFFILIATE'\n  GROUP BY dt_hour, dt_day, campaign_id, merchant_id\n),\n\n-- Checkout detection base data\ncheckout_detection_base AS (\n  SELECT\n    DATETIME(timestamp) AS detected_ts,\n    anonymous_id,\n    merchant_id,\n    final_score\n  FROM `piedotorg-production.backend_analytics.checkout_detection`\n  WHERE classified_as_checkout = true\n    AND anonymous_id IS NOT NULL\n    AND merchant_id IS NOT NULL\n),\n\n-- Checkout attribution 24h - checkout detections attributed to click events within 24h\ncheckout_attribution_24h AS (\n  SELECT\n    DATETIME_TRUNC(cd.detected_ts, HOUR) AS dt_hour,\n    DATETIME_TRUNC(cd.detected_ts, DAY) AS dt_day,\n    click_events.campaign_id,\n    cd.merchant_id,\n    COUNT(*) AS checkout_detections_24h,\n    COUNT(DISTINCT cd.anonymous_id) AS checkout_anonymous_ids_24h,\n    AVG(cd.final_score) AS avg_checkout_score_24h\n  FROM checkout_detection_base cd\n  INNER JOIN (\n    -- Get click events from our offer_base data\n    SELECT DISTINCT\n      anonymous_id,\n      campaign_id,\n      merchant_id,\n      ts\n    FROM offer_base\n    WHERE action = 'click'\n      AND campaign_id IS NOT NULL\n  ) click_events\n    ON cd.anonymous_id = click_events.anonymous_id\n    AND cd.merchant_id = click_events.merchant_id\n    AND DATETIME_DIFF(cd.detected_ts, click_events.ts, HOUR) BETWEEN 0 AND 24\n    AND cd.detected_ts >= click_events.ts\n  GROUP BY dt_hour, dt_day, campaign_id, merchant_id\n),\n\n-- Checkout attribution 7d - checkout detections attributed to click events within 7d\ncheckout_attribution_7d AS (\n  SELECT\n    DATETIME_TRUNC(cd.detected_ts, HOUR) AS dt_hour,\n    DATETIME_TRUNC(cd.detected_ts, DAY) AS dt_day,\n    click_events.campaign_id,\n    cd.merchant_id,\n    COUNT(*) AS checkout_detections_7d,\n    COUNT(DISTINCT cd.anonymous_id) AS checkout_anonymous_ids_7d,\n    AVG(cd.final_score) AS avg_checkout_score_7d\n  FROM checkout_detection_base cd\n  INNER JOIN (\n    -- Get click events from our offer_base data\n    SELECT DISTINCT\n      anonymous_id,\n      campaign_id,\n      merchant_id,\n      ts\n    FROM offer_base\n    WHERE action = 'click'\n      AND campaign_id IS NOT NULL\n  ) click_events\n    ON cd.anonymous_id = click_events.anonymous_id\n    AND cd.merchant_id = click_events.merchant_id\n    AND DATETIME_DIFF(cd.detected_ts, click_events.ts, DAY) BETWEEN 0 AND 7\n    AND cd.detected_ts >= click_events.ts\n  GROUP BY dt_hour, dt_day, campaign_id, merchant_id\n),\n\n-- Placement metrics - using GROUPING SETS for consistent multi-grain aggregation\nplacement_metrics AS (\n  SELECT\n    -- Time dimension using GROUPING SETS approach\n    COALESCE(hour_grain, day_grain) AS dt_time,\n    \n    -- Period indicator using GROUPING function\n    CASE \n      WHEN GROUPING(hour_grain) = 0 THEN 'hour'\n      WHEN GROUPING(day_grain) = 0 THEN 'day'\n    END AS grain,\n    \n    campaign_id,\n    merchant_id,\n    COUNT(*) AS total_placements,\n    COUNT(DISTINCT CONCAT(campaign_id, '-', merchant_id, '-', anonymous_id, '-', DATE(ts))) AS total_placement_hashes,\n    COUNT(DISTINCT anonymous_id) AS total_audience_ids\n  FROM (\n    SELECT \n      DATETIME_TRUNC(ts, HOUR) AS hour_grain,\n      DATETIME_TRUNC(ts, DAY) AS day_grain,\n      campaign_id,\n      merchant_id,\n      anonymous_id,\n      ts\n    FROM offer_base\n    WHERE campaign_id IS NOT NULL AND merchant_id IS NOT NULL\n  )\n  \n  -- GROUPING SETS for both hourly and daily aggregation\n  GROUP BY GROUPING SETS (\n    (hour_grain, campaign_id, merchant_id),   -- Hourly grain\n    (day_grain, campaign_id, merchant_id)     -- Daily grain  \n  )\n),\n\n-- User balance and claims tracking - DAILY ONLY (no hourly breakdown needed)\nbalance_claims AS (\n  SELECT\n    DATETIME_TRUNC(created_ts, DAY) AS dt_day,\n    adoffercampaignId AS campaign_id,\n    merchantId AS merchant_id,\n    -- Claims metrics (AD_OFFER transactions are essentially claims)\n    COUNT(*) AS total_claims,\n    COUNT(DISTINCT userId) AS claimed_devices,\n    COUNT(DISTINCT anonymous_id) AS claimed_anonymous_ids,\n    ARRAY_AGG(DISTINCT adOfferId IGNORE NULLS) AS claimed_offer_ids,\n    -- Balance burned metrics (assume millipoints represent burned balance)\n    SUM(millipoints) AS user_balance_burned_millipoints,\n    SUM(millipoints) / 100000 AS user_balance_burned_millipoints_dollars\n  FROM transactions_base\n  WHERE type = 'AD_OFFER'\n    AND adoffercampaignId IS NOT NULL\n    AND millipoints > 0  -- Only count actual balance usage\n  GROUP BY dt_day, campaign_id, merchant_id\n),\n\n-- Prepare time dimensions for GROUPING SETS\ntime_dimensions AS (\n  SELECT\n    ob.*,\n    cd.campaign_created_ts,\n    cd.campaign_updated_ts,\n    cd.campaign_ended_ts,\n    cd.active,\n    cd.budget,\n    cd.campaign_state,\n    cd.campaign_start_ts,\n    -- Pre-calculate both time grains\n    ob.dt_hour AS hour_grain,\n    DATETIME_TRUNC(ob.dt_hour, DAY) AS day_grain\n  FROM offer_base ob\n  LEFT JOIN campaign_data cd ON ob.campaign_id = cd.campaignId AND ob.merchant_id = cd.merchantId\n),\n\n-- Multi-grain aggregation using GROUPING SETS approach with transaction data\nmulti_grain_base AS (\n  SELECT\n    -- Time dimension - use COALESCE to handle NULL from GROUPING SETS\n    COALESCE(td.hour_grain, td.day_grain) AS dt_hour,\n    \n    -- Period indicator using GROUPING function (used for join logic)\n    CASE \n      WHEN GROUPING(td.hour_grain) = 0 THEN 'hour'\n      WHEN GROUPING(td.day_grain) = 0 THEN 'day'\n    END AS period,\n    \n    td.campaign_id,\n    td.merchant_id,\n    td.source_type,\n    td.intent_engine_type,\n    \n    -- Campaign metadata\n    ANY_VALUE(td.campaign_created_ts) AS campaign_created_ts,\n    ANY_VALUE(td.campaign_updated_ts) AS campaign_updated_ts,\n    ANY_VALUE(td.campaign_ended_ts) AS campaign_ended_ts,\n    ANY_VALUE(td.active) AS campaign_active,\n    ANY_VALUE(td.budget) AS campaign_budget,\n    ANY_VALUE(td.campaign_state) AS campaign_state,\n    ANY_VALUE(td.campaign_start_ts) AS campaign_start_ts,\n    \n    CAST([] AS ARRAY<STRUCT<offergroup_id STRING>>) AS offergroups,\n    \n    -- Core engagement metrics with proper COUNT DISTINCT\n    -- These will be correctly deduplicated at both hourly and daily levels\n    \n    -- Consideration metrics (AI offers only - backend events with or without frontend events)\n    COUNT(DISTINCT CASE WHEN td.intent_engine_type IN ('AI', 'MCP') THEN td.user_id END) AS consideration_users,\n    COUNT(DISTINCT CASE WHEN td.intent_engine_type IN ('AI', 'MCP') THEN td.req_offer END) AS considerations,\n    -- COUNT(DISTINCT CASE WHEN td.intent_engine_type = 'AI' THEN td.anonymous_id END) AS consideration_anonymous_ids,\n    \n    -- Expanded surface filters using JavaScript variable\n    COUNT(DISTINCT CASE WHEN td.action IN ('show', 'view') AND td.surface IN ('prompt', 'login_prompt', 'chatgpt', 'chat_gpt', 'gpt', 'ai_offers', 'rewards_transaction_popup', 'offers_popup', 'intent_engine', 'search_prompt', 'retargeting_prompt') AND td.offer_presented = true THEN td.user_id END) AS show_users,\n    COUNT(DISTINCT CASE WHEN td.action IN ('show', 'view') AND td.surface IN ('prompt', 'login_prompt', 'chatgpt', 'chat_gpt', 'gpt', 'ai_offers', 'rewards_transaction_popup', 'offers_popup', 'intent_engine', 'search_prompt', 'retargeting_prompt') AND td.offer_presented = true THEN td.req_offer END) AS shows,\n    COUNT(CASE WHEN td.action IN ('show', 'view') AND td.surface IN ('prompt', 'login_prompt', 'chatgpt', 'chat_gpt', 'gpt', 'ai_offers', 'rewards_transaction_popup', 'offers_popup', 'intent_engine', 'search_prompt', 'retargeting_prompt') AND td.offer_presented = true THEN 1 END) AS shows_raw,\n    -- COUNT(DISTINCT CASE WHEN td.action IN ('show', 'view') AND td.surface IN (${OFFER_SURFACES.map(s => `'${s}'`).join(', ')}) AND td.offer_presented = true THEN td.anonymous_id END) AS show_anonymous_ids,\n    COUNT(DISTINCT CASE WHEN td.action = 'click' AND td.surface IN ('prompt', 'login_prompt', 'chatgpt', 'chat_gpt', 'gpt', 'ai_offers', 'rewards_transaction_popup', 'offers_popup', 'intent_engine', 'search_prompt', 'retargeting_prompt') AND td.offer_presented = true THEN td.user_id END) AS click_users,\n    COUNT(DISTINCT CASE WHEN td.action = 'click' AND td.surface IN ('prompt', 'login_prompt', 'chatgpt', 'chat_gpt', 'gpt', 'ai_offers', 'rewards_transaction_popup', 'offers_popup', 'intent_engine', 'search_prompt', 'retargeting_prompt') AND td.offer_presented = true THEN td.req_offer END) AS clicks,\n    COUNT(CASE WHEN td.action = 'click' AND td.surface IN ('prompt', 'login_prompt', 'chatgpt', 'chat_gpt', 'gpt', 'ai_offers', 'rewards_transaction_popup', 'offers_popup', 'intent_engine', 'search_prompt', 'retargeting_prompt') AND td.offer_presented = true THEN 1 END) AS clicks_raw,\n    -- COUNT(DISTINCT CASE WHEN td.action = 'click' AND td.surface IN (${OFFER_SURFACES.map(s => `'${s}'`).join(', ')}) AND td.offer_presented = true THEN td.anonymous_id END) AS click_anonymous_ids,\n    COUNT(DISTINCT CASE WHEN td.action = 'close' AND td.surface IN ('prompt', 'login_prompt', 'chatgpt', 'chat_gpt', 'gpt', 'ai_offers', 'rewards_transaction_popup', 'offers_popup', 'intent_engine', 'search_prompt', 'retargeting_prompt') AND td.offer_presented = true THEN td.user_id END) AS close_users,\n    COUNT(CASE WHEN td.action = 'close' AND td.surface IN ('prompt', 'login_prompt', 'chatgpt', 'chat_gpt', 'gpt', 'ai_offers', 'rewards_transaction_popup', 'offers_popup', 'intent_engine', 'search_prompt', 'retargeting_prompt') AND td.offer_presented = true THEN 1 END) AS closes,\n    -- COUNT(DISTINCT CASE WHEN td.action = 'close' AND td.surface IN (${OFFER_SURFACES.map(s => `'${s}'`).join(', ')}) AND td.offer_presented = true THEN td.anonymous_id END) AS close_anonymous_ids,\n    COUNT(DISTINCT CASE WHEN td.action = 'redeem' AND td.surface IN ('prompt', 'login_prompt', 'chatgpt', 'chat_gpt', 'gpt', 'ai_offers', 'rewards_transaction_popup', 'offers_popup', 'intent_engine', 'search_prompt', 'retargeting_prompt') AND td.offer_presented = true THEN td.user_id END) AS redeem_users,\n    COUNT(DISTINCT CASE WHEN td.action = 'redeem' AND td.surface IN ('prompt', 'login_prompt', 'chatgpt', 'chat_gpt', 'gpt', 'ai_offers', 'rewards_transaction_popup', 'offers_popup', 'intent_engine', 'search_prompt', 'retargeting_prompt') AND td.offer_presented = true THEN td.req_offer END) AS redeems,\n    COUNT(CASE WHEN td.action = 'redeem' AND td.surface IN ('prompt', 'login_prompt', 'chatgpt', 'chat_gpt', 'gpt', 'ai_offers', 'rewards_transaction_popup', 'offers_popup', 'intent_engine', 'search_prompt', 'retargeting_prompt') AND td.offer_presented = true THEN 1 END) AS redeems_raw,\n    -- COUNT(DISTINCT CASE WHEN td.action = 'redeem' AND td.surface IN (${OFFER_SURFACES.map(s => `'${s}'`).join(', ')}) AND td.offer_presented = true THEN td.anonymous_id END) AS redeem_anonymous_ids,\n    COUNT(DISTINCT CASE WHEN td.action IN ('show', 'view') AND td.surface = 'error_prompt' AND td.offer_presented = true THEN td.user_id END) AS error_users,\n    COUNT(CASE WHEN td.action IN ('show', 'view') AND td.surface = 'error_prompt' AND td.offer_presented = true THEN 1 END) AS errors,\n    -- COUNT(DISTINCT CASE WHEN td.action IN ('show', 'view') AND td.surface = 'error_prompt' AND td.offer_presented = true THEN td.anonymous_id END) AS error_anonymous_ids,\n    \n    -- No-show metrics (Phase 3 - Limited implementation, data not available for all reasons)\n    0 AS no_shows_cooldown, 0 AS no_shows_tied_lost, 0 AS no_shows_not_funded, 0 AS no_shows_lower_bid, 0 AS no_shows_lower_campaign_boost, 0 AS no_shows_lower_offergroup_boost, 0 AS total_no_shows,\n    \n    -- Placement metrics (both hourly and daily using grain-aware JOIN)\n    COALESCE(MAX(pm.total_placements), 0) AS total_placements,\n    COALESCE(MAX(pm.total_placement_hashes), 0) AS total_placement_hashes,\n    COALESCE(MAX(pm.total_audience_ids), 0) AS total_audience_ids, \n    \n    -- Direct transaction metrics (DAILY ONLY - used for both grains)\n    COALESCE(MAX(dt_day.offer_aff_trx), 0) AS offer_aff_trx,\n    COALESCE(MAX(dt_day.trx_devices), 0) AS trx_devices,\n    COALESCE(MAX(dt_day.trx_anonymous_ids), 0) AS trx_anonymous_ids,\n    COALESCE(MAX(dt_day.gmv_dollars), 0.0) AS gmv_dollars,\n    COALESCE(MAX(dt_day.commission_dollars), 0.0) AS commission_dollars,\n    \n    -- Budget and awards metrics (DAILY ONLY - used for both grains)\n    COALESCE(MAX(ba_day.millipoints_awarded), 0) AS millipoints_awarded,\n    COALESCE(MAX(ba_day.dollars_awarded), 0.0) AS dollars_awarded,\n    COALESCE(MAX(ba_day.unique_awards), 0) AS unique_awards,\n    COALESCE(MAX(ba_day.awarded_devices), 0) AS awarded_devices,\n    COALESCE(MAX(ba_day.awarded_anonymous_ids), 0) AS awarded_anonymous_ids,\n    IFNULL(ANY_VALUE(ba_day.award_offer_ids), []) AS award_offer_ids,\n    COALESCE(MAX(ba_day.budget_usedinmillipoints), 0) AS budget_usedinmillipoints,\n    COALESCE(MAX(ba_day.budget_usedindollars), 0.0) AS budget_usedindollars,\n    \n    -- Click attribution metrics (Phase 2 - ALL PERIODS, filtered later)\n    COALESCE(MAX(ca24h_day.click_transactions_24h), 0) AS click_transactions_24h,\n    COALESCE(MAX(ca24h_day.click_devices_24h), 0) AS click_devices_24h,\n    COALESCE(MAX(ca24h_day.click_anonymous_ids_24h), 0) AS click_anonymous_ids_24h,\n    COALESCE(MAX(ca24h_day.click_gmv_dollars_24h), 0.0) AS click_gmv_dollars_24h,\n    COALESCE(MAX(ca24h_day.click_commission_dollars_24h), 0.0) AS click_commission_dollars_24h,\n    COALESCE(MAX(ca7d_day.click_transactions_7d), 0) AS click_transactions_7d,\n    COALESCE(MAX(ca7d_day.click_devices_7d), 0) AS click_devices_7d,\n    COALESCE(MAX(ca7d_day.click_anonymous_ids_7d), 0) AS click_anonymous_ids_7d,\n    COALESCE(MAX(ca7d_day.click_gmv_dollars_7d), 0.0) AS click_gmv_dollars_7d,\n    COALESCE(MAX(ca7d_day.click_commission_dollars_7d), 0.0) AS click_commission_dollars_7d,\n    \n    -- View attribution metrics (Phase 2 - ALL PERIODS, filtered later) \n    COALESCE(MAX(va24h_day.view_transactions_24h), 0) AS view_transactions_24h,\n    COALESCE(MAX(va24h_day.view_devices_24h), 0) AS view_devices_24h,\n    COALESCE(MAX(va24h_day.view_anonymous_ids_24h), 0) AS view_anonymous_ids_24h,\n    COALESCE(MAX(va24h_day.view_gmv_dollars_24h), 0.0) AS view_gmv_dollars_24h,\n    COALESCE(MAX(va24h_day.view_commission_dollars_24h), 0.0) AS view_commission_dollars_24h,\n    COALESCE(MAX(va7d_day.view_transactions_7d), 0) AS view_transactions_7d,\n    COALESCE(MAX(va7d_day.view_devices_7d), 0) AS view_devices_7d,\n    COALESCE(MAX(va7d_day.view_anonymous_ids_7d), 0) AS view_anonymous_ids_7d,\n    COALESCE(MAX(va7d_day.view_gmv_dollars_7d), 0.0) AS view_gmv_dollars_7d,\n    COALESCE(MAX(va7d_day.view_commission_dollars_7d), 0.0) AS view_commission_dollars_7d,\n    \n    -- Checkout attribution metrics (Phase 2 - ALL PERIODS, filtered later)\n    COALESCE(MAX(co24h_day.checkout_detections_24h), 0) AS checkout_detections_24h,\n    COALESCE(MAX(co24h_day.checkout_anonymous_ids_24h), 0) AS checkout_anonymous_ids_24h,\n    COALESCE(MAX(co24h_day.avg_checkout_score_24h), 0.0) AS avg_checkout_score_24h,\n    COALESCE(MAX(co7d_day.checkout_detections_7d), 0) AS checkout_detections_7d,\n    COALESCE(MAX(co7d_day.checkout_anonymous_ids_7d), 0) AS checkout_anonymous_ids_7d,\n    COALESCE(MAX(co7d_day.avg_checkout_score_7d), 0.0) AS avg_checkout_score_7d, \n    \n    -- Balance and claims metrics (DAILY ONLY - used for both grains)\n    COALESCE(MAX(bc_day.user_balance_burned_millipoints), 0) AS user_balance_burned_millipoints,\n    COALESCE(MAX(bc_day.user_balance_burned_millipoints_dollars), 0.0) AS user_balance_burned_millipoints_dollars,\n    COALESCE(MAX(bc_day.total_claims), 0) AS total_claims,\n    COALESCE(MAX(bc_day.claimed_devices), 0) AS claimed_devices,\n    COALESCE(MAX(bc_day.claimed_anonymous_ids), 0) AS claimed_anonymous_ids,\n    IFNULL(ANY_VALUE(bc_day.claimed_offer_ids), []) AS claimed_offer_ids\n    \n  FROM time_dimensions td\n  -- Join direct transaction data (DAILY ONLY - used for both hourly and daily GROUPING SETS)\n  LEFT JOIN direct_transactions dt_day \n    ON dt_day.campaign_id = td.campaign_id \n    AND dt_day.merchant_id = td.merchant_id \n    AND dt_day.dt_day = td.day_grain\n  -- Join budget/awards data (DAILY ONLY - used for both hourly and daily GROUPING SETS)\n  LEFT JOIN budget_awards ba_day \n    ON ba_day.campaign_id = td.campaign_id \n    AND ba_day.merchant_id = td.merchant_id \n    AND ba_day.dt_day = td.day_grain\n  -- Join attribution data (DAILY ONLY - optimized performance)\n  LEFT JOIN click_attribution_24h ca24h_day\n    ON ca24h_day.campaign_id = td.campaign_id \n    AND ca24h_day.merchant_id = td.merchant_id \n    AND ca24h_day.dt_day = td.day_grain\n  LEFT JOIN click_attribution_7d ca7d_day\n    ON ca7d_day.campaign_id = td.campaign_id \n    AND ca7d_day.merchant_id = td.merchant_id \n    AND ca7d_day.dt_day = td.day_grain\n  LEFT JOIN view_attribution_24h va24h_day\n    ON va24h_day.campaign_id = td.campaign_id \n    AND va24h_day.merchant_id = td.merchant_id \n    AND va24h_day.dt_day = td.day_grain\n  LEFT JOIN view_attribution_7d va7d_day\n    ON va7d_day.campaign_id = td.campaign_id \n    AND va7d_day.merchant_id = td.merchant_id \n    AND va7d_day.dt_day = td.day_grain\n  -- Join checkout attribution data (DAILY ONLY - optimized performance)\n  LEFT JOIN checkout_attribution_24h co24h_day\n    ON co24h_day.campaign_id = td.campaign_id \n    AND co24h_day.merchant_id = td.merchant_id \n    AND co24h_day.dt_day = td.day_grain\n  LEFT JOIN checkout_attribution_7d co7d_day\n    ON co7d_day.campaign_id = td.campaign_id \n    AND co7d_day.merchant_id = td.merchant_id \n    AND co7d_day.dt_day = td.day_grain\n  -- Join placement metrics - simply match on the coalesced time and let period handle grain selection\n  LEFT JOIN placement_metrics pm\n    ON pm.campaign_id = td.campaign_id \n    AND pm.merchant_id = td.merchant_id \n    AND pm.dt_time = COALESCE(td.hour_grain, td.day_grain)\n  -- Join balance/claims data (DAILY ONLY - used for both hourly and daily GROUPING SETS)\n  LEFT JOIN balance_claims bc_day\n    ON bc_day.campaign_id = td.campaign_id \n    AND bc_day.merchant_id = td.merchant_id \n    AND bc_day.dt_day = td.day_grain\n  \n  -- GROUPING SETS to get both hourly and daily aggregations in one pass\n  GROUP BY GROUPING SETS (\n    (td.hour_grain, td.campaign_id, td.merchant_id, td.source_type, td.intent_engine_type),  -- Hourly grain\n    (td.day_grain, td.campaign_id, td.merchant_id, td.source_type, td.intent_engine_type)    -- Daily grain\n  )\n),\n\n-- Apply attribution filtering based on period\nmulti_grain_data AS (\n  SELECT\n    *,\n    -- Click attribution metrics (DAILY ONLY to prevent overcounting)\n    CASE WHEN period = 'day' THEN click_transactions_24h ELSE NULL END AS click_transactions_24h_final,\n    CASE WHEN period = 'day' THEN click_devices_24h ELSE NULL END AS click_devices_24h_final,\n    CASE WHEN period = 'day' THEN click_anonymous_ids_24h ELSE NULL END AS click_anonymous_ids_24h_final,\n    CASE WHEN period = 'day' THEN click_gmv_dollars_24h ELSE NULL END AS click_gmv_dollars_24h_final,\n    CASE WHEN period = 'day' THEN click_commission_dollars_24h ELSE NULL END AS click_commission_dollars_24h_final,\n    CASE WHEN period = 'day' THEN click_transactions_7d ELSE NULL END AS click_transactions_7d_final,\n    CASE WHEN period = 'day' THEN click_devices_7d ELSE NULL END AS click_devices_7d_final,\n    CASE WHEN period = 'day' THEN click_anonymous_ids_7d ELSE NULL END AS click_anonymous_ids_7d_final,\n    CASE WHEN period = 'day' THEN click_gmv_dollars_7d ELSE NULL END AS click_gmv_dollars_7d_final,\n    CASE WHEN period = 'day' THEN click_commission_dollars_7d ELSE NULL END AS click_commission_dollars_7d_final,\n    -- View attribution metrics (DAILY ONLY to prevent overcounting)\n    CASE WHEN period = 'day' THEN view_transactions_24h ELSE NULL END AS view_transactions_24h_final,\n    CASE WHEN period = 'day' THEN view_devices_24h ELSE NULL END AS view_devices_24h_final,\n    CASE WHEN period = 'day' THEN view_anonymous_ids_24h ELSE NULL END AS view_anonymous_ids_24h_final,\n    CASE WHEN period = 'day' THEN view_gmv_dollars_24h ELSE NULL END AS view_gmv_dollars_24h_final,\n    CASE WHEN period = 'day' THEN view_commission_dollars_24h ELSE NULL END AS view_commission_dollars_24h_final,\n    CASE WHEN period = 'day' THEN view_transactions_7d ELSE NULL END AS view_transactions_7d_final,\n    CASE WHEN period = 'day' THEN view_devices_7d ELSE NULL END AS view_devices_7d_final,\n    CASE WHEN period = 'day' THEN view_anonymous_ids_7d ELSE NULL END AS view_anonymous_ids_7d_final,\n    CASE WHEN period = 'day' THEN view_gmv_dollars_7d ELSE NULL END AS view_gmv_dollars_7d_final,\n    CASE WHEN period = 'day' THEN view_commission_dollars_7d ELSE NULL END AS view_commission_dollars_7d_final,\n    -- Checkout attribution metrics (DAILY ONLY to prevent overcounting)\n    CASE WHEN period = 'day' THEN checkout_detections_24h ELSE NULL END AS checkout_detections_24h_final,\n    CASE WHEN period = 'day' THEN checkout_anonymous_ids_24h ELSE NULL END AS checkout_anonymous_ids_24h_final,\n    CASE WHEN period = 'day' THEN avg_checkout_score_24h ELSE NULL END AS avg_checkout_score_24h_final,\n    CASE WHEN period = 'day' THEN checkout_detections_7d ELSE NULL END AS checkout_detections_7d_final,\n    CASE WHEN period = 'day' THEN checkout_anonymous_ids_7d ELSE NULL END AS checkout_anonymous_ids_7d_final,\n    CASE WHEN period = 'day' THEN avg_checkout_score_7d ELSE NULL END AS avg_checkout_score_7d_final\n  FROM multi_grain_base\n)\n\n-- Select final result with proper column names\nSELECT \n  -- Context-aware dt field: DATETIME truncated to appropriate granularity\n  CASE \n    WHEN period = 'day' THEN DATETIME_TRUNC(dt_hour, DAY)\n    WHEN period = 'hour' THEN DATETIME_TRUNC(dt_hour, HOUR)\n    ELSE dt_hour\n  END AS dt,\n  period,\n  campaign_id,\n  merchant_id,\n  source_type,\n  intent_engine_type,\n  campaign_created_ts,\n  campaign_updated_ts,\n  campaign_ended_ts,\n  campaign_active,\n  campaign_budget,\n  campaign_state,\n  campaign_start_ts,\n  offergroups,\n  consideration_users,\n  considerations,\n  -- consideration_anonymous_ids,\n  show_users,\n  shows,\n  shows_raw,\n  -- show_anonymous_ids,\n  click_users,\n  clicks,\n  clicks_raw,\n  -- click_anonymous_ids,\n  close_users,\n  closes,\n  -- close_anonymous_ids,\n  redeem_users,\n  redeems,\n  redeems_raw,\n  -- redeem_anonymous_ids,\n  error_users,\n  errors,\n  -- error_anonymous_ids,\n  no_shows_cooldown,\n  no_shows_tied_lost,\n  no_shows_not_funded,\n  no_shows_lower_bid,\n  no_shows_lower_campaign_boost,\n  no_shows_lower_offergroup_boost,\n  total_no_shows,\n  total_placements,\n  total_placement_hashes,\n  total_audience_ids,\n  offer_aff_trx,\n  trx_devices,\n  trx_anonymous_ids,\n  gmv_dollars,\n  commission_dollars,\n  millipoints_awarded,\n  dollars_awarded,\n  unique_awards,\n  awarded_devices,\n  awarded_anonymous_ids,\n  award_offer_ids,\n  budget_usedinmillipoints,\n  budget_usedindollars,\n  -- Attribution metrics with proper names (NULL for hourly records)\n  click_transactions_24h_final AS click_transactions_24h,\n  click_devices_24h_final AS click_devices_24h,\n  click_anonymous_ids_24h_final AS click_anonymous_ids_24h,\n  click_gmv_dollars_24h_final AS click_gmv_dollars_24h,\n  click_commission_dollars_24h_final AS click_commission_dollars_24h,\n  click_transactions_7d_final AS click_transactions_7d,\n  click_devices_7d_final AS click_devices_7d,\n  click_anonymous_ids_7d_final AS click_anonymous_ids_7d,\n  click_gmv_dollars_7d_final AS click_gmv_dollars_7d,\n  click_commission_dollars_7d_final AS click_commission_dollars_7d,\n  view_transactions_24h_final AS view_transactions_24h,\n  view_devices_24h_final AS view_devices_24h,\n  view_anonymous_ids_24h_final AS view_anonymous_ids_24h,\n  view_gmv_dollars_24h_final AS view_gmv_dollars_24h,\n  view_commission_dollars_24h_final AS view_commission_dollars_24h,\n  view_transactions_7d_final AS view_transactions_7d,\n  view_devices_7d_final AS view_devices_7d,\n  view_anonymous_ids_7d_final AS view_anonymous_ids_7d,\n  view_gmv_dollars_7d_final AS view_gmv_dollars_7d,\n  view_commission_dollars_7d_final AS view_commission_dollars_7d,\n  -- Checkout attribution metrics (NULL for hourly records)\n  checkout_detections_24h_final AS checkout_detections_24h,\n  checkout_anonymous_ids_24h_final AS checkout_anonymous_ids_24h,\n  avg_checkout_score_24h_final AS avg_checkout_score_24h,\n  checkout_detections_7d_final AS checkout_detections_7d,\n  checkout_anonymous_ids_7d_final AS checkout_anonymous_ids_7d,\n  avg_checkout_score_7d_final AS avg_checkout_score_7d,\n  user_balance_burned_millipoints,\n  user_balance_burned_millipoints_dollars,\n  total_claims,\n  claimed_devices,\n  claimed_anonymous_ids,\n  claimed_offer_ids\nFROM multi_grain_data",
      "dependencies": [
        "offer_expanded_view",
        "campaigns_campaigns",
        "transactions_expanded_view"
      ]
    },
    "offer_campaign_ir_day": {
      "name": "offer_campaign_ir_day",
      "filePath": "intent_engine/offer_campaign_ir_day.sqlx",
      "type": "view",
      "schema": "intent_engine_dev",
      "tags": [
        "intent_engine",
        "analytics",
        "campaigns",
        "day",
        "view"
      ],
      "description": "Daily aggregated metrics for ALL offer campaigns - filtered view from base table",
      "config": {
        "type": "view",
        "schema": "intent_engine_dev",
        "tags": [
          "intent_engine",
          "analytics",
          "campaigns",
          "day",
          "view"
        ],
        "description": "Daily aggregated metrics for ALL offer campaigns - filtered view from base table"
      },
      "sqlContent": "\n\n-- Daily Campaign Analytics for ALL campaigns - Filtered view from base table\nSELECT \n  * EXCEPT(dt),\n  DATE(dt) AS dt  -- Convert DATETIME to DATE for daily views\nFROM `piedotorg-production.intent_engine_dev.offer_campaign_ir_base`\nWHERE period = 'day'  -- Daily data only",
      "dependencies": [
        "offer_campaign_ir_base"
      ]
    },
    "offer_campaign_ir_day_ai_only": {
      "name": "offer_campaign_ir_day_ai_only",
      "filePath": "intent_engine/offer_campaign_ir_day_ai_only.sqlx",
      "type": "view",
      "schema": "intent_engine_dev",
      "tags": [
        "intent_engine",
        "analytics",
        "campaigns",
        "day",
        "ai_only",
        "view"
      ],
      "description": "Daily aggregated metrics for AI-only offer campaigns - filtered view from base table",
      "config": {
        "type": "view",
        "schema": "intent_engine_dev",
        "tags": [
          "intent_engine",
          "analytics",
          "campaigns",
          "day",
          "ai_only",
          "view"
        ],
        "description": "Daily aggregated metrics for AI-only offer campaigns - filtered view from base table"
      },
      "sqlContent": "\n\n-- AI-Only Daily Campaign Analytics - Filtered view from base table\nSELECT \n  * EXCEPT(dt, intent_engine_type),\n  DATE(dt) AS dt  -- Convert DATETIME to DATE for daily views\nFROM `piedotorg-production.intent_engine_dev.offer_campaign_ir_base`\nWHERE period = 'day'  -- Daily data only\n  AND (intent_engine_type IN ('AI', 'MCP') OR source_type = 'ai')  -- AI offers only (defensive filter)",
      "dependencies": [
        "offer_campaign_ir_base"
      ]
    },
    "offer_campaign_ir_hour": {
      "name": "offer_campaign_ir_hour",
      "filePath": "intent_engine/offer_campaign_ir_hour.sqlx",
      "type": "view",
      "schema": "intent_engine_dev",
      "tags": [
        "intent_engine",
        "analytics",
        "campaigns",
        "hour",
        "view"
      ],
      "description": "Hourly aggregated metrics for ALL offer campaigns - filtered view from base table",
      "config": {
        "type": "view",
        "schema": "intent_engine_dev",
        "tags": [
          "intent_engine",
          "analytics",
          "campaigns",
          "hour",
          "view"
        ],
        "description": "Hourly aggregated metrics for ALL offer campaigns - filtered view from base table"
      },
      "sqlContent": "\n\n-- Hourly Campaign Analytics for ALL campaigns - Filtered view from base table\n-- Attribution metrics excluded (always NULL for hourly data)\nSELECT * EXCEPT(\n  period,\n  -- Click attribution fields (NULL for hourly data)\n  click_transactions_24h, click_devices_24h, click_anonymous_ids_24h, \n  click_gmv_dollars_24h, click_commission_dollars_24h,\n  click_transactions_7d, click_devices_7d, click_anonymous_ids_7d,\n  click_gmv_dollars_7d, click_commission_dollars_7d,\n  -- View attribution fields (NULL for hourly data)  \n  view_transactions_24h, view_devices_24h, view_anonymous_ids_24h,\n  view_gmv_dollars_24h, view_commission_dollars_24h,\n  view_transactions_7d, view_devices_7d, view_anonymous_ids_7d,\n  view_gmv_dollars_7d, view_commission_dollars_7d\n)\nFROM `piedotorg-production.intent_engine_dev.offer_campaign_ir_base`\nWHERE period = 'hour'  -- Hourly data only",
      "dependencies": [
        "offer_campaign_ir_base"
      ]
    },
    "offer_campaign_ir_hour_ai_only": {
      "name": "offer_campaign_ir_hour_ai_only",
      "filePath": "intent_engine/offer_campaign_ir_hour_ai_only.sqlx",
      "type": "view",
      "schema": "intent_engine_dev",
      "tags": [
        "intent_engine",
        "analytics",
        "campaigns",
        "hour",
        "ai_only",
        "view"
      ],
      "description": "Hourly aggregated metrics for AI-only offer campaigns - filtered view from base table",
      "config": {
        "type": "view",
        "schema": "intent_engine_dev",
        "tags": [
          "intent_engine",
          "analytics",
          "campaigns",
          "hour",
          "ai_only",
          "view"
        ],
        "description": "Hourly aggregated metrics for AI-only offer campaigns - filtered view from base table"
      },
      "sqlContent": "\n\n-- AI-Only Hourly Campaign Analytics - Filtered view from base table  \n-- Attribution metrics excluded (always NULL for hourly data)\nSELECT * EXCEPT(\n  period, intent_engine_type,\n  -- Click attribution fields (NULL for hourly data)\n  click_transactions_24h, click_devices_24h, click_anonymous_ids_24h,\n  click_gmv_dollars_24h, click_commission_dollars_24h,\n  click_transactions_7d, click_devices_7d, click_anonymous_ids_7d,\n  click_gmv_dollars_7d, click_commission_dollars_7d,\n  -- View attribution fields (NULL for hourly data)\n  view_transactions_24h, view_devices_24h, view_anonymous_ids_24h,\n  view_gmv_dollars_24h, view_commission_dollars_24h,\n  view_transactions_7d, view_devices_7d, view_anonymous_ids_7d,\n  view_gmv_dollars_7d, view_commission_dollars_7d\n)\nFROM `piedotorg-production.intent_engine_dev.offer_campaign_ir_base`\nWHERE period = 'hour'  -- Hourly data only\n  AND (intent_engine_type IN ('AI', 'MCP') OR source_type = 'ai')   -- AI offers only (defensive filter)",
      "dependencies": [
        "offer_campaign_ir_base"
      ]
    },
    "offer_expanded_view": {
      "name": "offer_expanded_view",
      "filePath": "intent_engine/offer_expanded_view.sqlx",
      "type": "table",
      "schema": "intent_engine_dev",
      "tags": [
        "intent_engine",
        "sources",
        "offers"
      ],
      "description": "Unified view of intent engine offers combining extension and AI offer data with placement, cooldown, and enrichment data - captures all ground-level events including duplicates from dual tracking",
      "config": {
        "type": "table",
        "schema": "intent_engine_dev",
        "tags": [
          "intent_engine",
          "sources",
          "offers"
        ],
        "description": "Unified view of intent engine offers combining extension and AI offer data with placement, cooldown, and enrichment data - captures all ground-level events including duplicates from dual tracking",
        "bigquery": {
          "partitionBy": "DATE(ts)",
          "clusterBy": [
            "campaign_id",
            "merchant_id",
            "action"
          ]
        }
      },
      "sqlContent": "\n\n-- Intent Engine Offer Expanded View - Ground-level Event Stream\n-- Debug: Preserves all events including duplicates from dual tracking systems (analytics.js + @segment/analytics-node)\nWITH deduplicated_placements AS (\n  SELECT DISTINCT\n    placementHash,\n    template,\n    placementId,\n    match,\n    hostname,\n    offerGroupId\n  FROM `piedotorg-production.analytics_etl.campaigns_placements`\n),\n\n-- Campaign metadata to enrich offers\ncampaign_data AS (\n  SELECT \n    campaignId,\n    budget,\n    merchantId,\n    TIMESTAMP_MILLIS(created) AS campaign_created_ts,\n    COALESCE(TIMESTAMP_MILLIS(updated), TIMESTAMP_MILLIS(created)) AS campaign_updated_ts,\n    CASE \n      WHEN endDate IS NOT NULL THEN TIMESTAMP_MILLIS(endDate)\n      WHEN state IN ('PAUSED', 'ENDED', 'CANCELLED', 'ARCHIVED') THEN COALESCE(TIMESTAMP_MILLIS(updated), TIMESTAMP_MILLIS(created))\n      ELSE NULL \n    END AS campaign_ended_ts,\n    CASE WHEN state = 'ACTIVE' THEN true ELSE false END AS active,\n    state AS campaign_state,\n    CASE WHEN startDate IS NOT NULL THEN TIMESTAMP_MILLIS(startDate) ELSE TIMESTAMP_MILLIS(created) END AS campaign_start_ts\n  FROM `piedotorg-production.analytics_etl.campaigns_campaigns`\n),\n\n-- Parse transactions_adviews for AI_AD transactions\nai_ad_transactions AS (\n  SELECT\n    userId,\n    adViewId,\n    state AS transaction_state,\n    created AS transaction_created_ms,\n    millipoints,\n    type AS transaction_type,\n    updated AS transaction_updated_ms,\n    JSON_EXTRACT_SCALAR(metadata, '$.offerId') AS offer_id,\n    JSON_EXTRACT_SCALAR(metadata, '$.requestId') AS request_id\n  FROM `piedotorg-production.analytics_etl.transactions_adviews`\n  WHERE type = 'AI_AD'\n    AND metadata IS NOT NULL\n),\n\n-- Unified frontend offer data (ext + AI + web)\nunified_frontend_offers AS (\n  -- Extension table with AI/web fields as NULL\n  SELECT \n    request_id,\n    offer_id,\n    action,\n    surface,\n    is_rewards,\n    user_id,\n    id,\n    timestamp AS timestamp_frontend,\n    NULL AS outbound_url,\n    context_user_agent AS user_agent,\n    ext_tag_id,\n    'ext' AS source_type,\n    -- Extension offer type classification\n    CASE \n      WHEN is_rewards = true THEN 'extension_rewards'\n      WHEN is_rewards = false THEN 'extension_regular'\n      ELSE 'extension_unknown'\n    END AS offer_type,\n    -- Tenant fields (NULL for extension)\n    NULL AS ai_tenant_id,\n    NULL AS ai_tenant_client_id,\n    NULL AS tenant_rewards_enabled,\n    -- Ext-specific fields (keep as-is)\n    anonymous_id,\n    referer_url,\n    platform,\n    context_app_name,\n    context_app_version,\n    context_browser,\n    context_browser_version,\n    context_device_id,\n    context_id,\n    context_ip,\n    context_library_name,\n    context_library_version,\n    context_locale,\n    context_os_os,\n    context_os_version,\n    context_os_name,\n    context_device_type,\n    context_time_zone,\n    event,\n    event_text,\n    loaded_at,\n    original_timestamp,\n    received_at,\n    sent_at,\n    uuid_ts\n  FROM `piedotorg-production.shopping_extension_production.ext_intent_engine_offer`\n  \n  UNION ALL\n  \n  -- AI table with ext/web fields as NULL  \n  SELECT\n    request_id,\n    offer_id, \n    action,\n    surface,\n    is_rewards,\n    user_id,\n    id,\n    TIMESTAMP_MILLIS(timestamp_ms) AS timestamp_frontend,\n    outbound_url,\n    user_agent,\n    tag_id AS ext_tag_id,\n    'ai' AS source_type,\n    -- AI offer type classification\n    CASE \n      WHEN REGEXP_CONTAINS(outbound_url, r'rewardsType=RATE_MAX') THEN 'cashback'\n      WHEN REGEXP_CONTAINS(outbound_url, r'rewardsType=RATE_PERCENT') THEN 'cashback'\n      WHEN REGEXP_CONTAINS(outbound_url, r'rewardsType=&|rewardsType=$') THEN 'regular_offer'\n      WHEN REGEXP_CONTAINS(outbound_url, r'rewardsType=FIXED') THEN 'fixed_reward'\n      ELSE 'other'\n    END AS offer_type,\n    -- Tenant fields from AI offers\n    tenant_id AS ai_tenant_id,\n    tenant_client_id AS ai_tenant_client_id,\n    tenant_rewards_enabled,\n    -- NULL for all ext-specific fields\n    NULL AS anonymous_id,\n    NULL AS referer_url,\n    NULL AS platform,\n    NULL AS context_app_name,\n    NULL AS context_app_version,\n    NULL AS context_browser,\n    NULL AS context_browser_version,\n    NULL AS context_device_id,\n    NULL AS context_id,\n    NULL AS context_ip,\n    NULL AS context_library_name,\n    NULL AS context_library_version,\n    NULL AS context_locale,\n    NULL AS context_os_os,\n    NULL AS context_os_version,\n    NULL AS context_os_name,\n    NULL AS context_device_type,\n    NULL AS context_time_zone,\n    NULL AS event,\n    NULL AS event_text,\n    NULL AS loaded_at,\n    NULL AS original_timestamp,\n    NULL AS received_at,\n    NULL AS sent_at,\n    NULL AS uuid_ts\n  FROM `piedotorg-production.backend_analytics.ai_intent_engine_offer`\n  \n  UNION ALL\n  \n  -- Website table with ext/AI fields as NULL\n  SELECT\n    request_id,\n    offer_id,\n    action,\n    surface,\n    is_rewards,\n    user_id,\n    id,\n    timestamp AS timestamp_frontend,\n    NULL AS outbound_url,  -- Website doesn't have outbound_url like AI\n    context_user_agent AS user_agent,\n    NULL AS ext_tag_id,  -- Website doesn't have tag_id\n    'web' AS source_type,\n    -- Website offer type classification\n    CASE \n      WHEN is_rewards = true THEN 'website_rewards'\n      WHEN is_rewards = false THEN 'website_regular'\n      ELSE 'website_unknown'\n    END AS offer_type,\n    -- Tenant fields (NULL for website)\n    NULL AS ai_tenant_id,\n    NULL AS ai_tenant_client_id,\n    NULL AS tenant_rewards_enabled,\n    -- Use website anonymous_id for counting\n    anonymous_id,\n    NULL AS referer_url,  -- Ignoring context fields per plan\n    NULL AS platform,\n    NULL AS context_app_name,\n    NULL AS context_app_version,\n    NULL AS context_browser,\n    NULL AS context_browser_version,\n    NULL AS context_device_id,\n    NULL AS context_id,\n    NULL AS context_ip,\n    NULL AS context_library_name,\n    NULL AS context_library_version,\n    context_locale,\n    NULL AS context_os_os,\n    NULL AS context_os_version,\n    NULL AS context_os_name,\n    context_device_type,\n    context_timezone AS context_time_zone,\n    event,\n    event_text,\n    loaded_at,\n    original_timestamp,\n    received_at,\n    sent_at,\n    uuid_ts\n  FROM `piedotorg-production.website_production.web_intent_engine_offer`\n)\n\nSELECT\n  TIMESTAMP_MILLIS(be.timestamp_ms) AS ts,\n  COALESCE(be.request_id, fe.request_id) request_id,\n  be.* EXCEPT(request_id, tenant_id, tenant_client_id),\n  fe.* EXCEPT(request_id, offer_id, user_id, ai_tenant_id, ai_tenant_client_id, tenant_rewards_enabled),\n  fe.offer_id as fe_offer_id,\n  fe.offer_id = be.offer_id AS offer_id_match,\n  cooldown_id IS NOT NULL AS cooldown_active,\n  cooldown_id,\n  cooldown_code,\n  cooldown_start,\n  cooldown_end,\n  scope,\n  \n  -- Campaign metadata\n  cd.active AS campaign_active,\n  cd.campaign_state,\n  cd.budget AS campaign_budget,\n  cd.campaign_created_ts,\n  cd.campaign_updated_ts,\n  cd.campaign_ended_ts,\n  cd.campaign_start_ts,\n\n  -- Computed offer_presented field  \n  be.top_offer = true OR (be.intent_engine_type IN ('AI', 'MCP') AND fe.request_id IS NOT NULL) AS offer_presented,\n\n  -- Collect an array of structs, one per placement_hash (deduplicated)\n  ARRAY_AGG(\n    STRUCT(\n      placement_hash,\n      p.template        AS template,\n      p.placementId     AS placementId,\n      p.match           AS match,\n      p.hostname\n    )\n  ) AS placements,\n  \n  -- Transaction fields for AI_AD offers\n  txn.transaction_state,\n  txn.transaction_created_ms,\n  txn.transaction_updated_ms,\n  txn.millipoints,\n  txn.adViewId,\n  txn.userId AS transaction_user_id,\n  \n  -- Composite key for distinct counting\n  CONCAT(COALESCE(be.request_id, fe.request_id), '|', be.offer_id) AS req_offer,\n  \n  -- Tenant fields (combined from backend and AI)\n  COALESCE(be.tenant_id, fe.ai_tenant_id) AS tenant_id,\n  COALESCE(be.tenant_client_id, fe.ai_tenant_client_id) AS tenant_client_id,\n  fe.tenant_rewards_enabled\n\nFROM\n  `piedotorg-production.backend_analytics.intent_engine_offer_group_match` AS be\nLEFT JOIN\n  unified_frontend_offers AS fe\nON be.request_id = fe.request_id \n  AND be.offer_id = fe.offer_id\n  -- Match on tenant_client_id for AI offers\n  AND (fe.source_type != 'ai' OR be.tenant_client_id = fe.ai_tenant_client_id)\n\nLEFT JOIN UNNEST(be.placement_hashes) AS placement_hash\n\nLEFT JOIN\n  deduplicated_placements AS p\nON\n  p.placementHash = placement_hash\n  and p.offerGroupId = be.offergroup_id\n\nLEFT JOIN \n  `piedotorg-production.backend_analytics.intent_engine_cooldown_triggered` c\nON \n  TIMESTAMP_TRUNC(TIMESTAMP_MILLIS(be.timestamp_ms), SECOND) BETWEEN cooldown_start AND cooldown_end \n  AND be.device_id = c.device_id \n  AND p.offerGroupId = be.offergroup_id\n\nLEFT JOIN\n  campaign_data cd\nON\n  be.campaign_id = cd.campaignId\n  AND be.merchant_id = cd.merchantId\n  AND (\n    DATE(TIMESTAMP_MILLIS(be.timestamp_ms)) >= DATE(cd.campaign_start_ts)\n    AND (cd.campaign_ended_ts IS NULL OR DATE(TIMESTAMP_MILLIS(be.timestamp_ms)) <= DATE(cd.campaign_ended_ts))\n  )\n\nLEFT JOIN\n  ai_ad_transactions txn\nON\n  be.offer_id = txn.offer_id\n  AND be.request_id = txn.request_id\n  AND be.intent_engine_type IN ('AI', 'MCP')\n\nGROUP BY\n  ALL ",
      "dependencies": [
        "campaigns_placements",
        "campaigns_campaigns",
        "transactions_adviews",
        "ext_intent_engine_offer",
        "ai_intent_engine_offer",
        "web_intent_engine_offer",
        "intent_engine_offer_group_match",
        "intent_engine_cooldown_triggered"
      ]
    },
    "offer_template_hostname_day": {
      "name": "offer_template_hostname_day",
      "filePath": "intent_engine/offer_template_hostname_day.sqlx",
      "type": "table",
      "schema": "intent_engine_dev",
      "tags": [
        "intent_engine",
        "marts",
        "offers",
        "aggregated"
      ],
      "description": "Daily aggregation of offer interactions by first template and first hostname for active campaigns",
      "config": {
        "type": "table",
        "schema": "intent_engine_dev",
        "tags": [
          "intent_engine",
          "marts",
          "offers",
          "aggregated"
        ],
        "description": "Daily aggregation of offer interactions by first template and first hostname for active campaigns",
        "bigquery": {
          "partitionBy": "dt",
          "clusterBy": [
            "first_template",
            "first_hostname",
            "dt"
          ]
        }
      },
      "sqlContent": "\n\nSELECT\n  DATE(ts) AS dt,\n  \n  -- Extract first template and hostname, handling NULLs explicitly\n  CASE \n    WHEN ARRAY_LENGTH(placements) > 0 THEN placements[OFFSET(0)].template\n    ELSE NULL \n  END AS first_template,\n  \n  CASE \n    WHEN ARRAY_LENGTH(placements) > 0 THEN placements[OFFSET(0)].hostname  \n    ELSE NULL\n  END AS first_hostname,\n  \n  -- Show metrics (prompt/login_prompt surfaces only, top offers)\n  COUNT(CASE WHEN action = 'show' AND surface IN ('prompt', 'login_prompt') AND top_offer = true THEN 1 END) AS shows,\n  COUNT(DISTINCT CASE WHEN action = 'show' AND surface IN ('prompt', 'login_prompt') AND top_offer = true THEN device_id END) AS show_devices,\n  COUNT(DISTINCT CASE WHEN action = 'show' AND surface IN ('prompt', 'login_prompt') AND top_offer = true THEN anonymous_id END) AS show_anonymous_ids,\n  \n  -- Click metrics (prompt/login_prompt surfaces only, top offers)\n  COUNT(CASE WHEN action = 'click' AND surface IN ('prompt', 'login_prompt') AND top_offer = true THEN 1 END) AS clicks,\n  COUNT(DISTINCT CASE WHEN action = 'click' AND surface IN ('prompt', 'login_prompt') AND top_offer = true THEN device_id END) AS click_devices,\n  COUNT(DISTINCT CASE WHEN action = 'click' AND surface IN ('prompt', 'login_prompt') AND top_offer = true THEN anonymous_id END) AS click_anonymous_ids,\n  \n  -- Redeem metrics (prompt/login_prompt surfaces only, top offers)\n  COUNT(CASE WHEN action = 'redeem' AND surface IN ('prompt', 'login_prompt') AND top_offer = true THEN 1 END) AS redeems,\n  COUNT(DISTINCT CASE WHEN action = 'redeem' AND surface IN ('prompt', 'login_prompt') AND top_offer = true THEN device_id END) AS redeem_devices,\n  COUNT(DISTINCT CASE WHEN action = 'redeem' AND surface IN ('prompt', 'login_prompt') AND top_offer = true THEN anonymous_id END) AS redeem_anonymous_ids,\n  \n  -- Error metrics (error_prompt surface, top offers)\n  COUNT(CASE WHEN action = 'show' AND surface = 'error_prompt' AND top_offer = true THEN 1 END) AS errors,\n  COUNT(DISTINCT CASE WHEN action = 'show' AND surface = 'error_prompt' AND top_offer = true THEN device_id END) AS error_devices,\n  COUNT(DISTINCT CASE WHEN action = 'show' AND surface = 'error_prompt' AND top_offer = true THEN anonymous_id END) AS error_anonymous_ids,\n  \n  COUNT(*) AS total_events,\n  \n  -- Calculate rates (handle division by zero)\n  SAFE_DIVIDE(COUNT(CASE WHEN action = 'click' AND surface IN ('prompt', 'login_prompt') AND top_offer = true THEN 1 END), \n              COUNT(CASE WHEN action = 'show' AND surface IN ('prompt', 'login_prompt') AND top_offer = true THEN 1 END)) AS click_through_rate,\n  SAFE_DIVIDE(COUNT(CASE WHEN action = 'redeem' AND surface IN ('prompt', 'login_prompt') AND top_offer = true THEN 1 END), \n              COUNT(CASE WHEN action = 'show' AND surface IN ('prompt', 'login_prompt') AND top_offer = true THEN 1 END)) AS redeem_rate\n\nFROM `piedotorg-production.intent_engine_dev.offer_expanded_view`\n\nWHERE \n  -- Filter to active campaigns only\n  campaign_active = true\n  AND campaign_state = 'ACTIVE'\n  \nGROUP BY\n  dt,\n  first_template,\n  first_hostname",
      "dependencies": [
        "offer_expanded_view"
      ]
    },
    "offer_unified_view": {
      "name": "offer_unified_view",
      "filePath": "intent_engine/offer_unified_view.sqlx",
      "type": "table",
      "schema": "intent_engine_dev",
      "tags": [
        "intent_engine",
        "unified_view",
        "offers",
        "funnel"
      ],
      "description": "Unified table of the complete offer funnel from backend consideration through frontend actions to conversion. Each row represents one action in the funnel.",
      "config": {
        "type": "table",
        "schema": "intent_engine_dev",
        "tags": [
          "intent_engine",
          "unified_view",
          "offers",
          "funnel"
        ],
        "description": "Unified table of the complete offer funnel from backend consideration through frontend actions to conversion. Each row represents one action in the funnel.",
        "bigquery": {
          "partitionBy": "DATE(event_ts)",
          "clusterBy": [
            "action",
            "merchant_id",
            "campaign_id"
          ]
        }
      },
      "sqlContent": "\n\n-- Unified offer funnel view combining all stages\nWITH \n-- 1. Backend Consideration Stage\nbackend_consideration AS (\n  SELECT\n    'backend_match' AS source_table,\n    action,\n    CAST(NULL AS STRING) AS attribution_model,\n    \n    -- Timestamps\n    backend_ts AS event_ts,\n    backend_ts,\n    \n    -- Core Identifiers\n    request_id,\n    offer_id,\n    req_offer,\n    \n    -- Campaign & Merchant\n    campaign_id,\n    merchant_id,\n    campaign_boost,\n    campaign_active,\n    campaign_state,\n    campaign_budget,\n    \n    -- User Identifiers\n    user_id,\n    CAST(NULL AS STRING) AS anonymous_id,\n    device_id,\n    \n    -- Offer Details\n    offer_content,\n    offer_click_url,\n    offer_cta,\n    offer_award,\n    offer_distribution,\n    top_offer,\n    \n    -- Offer Group Details\n    offergroup_id,\n    offergroup_min_bid,\n    offergroup_max_bid,\n    offergroup_bid_type,\n    \n    -- Tenant Details\n    tenant_id,\n    tenant_client_id,\n    \n    -- Platform & Source\n    intent_engine_type,\n    CAST(NULL AS STRING) AS source_type,\n    client,\n    \n    -- Frontend Specific (NULL for backend except placement info)\n    CAST(NULL AS INT64) AS tag_id,\n    CAST(NULL AS INT64) AS ext_tag_id,\n    CAST(NULL AS STRING) AS surface,\n    CAST(NULL AS STRING) AS outbound_url,\n    first_placement_template,\n    first_placement_id,\n    first_placement_match,\n    first_placement_hostname,\n    placement_count,\n    \n    -- Search context\n    keywords,\n    \n    -- Conversion Specific (NULL for backend)\n    CAST(NULL AS STRING) AS transaction_id,\n    CAST(NULL AS DATETIME) AS transaction_ts,\n    CAST(NULL AS STRING) AS transaction_type,\n    CAST(NULL AS FLOAT64) AS external_sale_value_dollars,\n    CAST(NULL AS FLOAT64) AS external_commission_dollars,\n    CAST(NULL AS INT64) AS millipoints,\n    CAST(NULL AS STRING) AS attribution_confidence,\n    CAST(NULL AS INT64) AS attribution_window_hours,\n    CAST(NULL AS INT64) AS time_to_conversion_hours\n    \n  FROM `piedotorg-production.fact_tables_dev.fact_intent_engine_offer_group_match`\n),\n\n-- 2. Frontend Actions Stage (impressions, clicks, dismissals)\nfrontend_actions AS (\n  SELECT\n    'frontend_offer' AS source_table,\n    -- Use surface-specific action names for error and login prompts\n    CASE \n      WHEN surface = 'error_prompt' THEN 'error_prompt'\n      WHEN surface = 'login_prompt' THEN 'login_prompt'\n      ELSE action\n    END AS action,\n    CAST(NULL AS STRING) AS attribution_model,\n    \n    -- Timestamps\n    event_ts,\n    backend_ts,\n    \n    -- Core Identifiers\n    request_id,\n    offer_id,\n    req_offer,\n    \n    -- Campaign & Merchant\n    campaign_id,\n    merchant_id,\n    campaign_boost,\n    campaign_active,\n    campaign_state,\n    campaign_budget,\n    \n    -- User Identifiers\n    user_id,\n    anonymous_id,\n    device_id,\n    \n    -- Offer Details\n    offer_content,\n    CAST(NULL AS STRING) AS offer_click_url,\n    offer_cta,\n    offer_award,\n    CAST(NULL AS INT64) AS offer_distribution,\n    top_offer,\n    \n    -- Offer Group Details\n    offergroup_id,\n    offergroup_min_bid,\n    offergroup_max_bid,\n    offergroup_bid_type,\n    \n    -- Tenant Details\n    tenant_id,\n    tenant_client_id,\n    \n    -- Platform & Source\n    intent_engine_type,\n    source_type,\n    CAST(NULL AS STRING) AS client,\n    \n    -- Frontend Specific\n    tag_id,\n    ext_tag_id,\n    surface,\n    outbound_url,\n    first_placement_template,\n    first_placement_id,\n    first_placement_match,\n    first_placement_hostname,\n    placement_count,\n    \n    -- Search context\n    keywords,  -- Keywords from mapping via int_fe_offer\n    \n    -- Conversion Specific (NULL for frontend)\n    CAST(NULL AS STRING) AS transaction_id,\n    CAST(NULL AS DATETIME) AS transaction_ts,\n    CAST(NULL AS STRING) AS transaction_type,\n    CAST(NULL AS FLOAT64) AS external_sale_value_dollars,\n    CAST(NULL AS FLOAT64) AS external_commission_dollars,\n    CAST(NULL AS INT64) AS millipoints,\n    CAST(NULL AS STRING) AS attribution_confidence,\n    CAST(NULL AS INT64) AS attribution_window_hours,\n    CAST(NULL AS INT64) AS time_to_conversion_hours\n    \n  FROM `piedotorg-production.fact_tables_dev.int_fe_offer`\n),\n\n-- 3. Conversion Stage (attributed transactions)\nconversions AS (\n  SELECT\n    'attribution_model' AS source_table,\n    'conversion' AS action,\n    attribution_model,\n    \n    -- Timestamps\n    CAST(transaction_ts AS TIMESTAMP) AS event_ts,\n    CAST(attribution_event_ts AS TIMESTAMP) AS backend_ts,\n    \n    -- Core Identifiers\n    request_id,\n    offer_id,\n    req_offer,\n    \n    -- Campaign & Merchant\n    campaign_id,\n    merchant_id,\n    CAST(NULL AS INT64) AS campaign_boost,\n    CAST(NULL AS BOOLEAN) AS campaign_active,\n    CAST(NULL AS STRING) AS campaign_state,\n    CAST(NULL AS INT64) AS campaign_budget,\n    \n    -- User Identifiers\n    user_id,\n    anonymous_id,\n    device_id,\n    \n    -- Offer Details\n    offer_content,\n    CAST(NULL AS STRING) AS offer_click_url,\n    CAST(NULL AS STRING) AS offer_cta,\n    offer_award,\n    CAST(NULL AS INT64) AS offer_distribution,\n    CAST(NULL AS BOOLEAN) AS top_offer,\n    \n    -- Offer Group Details (NULL for conversions)\n    CAST(NULL AS STRING) AS offergroup_id,\n    CAST(NULL AS INT64) AS offergroup_min_bid,\n    CAST(NULL AS INT64) AS offergroup_max_bid,\n    CAST(NULL AS STRING) AS offergroup_bid_type,\n    \n    -- Tenant Details\n    tenant_id,\n    CAST(NULL AS STRING) AS tenant_client_id,\n    \n    -- Platform & Source\n    intent_engine_type,\n    source_type,\n    CAST(NULL AS STRING) AS client,\n    \n    -- Frontend Specific (conversions have placement from click/view events)\n    CAST(NULL AS INT64) AS tag_id,\n    ext_tag_id,\n    CAST(NULL AS STRING) AS surface,\n    CAST(NULL AS STRING) AS outbound_url,\n    first_placement_template,\n    first_placement_id,\n    first_placement_match,\n    first_placement_hostname,\n    placement_count,\n    \n    -- Search context\n    CAST(NULL AS STRING) AS keywords,  -- Conversions don't have keywords directly\n    \n    -- Conversion Specific\n    transaction_id,\n    transaction_ts,\n    transaction_type,\n    external_sale_value_dollars,\n    external_commission_dollars,\n    millipoints,\n    attribution_confidence,\n    attribution_window_hours,\n    time_to_conversion_hours\n    \n  FROM `piedotorg-production.fact_tables_dev.fact_offer_attribution_models`\n)\n\n-- Union all stages\nSELECT * FROM backend_consideration\nUNION ALL\nSELECT * FROM frontend_actions\nUNION ALL\nSELECT * FROM conversions",
      "dependencies": [
        "fact_intent_engine_offer_group_match",
        "int_fe_offer",
        "fact_offer_attribution_models"
      ]
    },
    "transactions_expanded_view": {
      "name": "transactions_expanded_view",
      "filePath": "sources/transactions_expanded_view.sqlx",
      "type": "table",
      "schema": "data_science_dev",
      "tags": [
        "transactions",
        "sources",
        "commerce"
      ],
      "description": "Table of affiliate transactions with enhanced data joins and enrichments - converting to table",
      "config": {
        "type": "table",
        "schema": "data_science_dev",
        "tags": [
          "transactions",
          "sources",
          "commerce"
        ],
        "description": "Table of affiliate transactions with enhanced data joins and enrichments - converting to table",
        "bigquery": {
          "partitionBy": "DATE(created_coalesce_ts)",
          "clusterBy": [
            "merchantId",
            "campaignId",
            "type"
          ]
        }
      },
      "sqlContent": "\n\n-- Affiliate transactions expanded view\n-- Debug: Migrated from BigQuery data_science.transactions_expanded_view\nWITH\n  base_v2_fe_data as (\n    select \n    distinct \n    anonymous_id,\n    device_id,\n    user_id userId,\n    ext_tag_id,\n    offer_Id, -- this is offer_id linked to campaigns offergroups etc.\n    request_id requestId,\n    campaign_id,\n    top_offer,\n    \"v2\" as offers_version,\n  --  null as keyword_matched\n    from `piedotorg-production.intent_engine_dev.offer_expanded_view`\n   -- where top_offer  -- since we're only interested in top offers that are surfaced\n  ),\n\n  base_tag_cte AS (\n  SELECT\n    ext_tag_id,\n    requestid as tagged_request_Id,\n    offer_id as tagged_offer_id, -- tagged offer_id\n    campaign_id as tagged_campaign_id, --tagged campaign_id\n    timestamp AS tag_timestamp,\n    context_app_name,\n    context_app_version,\n    url,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt\n  FROM\n    `piedotorg-production.extension_production_views.ext_affiliate_tag` left join base_v2_fe_data as v2_fe_data\n    using (ext_tag_id)\n    where top_offer or top_offer is null \n  GROUP BY\n    ALL ),\n\n  base_v1_fe_data as (\n    SELECT\n      DISTINCT anonymous_id,\n--    device_id,\n    user_id userId,\n    offer_Id AS adofferId, -- Q: is this how V1 rewards are linked to transactions_adoffers?\n    \"v1\" as offers_version,\n    CASE WHEN metadata_keyword_matched IS NOT NULL THEN TRUE ELSE FALSE END AS keyword_matched\n  FROM\n    `piedotorg-production.extension_production_views.ext_rewards_transaction`\n  WHERE\n    action IN (\"click\", \"login\") \n  ),\n\n    \n  base_redirect_cte AS (\n  SELECT\n    anonymousid anonymous_id,\n    \"standard\" AS redirect_type,\n    subsrc,\n    extTagId ext_tag_id,\n    CAST(tagId AS INT64) AS tag_id,  -- AI offers use tagId\n    trackId,\n    affiliateLinkId,\n    sessionid,\n    CAST(NULL AS string) AS productid,\n    feature,\n    merchantId,\n    IFNULL(timestamp, TIMESTAMP_MILLIS(sessionid)) AS redirect_timestamp,\n    ROW_NUMBER() OVER (PARTITION BY trackId ORDER BY timestamp DESC) AS redirect_row_num\n  FROM\n    `piedotorg-production.backend_analytics.outbound_redirect`\n  QUALIFY\n    redirect_row_num = 1 ),\n    \n  base_product_redirect_cte AS (\n  SELECT\n    anonymousid anonymous_id,\n    \"product\" AS redirect_type,\n    subsrc,\n    CAST(extTagId AS INT64) ext_tag_id,\n    CAST(tagId AS INT64) AS tag_id,  -- AI offers use tagId\n    trackId,\n    affiliateLinkId,\n    CAST(sessionid AS int64) sessionId,\n    productid,\n    feature,\n    merchantId,\n    IFNULL(timestamp, TIMESTAMP_MILLIS(sessionid)) AS redirect_timestamp,\n    ROW_NUMBER() OVER (PARTITION BY trackId ORDER BY timestamp DESC) AS redirect_row_num\n  FROM\n    `piedotorg-production.backend_analytics.product_outbound_redirect`\n  QUALIFY\n    redirect_row_num = 1 ),\n    \n  all_redirect_cte AS (\n  SELECT\n    *\n  FROM\n    base_redirect_cte\n  UNION ALL\n  SELECT\n    *\n  FROM\n    base_product_redirect_cte),\n    \n  base_aff_cte AS (\n  SELECT\n    transactionId,\n    trackId,\n    TIMESTAMP_MILLIS(externalCreated) AS aff_trx_created_ts,\n    externalStatus,\n    externalCommission,\n    externalSaleValue,\n    provider\n  FROM\n    `piedotorg-production.analytics_etl.transactions_affiliatetransactions` ),\n    \n  base_trx_cte AS (\n  SELECT\n    type,\n    userId,\n    state,\n    millipoints,\n    TIMESTAMP_MILLIS(confirmed) AS confirmed_ts,\n    TIMESTAMP_MILLIS(created) AS trx_trx_created_ts,\n    merchantId,\n    transactionId\n  FROM\n    `piedotorg-production.analytics_etl.transactions_transactions`),\n    \n  offer_campaign_data AS (\n  SELECT\n    campaignId,\n    budget,\n    merchantId,\n    MIN(TIMESTAMP_MILLIS(created)) AS campaign_created_ts,\n    MAX(TIMESTAMP_MILLIS(updated)) AS campaign_updated_ts,\n    MAX(CASE\n        WHEN active = FALSE THEN TIMESTAMP_MILLIS(updated)\n    END\n      ) AS campaign_ended_ts,\n    MAX(active) AS active\n  FROM\n    `piedotorg-production.analytics_etl.transactions_campaigns`\n  GROUP BY\n    ALL ),\n    \n  base_offers_cte AS (\n  SELECT\n    DISTINCT \n    -- Fields from transactions_adoffers table\n    adOfferType, -- this will be campaign_v2 for v2 Q: what is it for v1?\n    adOfferId, --individual transaction adofferId\n    millipoints, --this is millipoints burned from user balance\n    requestId,\n    offerId,\n    offerGroupId,\n    COALESCE(v1_fe_data.keyword_matched, FALSE) AS keyword_matched,\n    transactionId,\n    state AS adofferstate,\n    COALESCE(campaignId,campaignIdV2) AS campaignId,\n   -- budgetUsedInMillipoints, -- deprecated, \n    TIMESTAMP_MILLIS(created) AS ad_offers_created_ts,\n    TIMESTAMP_MILLIS(claimed) AS offer_claimed_ts,\n    -- Fields from offer_campaign_data table\n    campaign_created_ts,\n    campaign_ended_ts,\n    active,\n    COALESCE(v1_fe_data.anonymous_id, v2_fe_data.anonymous_id) AS anonymous_id, -- we pull this from ext_rewards_transaction for v1 rewards transactions\n    v2_fe_data.device_id AS device_id,\n    userId\n  FROM\n    `piedotorg-production.analytics_etl.transactions_adoffers` ta\n  LEFT JOIN\n    offer_campaign_data\n  USING\n    (campaignId)\n  LEFT JOIN\n    base_v1_fe_data as v1_fe_data\n  USING\n    (adofferId, userId) \n         LEFT JOIN base_v2_fe_data as v2_fe_data\n     USING (requestId, userId)\n  ),\n  aff_trx_join AS (\n  SELECT\n    * EXCEPT(merchantId),\n    COALESCE(all_redirect_cte.merchantid, base_trx_cte.merchantid) AS merchantId\n  FROM\n    base_aff_cte\n  LEFT JOIN\n    all_redirect_cte\n  USING\n    (trackId)\n  FULL OUTER JOIN\n    base_trx_cte\n  USING\n    (transactionId)\n  LEFT JOIN\n    base_tag_cte\n  USING\n    (ext_tag_id) ),\n    \n  user_id_anon_map AS (\n  SELECT\n    DISTINCT most_common_anonymous_id most_common_anonymous_id,\n    user_id userid\n  FROM\n    `piedotorg-production.users.user_anon_mapping`),\n    \n  aff_offers_join AS (\n  SELECT\n    * EXCEPT(anonymous_id, millipoints),\n    COALESCE(aff_trx_join.millipoints) millipoints,\n    coalesce(base_offers_cte.millipoints) as balance_burned_millipoints, -- Note we'll need to track user balance burns a bit better especially for AD_VIEW transactions\n    COALESCE(aff_trx_join.anonymous_id, base_offers_cte.anonymous_id, user_id_anon_map.most_common_anonymous_id) AS anonymous_id,\n    COALESCE(aff_trx_created_ts, offer_claimed_ts, trx_trx_created_ts, redirect_timestamp) AS created_coalesce_ts\n  FROM\n    aff_trx_join\n  FULL OUTER JOIN\n    base_offers_cte\n  USING\n    (transactionId, userId) \n  LEFT JOIN \n    user_id_anon_map \n  USING \n    (userId) )\n\n-- Debug: Final SELECT with alias fields for backward compatibility\nSELECT\n  * EXCEPT(ext_tag_id, tag_id),\n  -- Coalesce ext_tag_id and tag_id for backward compatibility\n  COALESCE(ext_tag_id, tag_id) AS ext_tag_id,\n  tag_id,  -- Keep tag_id separate for AI-specific analysis\n  created_coalesce_ts AS timestamp,\n  userId user_id,\n  merchantId merchant_id\nFROM\n  aff_offers_join ",
      "dependencies": [
        "offer_expanded_view",
        "ext_affiliate_tag",
        "ext_rewards_transaction",
        "outbound_redirect",
        "product_outbound_redirect",
        "transactions_affiliatetransactions",
        "transactions_transactions",
        "transactions_campaigns",
        "transactions_adoffers",
        "user_anon_mapping"
      ]
    },
    "unified_user_feedback": {
      "name": "unified_user_feedback",
      "filePath": "unified_user_feedback.sqlx",
      "type": "table",
      "schema": "data_science_dev",
      "tags": [
        "feedback",
        "analytics",
        "users"
      ],
      "description": "Unified view of user feedback from uninstall surveys, bug reports, extension feedback, and low-rated reviews",
      "config": {
        "type": "table",
        "schema": "data_science_dev",
        "tags": [
          "feedback",
          "analytics",
          "users"
        ],
        "description": "Unified view of user feedback from uninstall surveys, bug reports, extension feedback, and low-rated reviews",
        "bigquery": {
          "partitionBy": "DATE(timestamp)",
          "clusterBy": [
            "anonymous_id",
            "feedback_source"
          ]
        }
      },
      "sqlContent": "\n\nWITH processed_uninstall AS (\n  SELECT\n    id as feedback_id,\n    CASE \n      WHEN extension_type = 'adblock' THEN extension_adblock_anonymous_id\n      WHEN extension_type = 'shopping' THEN extension_shopping_anonymous_id\n      WHEN extension_type = 'unified' THEN extension_unified_anonymous_id\n      ELSE anonymous_id  -- fallback\n    END as anonymous_id,\n    CONCAT('extension-', extension_type) as context_app_name,\n    'uninstall' as feedback_source,\n    timestamp,\n    additional_info as feedback_text,\n    cast(selected_options as STRING) as feedback_category,\n    version as context_app_version,\n    platform,\n    context_page_referrer as referrer_url,\n    CAST(version AS STRING) as app_version,\n    context_user_agent as user_agent,\n    `piedotorg-production.data_science.parse_useragent`(context_user_agent).browser.name as context_browser\n  FROM `piedotorg-production.website_production.web_uninstall`\n  WHERE action = \"submit\"\n),\n\nprocessed_bug_reports AS (\n  SELECT\n    id as feedback_id,\n    -- CASE \n    --   WHEN extension_type = 'adblock' THEN extension_adblock_anonymous_id\n    --   WHEN extension_type = 'shopping' THEN extension_shopping_anonymous_id\n    --   WHEN extension_type = 'unified' THEN extension_unified_anonymous_id\n    --   ELSE anonymous_id  -- fallback\n    -- END \n    --until we have the proper way\n    cast(coalesce(extension_adblock_anonymous_id,extension_shopping_anonymous_id,extension_unified_anonymous_id) as string) as anonymous_id,\n   -- CONCAT('extension-', extension_type)\n    cast(null as string) as context_app_name,\n    'bug_report' as feedback_source,\n    timestamp,\n    additional_info as feedback_text,\n    selected_option as feedback_category,\n    'null' as context_app_version,\n    context_user_agent_data_platform as platform,\n    context_page_referrer as referrer_url,\n    CAST(NULL AS STRING) as app_version,\n    context_user_agent as user_agent,\n    `piedotorg-production.data_science.parse_useragent`(context_user_agent).browser.name as context_browser\n  FROM `piedotorg-production.website_production.web_report_bug`\n  WHERE action = \"submit\"\n),\n\nprocessed_extension_feedback AS (\n  SELECT\n    id as feedback_id,\n    anonymous_id,\n    context_app_name,  -- already in the correct format\n    concat('ext_feedback|', ifnull(surface,\"\"))  as feedback_source,\n    timestamp,\n    text as feedback_text,\n    type as feedback_category,\n    context_app_version,\n    platform,\n    referer_url as referrer_url,\n    CAST(context_app_version AS STRING) as app_version,\n    context_user_agent as user_agent,\n    `piedotorg-production.data_science.parse_useragent`(context_user_agent).browser.name as context_browser\n  FROM `piedotorg-production.extension_production_views.ext_feedback`\n),\n\nprocessed_reviews AS (\n  SELECT\n    id as feedback_id,\n    '' as anonymous_id,  -- Reviews don't have anonymous_id\n    CONCAT('extension-', extension_type) as context_app_name,\n    'low_rated_review' as feedback_source,\n    timestamp,\n    text as feedback_text,\n    CAST(rating AS STRING) as feedback_category,\n    'null' as context_app_version,\n    platform,\n    cast(NULL as string) as referrer_url,\n    cast(NULL as string)  as app_version,\n    cast(NULL as string) user_agent,\n    cast(NULL as string) as context_browser  -- Reviews don't have user agent\n  FROM `piedotorg-production.extensions_data.reviews`\n  WHERE rating <= 3\n)\n\nSELECT * FROM processed_uninstall\nUNION ALL\nSELECT * FROM processed_bug_reports\nUNION ALL\nSELECT * FROM processed_extension_feedback \nUNION ALL\nSELECT * FROM processed_reviews ",
      "dependencies": [
        "web_uninstall",
        "web_report_bug",
        "ext_feedback",
        "reviews"
      ]
    },
    "f_user_commerce": {
      "name": "f_user_commerce",
      "filePath": "user_features/f_user_commerce.sqlx",
      "type": "incremental",
      "schema": "user_features_dev",
      "tags": [
        "users",
        "features",
        "commerce"
      ],
      "description": "Daily aggregated commerce activity including affiliate tags, order confirmations, and redirects",
      "config": {
        "type": "incremental",
        "schema": "user_features_dev",
        "tags": [
          "users",
          "features",
          "commerce"
        ],
        "description": "Daily aggregated commerce activity including affiliate tags, order confirmations, and redirects",
        "uniqueKey": [
          "dt",
          "anonymous_id"
        ],
        "bigquery": {
          "partitionBy": "dt",
          "updatePartitionFilter": "dt >= date_sub(current_date(), interval 3 day)"
        }
      },
      "sqlContent": "\n\n-- Feature table: Daily commerce aggregations per user\n-- Debug: Processing affiliate tags, confirmations, and redirects\nWITH affiliate_tags_base AS (\n  SELECT\n    anonymous_id,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt,\n    COUNT(*) AS total_affiliate_tags,\n    COUNT(DISTINCT session_id) AS total_tag_sessions\n  FROM `piedotorg-production.extension_production_views.ext_affiliate_tag`\n  \n  \n  \n  GROUP BY anonymous_id, dt\n),\n\norder_confirmations_base AS (\n  SELECT\n    anonymous_id,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt,\n    COUNT(*) AS total_order_confirmations,\n    COUNT(DISTINCT session_id) AS order_confirmation_sessions,\n    COUNTIF(tagged IS TRUE) AS tagged_order_confirmations\n  FROM `piedotorg-production.extension_production_views.ext_order_confirmation`\n  \n  \n  \n  GROUP BY anonymous_id, dt\n),\n\nredirects_base AS (\n  SELECT\n    anonymousid AS anonymous_id,\n    DATE(IFNULL(timestamp, TIMESTAMP_MILLIS(sessionid)), \"America/Los_Angeles\") AS dt,\n    \n    -- Overall redirect metrics\n    COUNT(*) AS total_redirects,\n    COUNT(DISTINCT sessionid) AS total_redirect_sessions,\n    \n    -- Redirect source breakdown\n    COUNTIF(subsrc = \"rewards_transaction_popup\") AS rewards_transaction_popup_redirects,\n    COUNTIF(subsrc = \"coupon_popup\") AS coupon_popup_shopping_redirects,\n    COUNTIF(subsrc = \"cashback_popup_adblock\") AS cashback_popup_adblock_redirects,\n    COUNTIF(subsrc = \"rewards_popup\") AS rewards_popup_shopping_redirects,\n    COUNTIF(subsrc = \"popover_coupon_list\") AS popover_coupon_list_redirects,\n    COUNTIF(subsrc = \"pie_offer_login_retargeting\") AS login_retargeting_redirects,\n    COUNTIF(subsrc = \"standdown\") AS standdown_redirects\n    \n  FROM `piedotorg-production.backend_analytics.outbound_redirect`\n  \n  \n  \n  GROUP BY anonymous_id, dt\n)\n\n-- Debug: Combining all commerce features\nSELECT\n  COALESCE(\n    affiliate_tags_base.anonymous_id, \n    order_confirmations_base.anonymous_id, \n    redirects_base.anonymous_id\n  ) AS anonymous_id,\n  COALESCE(\n    affiliate_tags_base.dt, \n    order_confirmations_base.dt, \n    redirects_base.dt\n  ) AS dt,\n  \n  -- Affiliate tag metrics\n  COALESCE(total_affiliate_tags, 0) AS total_affiliate_tags,\n  COALESCE(total_tag_sessions, 0) AS total_tag_sessions,\n  \n  -- Order confirmation metrics\n  COALESCE(total_order_confirmations, 0) AS total_order_confirmations,\n  COALESCE(order_confirmation_sessions, 0) AS order_confirmation_sessions,\n  COALESCE(tagged_order_confirmations, 0) AS tagged_order_confirmations,\n  \n  -- Redirect metrics\n  COALESCE(total_redirects, 0) AS total_redirects,\n  COALESCE(total_redirect_sessions, 0) AS total_redirect_sessions,\n  COALESCE(rewards_transaction_popup_redirects, 0) AS rewards_transaction_popup_redirects,\n  COALESCE(coupon_popup_shopping_redirects, 0) AS coupon_popup_shopping_redirects,\n  COALESCE(cashback_popup_adblock_redirects, 0) AS cashback_popup_adblock_redirects,\n  COALESCE(rewards_popup_shopping_redirects, 0) AS rewards_popup_shopping_redirects,\n  COALESCE(popover_coupon_list_redirects, 0) AS popover_coupon_list_redirects,\n  COALESCE(login_retargeting_redirects, 0) AS login_retargeting_redirects,\n  COALESCE(standdown_redirects, 0) AS standdown_redirects\n\nFROM affiliate_tags_base\nFULL OUTER JOIN order_confirmations_base\n  USING (anonymous_id, dt)\nFULL OUTER JOIN redirects_base\n  USING (anonymous_id, dt) ",
      "dependencies": [
        "ext_affiliate_tag",
        "ext_order_confirmation",
        "outbound_redirect"
      ],
      "uniqueKey": [
        "dt",
        "anonymous_id"
      ]
    },
    "f_user_events": {
      "name": "f_user_events",
      "filePath": "user_features/f_user_events.sqlx",
      "type": "incremental",
      "schema": "user_features_dev",
      "tags": [
        "users",
        "features",
        "events"
      ],
      "description": "Daily aggregated user events including standdowns, ad metrics, and settings",
      "config": {
        "type": "incremental",
        "schema": "user_features_dev",
        "tags": [
          "users",
          "features",
          "events"
        ],
        "description": "Daily aggregated user events including standdowns, ad metrics, and settings",
        "uniqueKey": [
          "dt",
          "anonymous_id"
        ],
        "bigquery": {
          "partitionBy": "dt",
          "updatePartitionFilter": "dt >= date_sub(current_date(), interval 3 day)"
        }
      },
      "sqlContent": "\n\n-- Feature table: Daily event aggregations per user\n-- Debug: Processing standdowns, ad metrics, and user settings\nWITH standdowns_base AS (\n  SELECT\n    anonymous_id,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt,\n    COUNT(*) AS total_standdowns,\n    COUNTIF(standdown_type = \"stop\") AS stop_standdowns,\n    COUNTIF(standdown_type = \"notag\") AS notag_standdowns,\n    COUNTIF(standdown_type = \"suppress\") AS suppress_standdowns\n  FROM `piedotorg-production.extension_production_views.ext_standdown_detected`\n  \n  \n  \n  GROUP BY anonymous_id, dt\n),\n\nad_metrics_base AS (\n  SELECT\n    anonymous_id,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt,\n    COUNT(*) AS total_pages_w_ads_seen,\n    SUM(ad_placements_seen) AS total_ad_placements_seen,\n    SUM(pixels_used_by_ads_total) AS total_pixels_seen\n  FROM `piedotorg-production.extension_production_views.ext_device_ad_metrics_rollup`\n  \n  \n  \n  GROUP BY anonymous_id, dt\n),\n\nuser_settings_base AS (\n  -- Debug: Getting latest user settings per day (last value wins)\n  SELECT\n    anonymous_id,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt,\n    LAST_VALUE(other_adblockers) OVER (\n      PARTITION BY anonymous_id, DATE(timestamp, \"America/Los_Angeles\") \n      ORDER BY timestamp ASC \n      ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING\n    ) AS other_adblockers\n  FROM `piedotorg-production.extension_production_views.ext_user_settings`\n  WHERE other_adblockers IS NOT NULL -- only rows with actual values\n  \n  \n  \n  QUALIFY ROW_NUMBER() OVER (\n    PARTITION BY anonymous_id, DATE(timestamp, \"America/Los_Angeles\") \n    ORDER BY timestamp DESC\n  ) = 1\n)\n\n-- Debug: Combining all event features\nSELECT\n  COALESCE(\n    standdowns_base.anonymous_id, \n    ad_metrics_base.anonymous_id, \n    user_settings_base.anonymous_id\n  ) AS anonymous_id,\n  COALESCE(\n    standdowns_base.dt, \n    ad_metrics_base.dt, \n    user_settings_base.dt\n  ) AS dt,\n  \n  -- Standdown metrics\n  COALESCE(total_standdowns, 0) AS total_standdowns,\n  COALESCE(stop_standdowns, 0) AS stop_standdowns,\n  COALESCE(notag_standdowns, 0) AS notag_standdowns,\n  COALESCE(suppress_standdowns, 0) AS suppress_standdowns,\n  \n  -- Ad metrics\n  COALESCE(total_pages_w_ads_seen, 0) AS total_pages_w_ads_seen,\n  COALESCE(total_ad_placements_seen, 0) AS total_ad_placements_seen,\n  COALESCE(total_pixels_seen, 0) AS total_pixels_seen,\n  \n  -- User settings\n  user_settings_base.other_adblockers\n\nFROM standdowns_base\nFULL OUTER JOIN ad_metrics_base\n  USING (anonymous_id, dt)\nFULL OUTER JOIN user_settings_base\n  USING (anonymous_id, dt) ",
      "dependencies": [
        "ext_standdown_detected",
        "ext_device_ad_metrics_rollup",
        "ext_user_settings"
      ],
      "uniqueKey": [
        "dt",
        "anonymous_id"
      ]
    },
    "f_user_heartbeats": {
      "name": "f_user_heartbeats",
      "filePath": "user_features/f_user_heartbeats.sqlx",
      "type": "incremental",
      "schema": "user_features_dev",
      "tags": [
        "users",
        "features",
        "events"
      ],
      "description": "Daily aggregated heartbeat data per user including device tracking and app versions",
      "config": {
        "type": "incremental",
        "schema": "user_features_dev",
        "tags": [
          "users",
          "features",
          "events"
        ],
        "description": "Daily aggregated heartbeat data per user including device tracking and app versions",
        "uniqueKey": [
          "dt",
          "anonymous_id"
        ],
        "bigquery": {
          "partitionBy": "dt",
          "updatePartitionFilter": "dt >= date_sub(current_date(), interval 3 day)"
        }
      },
      "sqlContent": "\n\n-- Feature table: Daily heartbeat aggregations per user\n-- Debug: Processing heartbeat data with device tracking and extension status\nSELECT    \n  anonymous_id,\n  DATE(timestamp, \"America/Los_Angeles\") AS dt,\n  \n  -- Heartbeat metrics\n  COUNT(*) AS total_heartbeats,\n  COUNTIF(has_both_extensions_enabled) > 0 AS has_both_extensions_enabled,\n  MAX(context_app_version) AS max_app_version,\n  \n  -- App and context data\n  ARRAY_AGG(DISTINCT context_app_name IGNORE NULLS) AS all_context_app_names,\n  \n  -- Device aggregations\n  ARRAY_AGG(DISTINCT context_device_id IGNORE NULLS) AS all_device_ids,\n  ARRAY_AGG(DISTINCT user_id IGNORE NULLS) AS all_user_ids,\n  \n  -- Context resolution for user identity (most frequent values)\n  APPROX_TOP_COUNT(context_country, 1)[OFFSET(0)].value AS context_country_hb,\n  APPROX_TOP_COUNT(context_user_agent, 1)[OFFSET(0)].value AS context_user_agent_hb\n\nFROM `piedotorg-production.extension_production_views.ext_heartbeat`\n\nWHERE\n  context_app_name IN ('extension-adblock', 'extension-shopping', 'extension-unified')\n  \n\nGROUP BY \n  anonymous_id,\n  dt ",
      "dependencies": [
        "ext_heartbeat"
      ],
      "uniqueKey": [
        "dt",
        "anonymous_id"
      ]
    },
    "f_user_identity": {
      "name": "f_user_identity",
      "filePath": "user_features/f_user_identity.sqlx",
      "type": "table",
      "schema": "user_features_dev",
      "tags": [
        "users",
        "features",
        "identity",
        "full_refresh"
      ],
      "description": "User identity resolution including app assignment and context from heartbeats and installs - uses installs_base_w_reinstall consistently",
      "config": {
        "type": "table",
        "schema": "user_features_dev",
        "tags": [
          "users",
          "features",
          "identity",
          "full_refresh"
        ],
        "description": "User identity resolution including app assignment and context from heartbeats and installs - uses installs_base_w_reinstall consistently"
      },
      "sqlContent": "\n\n-- Feature table: User identity resolution (FULL REFRESH)\n-- Debug: Clean user context resolution using consistent install table\nWITH heartbeat_context AS (\n  -- Debug: Getting most frequent country/UA from raw heartbeats per user/app\n  SELECT \n    anonymous_id,\n    context_app_name,\n    APPROX_TOP_COUNT(context_country, 1)[OFFSET(0)].value AS context_country_hb,\n    APPROX_TOP_COUNT(context_user_agent, 1)[OFFSET(0)].value AS context_user_agent_hb,\n    MAX(DATE(timestamp, \"America/Los_Angeles\")) AS last_heartbeat_date,\n    COUNT(*) AS total_heartbeats\n  FROM `piedotorg-production.extension_production_views.ext_heartbeat`\n  WHERE context_app_name IN ('extension-adblock', 'extension-shopping', 'extension-unified')\n    AND context_app_name IS NOT NULL\n  GROUP BY anonymous_id, context_app_name\n),\n\ninstall_context AS (\n  -- Debug: Getting context from installs_base_w_reinstall per user/app\n  SELECT \n    anonymous_id,\n    CONCAT(\"extension-\", extension_type) AS context_app_name,\n    APPROX_TOP_COUNT(context_country, 1)[OFFSET(0)].value AS context_country_install,\n    APPROX_TOP_COUNT(context_user_agent, 1)[OFFSET(0)].value AS context_user_agent_install,\n    MAX(DATE(timestamp, \"America/Los_Angeles\")) AS last_install_date\n  FROM `piedotorg-production.growth_marketing.installs_base_w_reinstall`\n  WHERE extension_type IS NOT NULL\n    AND anonymous_id IS NOT NULL\n  GROUP BY anonymous_id, extension_type\n),\n\nuser_app_assignments AS (\n  -- Debug: Combine heartbeat and install data to assign users to their primary app\n  SELECT\n    COALESCE(heartbeat_context.anonymous_id, install_context.anonymous_id) AS anonymous_id,\n    COALESCE(heartbeat_context.context_app_name, install_context.context_app_name) AS context_app_name,\n    COALESCE(\n      install_context.context_country_install, \n      heartbeat_context.context_country_hb\n    ) AS context_country,\n    COALESCE(\n      install_context.context_user_agent_install, \n      heartbeat_context.context_user_agent_hb  \n    ) AS context_user_agent,\n    -- Use most recent activity (heartbeat or install) to determine primary app\n    ROW_NUMBER() OVER (\n      PARTITION BY COALESCE(heartbeat_context.anonymous_id, install_context.anonymous_id)\n      ORDER BY GREATEST(\n        COALESCE(heartbeat_context.last_heartbeat_date, DATE('1970-01-01')),\n        COALESCE(install_context.last_install_date, DATE('1970-01-01'))\n      ) DESC\n    ) AS row_num\n  FROM heartbeat_context\n  FULL OUTER JOIN install_context \n    USING (anonymous_id, context_app_name)\n)\n\n-- Debug: Final user identity with most recent app assignment\nSELECT\n  anonymous_id,\n  context_app_name,\n  context_country,\n  context_user_agent\nFROM user_app_assignments\nWHERE row_num = 1 -- Most recent app assignment per user ",
      "dependencies": [
        "ext_heartbeat",
        "installs_base_w_reinstall"
      ]
    },
    "f_user_installs": {
      "name": "f_user_installs",
      "filePath": "user_features/f_user_installs.sqlx",
      "type": "incremental",
      "schema": "user_features_dev",
      "tags": [
        "users",
        "features",
        "installs"
      ],
      "description": "Daily aggregated install and uninstall events per user",
      "config": {
        "type": "incremental",
        "schema": "user_features_dev",
        "tags": [
          "users",
          "features",
          "installs"
        ],
        "description": "Daily aggregated install and uninstall events per user",
        "uniqueKey": [
          "dt",
          "anonymous_id"
        ],
        "bigquery": {
          "partitionBy": "dt",
          "updatePartitionFilter": "dt >= date_sub(current_date(), interval 3 day)"
        }
      },
      "sqlContent": "\n\n-- Feature table: Daily install/uninstall aggregations per user\n-- Debug: Processing installs, reinstalls, and uninstalls\nWITH installs_base AS (\n  SELECT\n    anonymous_id,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt,\n    COUNT(*) AS total_installs\n  FROM `piedotorg-production.growth_marketing.installs_base_w_reinstall`\n  \n  \n  \n  GROUP BY anonymous_id, dt\n),\n\nserver_uninstalls_base AS (\n  SELECT\n    CASE\n      WHEN extension_type = \"adblock\" THEN extension_adblock_anonymous_id\n      WHEN extension_type = \"shopping\" THEN extension_shopping_anonymous_id  \n      WHEN extension_type = \"unified\" THEN extension_unified_anonymous_id\n      ELSE NULL\n    END AS anonymous_id,\n    CONCAT(\"extension-\", extension_type) AS context_app_name,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt,\n    COUNT(*) AS server_uninstalls\n  FROM `piedotorg-production.website_production.web_server_uninstall`\n  \n  WHERE \n    \n    CASE\n      WHEN extension_type = \"adblock\" THEN extension_adblock_anonymous_id\n      WHEN extension_type = \"shopping\" THEN extension_shopping_anonymous_id\n      WHEN extension_type = \"unified\" THEN extension_unified_anonymous_id\n      ELSE NULL\n    END IS NOT NULL\n  \n  GROUP BY anonymous_id, context_app_name, dt\n),\n\nweb_uninstalls_base AS (\n  SELECT\n    CASE\n      WHEN extension_type = \"adblock\" THEN extension_adblock_anonymous_id\n      WHEN extension_type = \"shopping\" THEN extension_shopping_anonymous_id\n      WHEN extension_type = \"unified\" THEN extension_unified_anonymous_id  \n      ELSE NULL\n    END AS anonymous_id,\n    CONCAT(\"extension-\", extension_type) AS context_app_name,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt,\n    COUNT(*) AS web_uninstalls\n  FROM `piedotorg-production.website_production.web_uninstall`\n  \n  WHERE \n    \n    CASE\n      WHEN extension_type = \"adblock\" THEN extension_adblock_anonymous_id\n      WHEN extension_type = \"shopping\" THEN extension_shopping_anonymous_id\n      WHEN extension_type = \"unified\" THEN extension_unified_anonymous_id\n      ELSE NULL\n    END IS NOT NULL\n  \n  GROUP BY anonymous_id, context_app_name, dt\n),\n\nuninstalls_combined AS (\n  -- Debug: Combining server and web uninstalls per user/day\n  SELECT\n    anonymous_id,\n    dt,\n    SUM(server_uninstalls) AS total_server_uninstalls,\n    SUM(web_uninstalls) AS total_web_uninstalls,\n    -- Get maximum uninstalls across all app types for a user on a given day\n    MAX(COALESCE(server_uninstalls, 0) + COALESCE(web_uninstalls, 0)) AS max_daily_uninstalls\n  FROM (\n    SELECT anonymous_id, dt, server_uninstalls, 0 AS web_uninstalls\n    FROM server_uninstalls_base\n    \n    UNION ALL\n    \n    SELECT anonymous_id, dt, 0 AS server_uninstalls, web_uninstalls\n    FROM web_uninstalls_base\n  )\n  GROUP BY anonymous_id, dt\n)\n\n-- Debug: Combining all install/uninstall features\nSELECT\n  COALESCE(installs_base.anonymous_id, uninstalls_combined.anonymous_id) AS anonymous_id,\n  COALESCE(installs_base.dt, uninstalls_combined.dt) AS dt,\n  \n  -- Install metrics\n  COALESCE(total_installs, 0) AS total_installs,\n  \n  -- Uninstall metrics\n  COALESCE(total_server_uninstalls, 0) AS total_server_uninstalls,\n  COALESCE(total_web_uninstalls, 0) AS total_web_uninstalls,\n  COALESCE(max_daily_uninstalls, 0) AS max_daily_uninstalls -- replicates GREATEST_ARRAY logic\n\nFROM installs_base\nFULL OUTER JOIN uninstalls_combined\n  USING (anonymous_id, dt) ",
      "dependencies": [
        "installs_base_w_reinstall",
        "web_server_uninstall",
        "web_uninstall"
      ],
      "uniqueKey": [
        "dt",
        "anonymous_id"
      ]
    },
    "f_user_interactions": {
      "name": "f_user_interactions",
      "filePath": "user_features/f_user_interactions.sqlx",
      "type": "incremental",
      "schema": "user_features_dev",
      "tags": [
        "users",
        "features",
        "events"
      ],
      "description": "Daily aggregated user interactions including clicks, shows, and savings actions",
      "config": {
        "type": "incremental",
        "schema": "user_features_dev",
        "tags": [
          "users",
          "features",
          "events"
        ],
        "description": "Daily aggregated user interactions including clicks, shows, and savings actions",
        "uniqueKey": [
          "dt",
          "anonymous_id"
        ],
        "bigquery": {
          "partitionBy": "dt",
          "updatePartitionFilter": "dt >= date_sub(current_date(), interval 3 day)"
        }
      },
      "sqlContent": "\n\n-- Feature table: Daily user interaction aggregations\n-- Debug: Processing all click/show/savings interactions with detailed breakdowns\nSELECT\n  anonymous_id,\n  DATE(timestamp, \"America/Los_Angeles\") AS dt,\n  \n  -- Overall interaction metrics\n  COUNTIF(action = \"click\") AS total_clicks,\n  COUNTIF(action = \"show\") AS total_shows,\n  COUNTIF(action = \"close\") AS total_closes,\n  \n  -- Session-based metrics\n  COUNT(DISTINCT IF(action = \"click\", session_id, NULL)) AS total_click_sessions,\n  COUNT(DISTINCT IF(action = \"show\", session_id, NULL)) AS total_show_sessions,\n  \n  -- Adblock cashback popup interactions\n  COUNTIF(action = \"show\" AND automation_type = \"cashback_adblock\") AS shows_adblock_cashback_popup,\n  COUNTIF(action = \"click\" AND automation_type = \"cashback_adblock\") AS clicks_adblock_cashback_popup,\n  COUNTIF(action = \"close\" AND automation_type = \"cashback_adblock\") AS closes_adblock_cashback_popup,\n  \n  -- Popover interactions\n  COUNTIF(action = \"click\" AND surface IN (\"popover\", \"popover_adblock\")) AS clicks_popover,\n  COUNTIF(action = \"show\" AND surface IN (\"popover\", \"popover_adblock\")) AS shows_popover,\n  \n  -- Popover rewards specific\n  COUNTIF(action = \"click\" AND surface IN (\"popover\", \"popover_adblock\") AND is_rewards) AS clicks_popover_rewards,\n  COUNTIF(action = \"show\" AND surface IN (\"popover\", \"popover_adblock\") AND is_rewards) AS shows_popover_rewards,\n  \n  -- Savings coupons with rewards breakdown (c1_r1 = coupons + rewards, c1_r0 = coupons only)\n  COUNTIF(action = \"show\" AND automation_type = \"savings_coupons\" AND is_rewards) AS c1_r1_shows,\n  COUNTIF(action = \"show\" AND automation_type = \"savings_coupons\" AND NOT is_rewards) AS c1_r0_shows,\n  COUNTIF(action = \"click\" AND automation_type = \"savings_coupons\" AND is_rewards) AS c1_r1_clicks,\n  COUNTIF(action = \"click\" AND automation_type = \"savings_coupons\" AND NOT is_rewards) AS c1_r0_clicks,\n  COUNTIF(action = \"close\" AND automation_type = \"savings_coupons\" AND is_rewards) AS c1_r1_closes,\n  COUNTIF(action = \"close\" AND automation_type = \"savings_coupons\" AND NOT is_rewards) AS c1_r0_closes\n\nFROM `piedotorg-production.extension_production_views.ext_savings`\n\n\n\nGROUP BY \n  anonymous_id,\n  dt ",
      "dependencies": [
        "ext_savings"
      ],
      "uniqueKey": [
        "dt",
        "anonymous_id"
      ]
    },
    "f_user_sessions": {
      "name": "f_user_sessions",
      "filePath": "user_features/f_user_sessions.sqlx",
      "type": "incremental",
      "schema": "user_features_dev",
      "tags": [
        "users",
        "features",
        "sessions"
      ],
      "description": "Daily aggregated session and cart activity per user",
      "config": {
        "type": "incremental",
        "schema": "user_features_dev",
        "tags": [
          "users",
          "features",
          "sessions"
        ],
        "description": "Daily aggregated session and cart activity per user",
        "uniqueKey": [
          "dt",
          "anonymous_id"
        ],
        "bigquery": {
          "partitionBy": "dt",
          "updatePartitionFilter": "dt >= date_sub(current_date(), interval 3 day)"
        }
      },
      "sqlContent": "\n\n-- Feature table: Daily session and cart aggregations per user\n-- Debug: Processing session starts and cart visits together\nWITH sessions_base AS (\n  SELECT\n    anonymous_id,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt,\n    COUNT(*) AS total_sessions_started,\n    COUNTIF(merchant_id != \"pie\") AS non_pie_sessions_started\n  FROM `piedotorg-production.extension_production_views.ext_session_started`\n  \n  \n  \n  GROUP BY anonymous_id, dt\n),\n\ncart_base AS (\n  SELECT\n    anonymous_id,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt,\n    COUNT(*) AS total_carts_visited,\n    COUNT(DISTINCT session_id) AS total_cart_sessions\n  FROM `piedotorg-production.extension_production_views.ext_context_detect`\n  \n  \n  \n  GROUP BY anonymous_id, dt\n)\n\n-- Debug: Full outer join to capture all user activity\nSELECT\n  COALESCE(sessions_base.anonymous_id, cart_base.anonymous_id) AS anonymous_id,\n  COALESCE(sessions_base.dt, cart_base.dt) AS dt,\n  \n  -- Session metrics\n  COALESCE(total_sessions_started, 0) AS total_sessions_started,\n  COALESCE(non_pie_sessions_started, 0) AS non_pie_sessions_started,\n  \n  -- Cart metrics  \n  COALESCE(total_carts_visited, 0) AS total_carts_visited,\n  COALESCE(total_cart_sessions, 0) AS total_cart_sessions\n  \nFROM sessions_base\nFULL OUTER JOIN cart_base\n  USING (anonymous_id, dt) ",
      "dependencies": [
        "ext_session_started",
        "ext_context_detect"
      ],
      "uniqueKey": [
        "dt",
        "anonymous_id"
      ]
    },
    "f_user_transactions": {
      "name": "f_user_transactions",
      "filePath": "user_features/f_user_transactions.sqlx",
      "type": "incremental",
      "schema": "user_features_dev",
      "tags": [
        "users",
        "features",
        "commerce"
      ],
      "description": "Daily aggregated transaction data per user including revenue, millipoints, and transaction types - incremental with all-time lookback for late confirmations",
      "config": {
        "type": "incremental",
        "schema": "user_features_dev",
        "tags": [
          "users",
          "features",
          "commerce"
        ],
        "description": "Daily aggregated transaction data per user including revenue, millipoints, and transaction types - incremental with all-time lookback for late confirmations",
        "uniqueKey": [
          "dt",
          "anonymous_id"
        ],
        "bigquery": {
          "partitionBy": "dt"
        }
      },
      "sqlContent": "\n\n-- Feature table: Daily transaction aggregations per user\n-- Debug: Processing all transaction types with detailed revenue and millipoint tracking\nWITH transaction_base AS (\n  SELECT\n    anonymous_id,\n    userId,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt,\n    \n    -- Overall transaction counts\n    COUNT(*) AS total_transactions,\n    COUNTIF(t.state = \"CONFIRMED\") AS confirmed_transactions,\n\n    -- Millipoints (rewards currency)\n    SUM(t.millipoints) AS total_millipoints, -- includes payouts\n    SUM(IF(t.state = \"CONFIRMED\", t.millipoints, 0)) AS total_millipoints_confirmed,\n    SUM(IF(adOfferType != \"PAYOUT\", t.millipoints, 0)) AS earned_millipoints, -- excludes payouts\n    \n    -- Revenue calculations (affiliate + ad offers)\n    SUM(externalSaleValue) AS gmv_cents,\n    SUM(externalCommission) AS commission_cents,\n    SUM(IF(externalStatus = \"CONFIRMED\", externalSaleValue, 0)) AS confirmed_gmv_cents,\n    SUM(IF(externalStatus = \"CONFIRMED\", externalCommission, 0)) AS confirmed_commission_cents,\n\n    -- Transaction type breakdowns\n    COUNTIF(type = \"AD_OFFER\") AS total_ad_offers_transactions,\n    COUNTIF(adOfferType = \"RETARGETING\") AS retargeting_offers_transactions,\n    COUNTIF(adOfferType = \"SEARCH\") AS search_offers_transactions,\n    COUNTIF(type = \"AD_VIEW\") AS ad_view_transactions,\n    COUNTIF(type = \"MANUAL\") AS manual_transactions,\n    COUNTIF(type = \"ONBOARDING\") AS onboarding_transactions,\n    COUNTIF(type = \"PAYOUT\") AS payout_transactions,\n    COUNTIF(type = \"AFFILIATE\") AS affiliate_transactions,\n    COUNTIF(type = \"REFERRAL\") AS referral_transactions,\n\n    -- Millipoints by transaction type\n    SUM(IF(type = \"AD_OFFER\", t.millipoints, 0)) AS ad_offer_millipoints,\n    SUM(IF(adOfferType = \"RETARGETING\", t.millipoints, 0)) AS retargeting_millipoints,\n    SUM(IF(adOfferType = \"SEARCH\", t.millipoints, 0)) AS search_millipoints,\n    SUM(IF(type = \"AD_VIEW\", t.millipoints, 0)) AS ad_view_millipoints,\n    SUM(IF(type = \"MANUAL\", t.millipoints, 0)) AS manual_millipoints,\n    SUM(IF(type = \"REFERRAL\", t.millipoints, 0)) AS referral_millipoints,\n    SUM(IF(type = \"ONBOARDING\", t.millipoints, 0)) AS onboarding_millipoints,\n    SUM(IF(type = \"PAYOUT\", t.millipoints, 0)) AS payout_millipoints,\n    SUM(IF(type = \"AFFILIATE\", t.millipoints, 0)) AS affiliate_millipoints\n\n  FROM `piedotorg-production.data_science_dev.transactions_expanded_view` t\n  \n  where timestamp is not null\n  GROUP BY anonymous_id, userId, dt\n\n),\n\nrewards_transaction_base AS (\n  SELECT\n    anonymous_id,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt,\n    \n    -- Rewards popup interactions\n    COUNTIF(action = \"show\" AND surface = \"rewards_transaction_popup\") AS rewards_shows,\n    COUNTIF(action IN (\"click\", \"login\") AND surface = \"rewards_transaction_popup\") AS rewards_clicks,\n    COUNTIF(action = \"close\" AND surface = \"rewards_transaction_popup\") AS rewards_closes,\n    COUNTIF(action = \"no_show\" AND surface = \"rewards_transaction_popup\") AS rewards_no_shows,\n    COUNTIF(action = \"show\" AND surface = \"rewards_transaction_toast_success\") AS rewards_success_toasts\n    \n  FROM `piedotorg-production.extension_production_views.ext_rewards_transaction`\n  \n  GROUP BY anonymous_id, dt\n),\n\nuser_balances_base AS (\n  SELECT\n    userId,\n    dt,\n    end_balance AS ir_balance -- current IR (rewards) balance\n  FROM `piedotorg-production.users.user_balances`\n)\n\n-- Debug: Combining all transaction-related features with proper aggregation\nSELECT\n  COALESCE(transaction_base.anonymous_id, rewards_transaction_base.anonymous_id) AS anonymous_id,\n  COALESCE(transaction_base.dt, rewards_transaction_base.dt) AS dt,\n  MAX(transaction_base.userId) AS userId, -- Use MAX to handle potential nulls\n  \n  -- Transaction metrics\n  COALESCE(MAX(total_transactions), 0) AS total_transactions,\n  COALESCE(MAX(confirmed_transactions), 0) AS confirmed_transactions,\n  COALESCE(MAX(total_millipoints), 0) AS total_millipoints,\n  COALESCE(MAX(total_millipoints_confirmed), 0) AS total_millipoints_confirmed,\n  COALESCE(MAX(earned_millipoints), 0) AS earned_millipoints,\n  \n  -- Revenue metrics (Note: ad_offer budget revenue removed - now tracked separately in campaigns_campaignbudgetevents)\n  COALESCE(MAX(commission_cents), 0) AS total_revenue_cents,\n  COALESCE(MAX(gmv_cents), 0) AS gmv_cents,\n  COALESCE(MAX(commission_cents), 0) AS commission_cents,\n  COALESCE(MAX(confirmed_gmv_cents), 0) AS confirmed_gmv_cents,\n  COALESCE(MAX(confirmed_commission_cents), 0) AS confirmed_commission_cents,\n  \n  -- Transaction type counts\n  COALESCE(MAX(total_ad_offers_transactions), 0) AS total_ad_offers_transactions,\n  COALESCE(MAX(ad_offer_millipoints), 0) AS ad_offer_millipoints,\n  COALESCE(MAX(retargeting_offers_transactions), 0) AS retargeting_offers_transactions,\n  COALESCE(MAX(retargeting_millipoints), 0) AS retargeting_millipoints,\n  COALESCE(MAX(search_offers_transactions), 0) AS search_offers_transactions,\n  COALESCE(MAX(search_millipoints), 0) AS search_millipoints,\n  COALESCE(MAX(ad_view_transactions), 0) AS ad_view_transactions,\n  COALESCE(MAX(ad_view_millipoints), 0) AS ad_view_millipoints,\n  COALESCE(MAX(manual_transactions), 0) AS manual_transactions,\n  COALESCE(MAX(manual_millipoints), 0) AS manual_millipoints,\n  COALESCE(MAX(onboarding_transactions), 0) AS onboarding_transactions,\n  COALESCE(MAX(onboarding_millipoints), 0) AS onboarding_millipoints,\n  COALESCE(MAX(payout_transactions), 0) AS payout_transactions,\n  COALESCE(MAX(payout_millipoints), 0) AS payout_millipoints,\n  COALESCE(MAX(affiliate_transactions), 0) AS affiliate_transactions,\n  COALESCE(MAX(affiliate_millipoints), 0) AS affiliate_millipoints,\n  COALESCE(MAX(referral_millipoints), 0) AS referral_millipoints,\n  \n  -- Rewards transaction popup metrics\n  COALESCE(MAX(rewards_shows), 0) AS rewards_shows,\n  COALESCE(MAX(rewards_clicks), 0) AS rewards_clicks,\n  COALESCE(MAX(rewards_closes), 0) AS rewards_closes,\n  COALESCE(MAX(rewards_no_shows), 0) AS rewards_no_shows,\n  COALESCE(MAX(rewards_success_toasts), 0) AS rewards_success_toasts,\n  \n  -- Balance data\n  MAX(user_balances_base.ir_balance) AS ir_balance\n  \nFROM transaction_base\nFULL OUTER JOIN rewards_transaction_base\n  USING (anonymous_id, dt)\nLEFT JOIN user_balances_base\n  ON transaction_base.userId = user_balances_base.userId \n  AND transaction_base.dt = user_balances_base.dt \n\nGROUP BY \n  COALESCE(transaction_base.anonymous_id, rewards_transaction_base.anonymous_id),\n  COALESCE(transaction_base.dt, rewards_transaction_base.dt) ",
      "dependencies": [
        "transactions_expanded_view",
        "ext_rewards_transaction",
        "user_balances"
      ],
      "uniqueKey": [
        "dt",
        "anonymous_id"
      ]
    },
    "f_user_video_events": {
      "name": "f_user_video_events",
      "filePath": "user_features/f_user_video_events.sqlx",
      "type": "incremental",
      "schema": "user_features_dev",
      "tags": [
        "users",
        "features",
        "video_events"
      ],
      "description": "Daily aggregated video events including YouTube and Twitch adblock activity",
      "config": {
        "type": "incremental",
        "schema": "user_features_dev",
        "tags": [
          "users",
          "features",
          "video_events"
        ],
        "description": "Daily aggregated video events including YouTube and Twitch adblock activity",
        "uniqueKey": [
          "dt",
          "anonymous_id"
        ],
        "bigquery": {
          "partitionBy": "dt",
          "updatePartitionFilter": "dt >= date_sub(current_date(), interval 3 day)"
        }
      },
      "sqlContent": "\n\n-- Feature table: Daily video event aggregations per user\n-- Debug: Processing YouTube and Twitch adblock events\nWITH youtube_ads_base AS (\n  SELECT\n    anonymous_id,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt,\n    COUNT(*) AS total_youtube_ads_seen\n  FROM `piedotorg-production.extension_production_views.adblock_youtube_ad_seen`\n  \n  \n  \n  GROUP BY anonymous_id, dt\n),\n\nyoutube_errors_base AS (\n  SELECT\n    anonymous_id,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt,\n    COUNT(*) AS total_youtube_errors\n  FROM `piedotorg-production.extension_production_views.adblock_youtube_error_msg`\n  \n  \n  \n  GROUP BY anonymous_id, dt\n),\n\nyoutube_embeds_base AS (\n  SELECT\n    anonymous_id,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt,\n    COUNT(*) AS total_youtube_embeds\n  FROM `piedotorg-production.extension_production_views.adblock_youtube_video_embed`\n  \n  \n  \n  GROUP BY anonymous_id, dt\n),\n\nyoutube_success_base AS (\n  SELECT\n    anonymous_id,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt,\n    COUNT(*) AS total_youtube_successes\n  FROM `piedotorg-production.extension_production_views.adblock_youtube_video_success`\n  \n  \n  \n  GROUP BY anonymous_id, dt\n),\n\ntwitch_ads_base AS (\n  SELECT\n    anonymous_id,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt,\n    COUNT(*) AS total_twitch_ads_seen\n  FROM `piedotorg-production.extension_production_views.adblock_twitch_ad_seen`\n  \n  \n  \n  GROUP BY anonymous_id, dt\n),\n\ngeneral_errors_base AS (\n  SELECT\n    anonymous_id,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt,\n    COUNT(*) AS total_adblock_errors\n  FROM `piedotorg-production.extension_production_views.adblock_error_msg`\n  \n  \n  \n  GROUP BY anonymous_id, dt\n)\n\n-- Debug: Combining all video event features\nSELECT\n  COALESCE(\n    youtube_ads_base.anonymous_id,\n    youtube_errors_base.anonymous_id, \n    youtube_embeds_base.anonymous_id,\n    youtube_success_base.anonymous_id,\n    twitch_ads_base.anonymous_id,\n    general_errors_base.anonymous_id\n  ) AS anonymous_id,\n  COALESCE(\n    youtube_ads_base.dt,\n    youtube_errors_base.dt,\n    youtube_embeds_base.dt, \n    youtube_success_base.dt,\n    twitch_ads_base.dt,\n    general_errors_base.dt\n  ) AS dt,\n  \n  -- YouTube metrics\n  COALESCE(total_youtube_ads_seen, 0) AS total_youtube_ads_seen,\n  COALESCE(total_youtube_errors, 0) AS total_youtube_errors,\n  COALESCE(total_youtube_embeds, 0) AS total_youtube_embeds,  \n  COALESCE(total_youtube_successes, 0) AS total_youtube_successes,\n  \n  -- Twitch metrics  \n  COALESCE(total_twitch_ads_seen, 0) AS total_twitch_ads_seen,\n  \n  -- Error metrics\n  COALESCE(total_adblock_errors, 0) AS total_adblock_errors\n\nFROM youtube_ads_base\nFULL OUTER JOIN youtube_errors_base\n  USING (anonymous_id, dt)\nFULL OUTER JOIN youtube_embeds_base\n  USING (anonymous_id, dt)\nFULL OUTER JOIN youtube_success_base\n  USING (anonymous_id, dt)\nFULL OUTER JOIN twitch_ads_base\n  USING (anonymous_id, dt)\nFULL OUTER JOIN general_errors_base\n  USING (anonymous_id, dt) ",
      "dependencies": [
        "adblock_youtube_ad_seen",
        "adblock_youtube_error_msg",
        "adblock_youtube_video_embed",
        "adblock_youtube_video_success",
        "adblock_twitch_ad_seen",
        "adblock_error_msg"
      ],
      "uniqueKey": [
        "dt",
        "anonymous_id"
      ]
    },
    "int_transaction_mapping": {
      "name": "int_transaction_mapping",
      "filePath": "user_intermediate/int_transaction_mapping.sqlx",
      "type": "table",
      "schema": "user_intermediate_dev",
      "tags": [
        "users",
        "intermediate",
        "commerce",
        "full_refresh"
      ],
      "description": "Maps affiliate transactions to anonymous IDs via redirect tracking - requires full historical context for proper linking",
      "config": {
        "type": "table",
        "schema": "user_intermediate_dev",
        "tags": [
          "users",
          "intermediate",
          "commerce",
          "full_refresh"
        ],
        "description": "Maps affiliate transactions to anonymous IDs via redirect tracking - requires full historical context for proper linking"
      },
      "sqlContent": "\n\n-- Intermediate table: Transaction to anonymous ID mapping (FULL REFRESH)\n-- Debug: Complex transaction linking that requires full historical context\nWITH base_transactions AS (\n  SELECT\n    transactionId,\n    trackId,\n    TIMESTAMP_MILLIS(externalCreated) AS transaction_created,\n    externalCommission,\n    externalstatus,\n    externalSaleValue,\n    provider\n  FROM `piedotorg-production.analytics_etl.transactions_affiliatetransactions`\n),\n\nbase_redirects AS (\n  SELECT\n    anonymousid AS anonymous_id,\n    extTagId AS ext_tag_id,\n    trackId,\n    affiliateLinkId,\n    sessionid,\n    merchantId,\n    IFNULL(timestamp, TIMESTAMP_MILLIS(sessionid)) AS redirect_timestamp\n  FROM `piedotorg-production.backend_analytics.outbound_redirect`\n)\n\n-- Debug: Linking transactions to users via trackId from redirects\nSELECT\n  base_transactions.transactionId,\n  base_redirects.anonymous_id,\n  base_transactions.externalstatus,\n  SUM(base_transactions.externalCommission) AS commission_cents,\n  SUM(base_transactions.externalSaleValue) AS gmv_cents,\n  MIN(base_transactions.transaction_created) AS first_transaction_created,\n  MAX(base_transactions.transaction_created) AS last_transaction_created,\n  COUNT(*) AS transaction_count\nFROM base_transactions\nLEFT JOIN base_redirects\n  USING (trackId)\nWHERE base_redirects.anonymous_id IS NOT NULL -- Only transactions we can link to users\nGROUP BY \n  transactionId,\n  anonymous_id,\n  externalstatus ",
      "dependencies": [
        "transactions_affiliatetransactions",
        "outbound_redirect"
      ]
    },
    "int_user_cohort_logic": {
      "name": "int_user_cohort_logic",
      "filePath": "user_intermediate/int_user_cohort_logic.sqlx",
      "type": "incremental",
      "schema": "user_intermediate_dev",
      "tags": [
        "users",
        "intermediate",
        "identity"
      ],
      "description": "User cohort logic calculations including cohort dates and days since cohort - incremental with all-time lookback for consistency",
      "config": {
        "type": "incremental",
        "schema": "user_intermediate_dev",
        "tags": [
          "users",
          "intermediate",
          "identity"
        ],
        "description": "User cohort logic calculations including cohort dates and days since cohort - incremental with all-time lookback for consistency",
        "uniqueKey": [
          "dt",
          "anonymous_id"
        ],
        "bigquery": {
          "partitionBy": "dt"
        }
      },
      "sqlContent": "\n\n-- Intermediate table: User cohort logic (INCREMENTAL)\n-- Debug: Complex cohort calculations with all-time lookback for consistency\nWITH install_dates AS (\n  -- Debug: Get earliest install per anonymous_id (by timestamp, not alphabetical)\n  SELECT\n    anonymous_id,\n    DATE(first_install_ts, \"America/Los_Angeles\") AS install_day_pst,\n    first_install_ts AS install_timestamp,\n    puci\n  FROM (\n    SELECT\n      anonymous_id,\n      first_install_ts,\n      puci,\n      ROW_NUMBER() OVER (PARTITION BY anonymous_id ORDER BY first_install_ts ASC) AS rn\n    FROM `piedotorg-production.growth_marketing.installs_base_w_reinstall`\n    WHERE is_first_install = true\n  )\n  WHERE rn = 1\n),\n\nfirst_heartbeat_dates AS (\n  -- Debug: Calculate first heartbeat date per user across all days\n  SELECT\n    anonymous_id,\n    MIN(CASE WHEN total_heartbeats > 0 THEN dt ELSE NULL END) AS first_heartbeat_date\n  FROM `piedotorg-production.user_intermediate_dev.int_user_daily_base`\n  GROUP BY anonymous_id\n),\n\nuninstall_tracking AS (\n  -- Debug: Track most recent uninstall date per user\n  SELECT\n    anonymous_id,\n    MAX(CASE WHEN max_daily_uninstalls > 0 THEN dt ELSE NULL END) AS most_recent_uninstall_date\n  FROM `piedotorg-production.user_intermediate_dev.int_user_daily_base`\n  GROUP BY anonymous_id\n)\n\n-- Debug: Final cohort logic with all calculations\nSELECT\n  base.*,\n  \n  -- Install and heartbeat dates\n  install_dates.install_day_pst,\n  install_dates.install_timestamp,\n  install_dates.puci,\n  first_heartbeat_dates.first_heartbeat_date,\n  uninstall_tracking.most_recent_uninstall_date,\n  \n  -- Cohort date calculation (earliest of install or first heartbeat)\n  LEAST(\n    COALESCE(install_dates.install_day_pst, DATE('2099-12-31')),\n    COALESCE(first_heartbeat_dates.first_heartbeat_date, DATE('2099-12-31'))\n  ) AS cohort_date,\n  \n  -- Days since cohort calculation\n  DATE_DIFF(\n    base.dt,\n    LEAST(\n      COALESCE(install_dates.install_day_pst, DATE('2099-12-31')),\n      COALESCE(first_heartbeat_dates.first_heartbeat_date, DATE('2099-12-31'))\n    ),\n    DAY\n  ) AS days_since_cohort_date\n\nFROM `piedotorg-production.user_intermediate_dev.int_user_daily_base` base\nLEFT JOIN install_dates\n  USING (anonymous_id)\nLEFT JOIN first_heartbeat_dates\n  USING (anonymous_id)\nLEFT JOIN uninstall_tracking\n  USING (anonymous_id) ",
      "dependencies": [
        "int_user_daily_base",
        "installs_base_w_reinstall"
      ],
      "uniqueKey": [
        "dt",
        "anonymous_id"
      ]
    },
    "int_user_daily_base": {
      "name": "int_user_daily_base",
      "filePath": "user_intermediate/int_user_daily_base.sqlx",
      "type": "incremental",
      "schema": "user_intermediate_dev",
      "tags": [
        "users",
        "intermediate",
        "daily"
      ],
      "description": "Core daily user table, combining all user activity into a single wide table - incremental with all-time lookback for transaction updates",
      "config": {
        "type": "incremental",
        "schema": "user_intermediate_dev",
        "tags": [
          "users",
          "intermediate",
          "daily"
        ],
        "description": "Core daily user table, combining all user activity into a single wide table - incremental with all-time lookback for transaction updates",
        "uniqueKey": [
          "dt",
          "anonymous_id"
        ],
        "bigquery": {
          "partitionBy": "dt"
        }
      },
      "sqlContent": "\n\n-- Intermediate table: Daily user base aggregations\n-- Debug: Combining all feature tables into comprehensive daily user view\nWITH heartbeat_agg AS (\n  SELECT\n    anonymous_id,\n    dt,\n    SUM(total_heartbeats) AS total_heartbeats,\n    LOGICAL_OR(has_both_extensions_enabled) AS has_both_extensions_enabled,\n    MAX(max_app_version) AS max_app_version,\n    ARRAY_CONCAT_AGG(all_device_ids) AS all_device_ids,\n    ARRAY_CONCAT_AGG(all_user_ids) AS all_user_ids\n  FROM `piedotorg-production.user_features_dev.f_user_heartbeats`\n  GROUP BY anonymous_id, dt\n),\n\n-- Pre-compute COALESCE values to ensure consistency between SELECT and GROUP BY\nbase_data AS (\n  SELECT\n    COALESCE(\n      COALESCE(\n        heartbeat_agg.anonymous_id,\n        f_user_sessions.anonymous_id,\n        f_user_interactions.anonymous_id,\n        f_user_transactions.anonymous_id,\n        f_user_commerce.anonymous_id,\n        f_user_installs.anonymous_id,\n        f_user_events.anonymous_id,\n        f_user_video_events.anonymous_id\n      ),\n      'null_anonymous_id' -- Simple constant for all NULL anonymous_id cases\n    ) AS final_anonymous_id,\n    \n    COALESCE(\n      heartbeat_agg.dt,\n      f_user_sessions.dt,\n      f_user_interactions.dt,\n      f_user_transactions.dt,\n      f_user_commerce.dt,\n      f_user_installs.dt,\n      f_user_events.dt,\n      f_user_video_events.dt\n    ) AS final_dt,\n    \n    -- Keep all original data for aggregation\n    heartbeat_agg,\n    f_user_sessions,\n    f_user_interactions,\n    f_user_transactions,\n    f_user_commerce,\n    f_user_installs,\n    f_user_events,\n    f_user_video_events,\n    f_user_identity\n    \n  FROM heartbeat_agg\n  FULL OUTER JOIN `piedotorg-production.user_features_dev.f_user_sessions` f_user_sessions\n    USING (anonymous_id, dt)\n  FULL OUTER JOIN `piedotorg-production.user_features_dev.f_user_interactions` f_user_interactions\n    USING (anonymous_id, dt)\n  FULL OUTER JOIN `piedotorg-production.user_features_dev.f_user_transactions` f_user_transactions\n    USING (anonymous_id, dt)\n  FULL OUTER JOIN `piedotorg-production.user_features_dev.f_user_commerce` f_user_commerce\n    USING (anonymous_id, dt)\n  FULL OUTER JOIN `piedotorg-production.user_features_dev.f_user_installs` f_user_installs\n    USING (anonymous_id, dt)\n  FULL OUTER JOIN `piedotorg-production.user_features_dev.f_user_events` f_user_events\n    USING (anonymous_id, dt)\n  FULL OUTER JOIN `piedotorg-production.user_features_dev.f_user_video_events` f_user_video_events\n    USING (anonymous_id, dt)\n  LEFT JOIN `piedotorg-production.user_features_dev.f_user_identity` f_user_identity\n    USING (anonymous_id)\n)\n\n-- Debug: Final aggregation using pre-computed keys\nSELECT\n  final_anonymous_id AS anonymous_id,\n  final_dt AS dt,\n  \n  -- User identity data\n  MAX(f_user_identity.context_app_name) AS context_app_name,\n  MAX(f_user_identity.context_country) AS context_country,\n  MAX(f_user_identity.context_user_agent) AS context_user_agent,\n  MAX(f_user_transactions.userId) AS userId,\n  \n  -- Heartbeat metrics\n  COALESCE(MAX(heartbeat_agg.total_heartbeats), 0) AS total_heartbeats,\n  COALESCE(LOGICAL_OR(heartbeat_agg.has_both_extensions_enabled), FALSE) AS has_both_extensions_enabled,\n  MAX(heartbeat_agg.max_app_version) AS max_app_version,\n  ARRAY_CONCAT_AGG(heartbeat_agg.all_device_ids) AS all_device_ids,\n  ARRAY_CONCAT_AGG(heartbeat_agg.all_user_ids) AS all_user_ids,\n  \n  -- Session metrics\n  COALESCE(MAX(f_user_sessions.total_sessions_started), 0) AS total_sessions_started,\n  COALESCE(MAX(f_user_sessions.non_pie_sessions_started), 0) AS non_pie_sessions_started,\n  COALESCE(MAX(f_user_sessions.total_carts_visited), 0) AS total_carts_visited,\n  COALESCE(MAX(f_user_sessions.total_cart_sessions), 0) AS total_cart_sessions,\n  \n  -- Interaction metrics\n  COALESCE(MAX(f_user_interactions.total_clicks), 0) AS total_clicks,\n  COALESCE(MAX(f_user_interactions.total_shows), 0) AS total_shows,\n  COALESCE(MAX(f_user_interactions.total_click_sessions), 0) AS total_click_sessions,\n  COALESCE(MAX(f_user_interactions.total_show_sessions), 0) AS total_show_sessions,\n  COALESCE(MAX(f_user_interactions.shows_adblock_cashback_popup), 0) AS shows_adblock_cashback_popup,\n  COALESCE(MAX(f_user_interactions.clicks_adblock_cashback_popup), 0) AS clicks_adblock_cashback_popup,\n  COALESCE(MAX(f_user_interactions.closes_adblock_cashback_popup), 0) AS closes_adblock_cashback_popup,\n  COALESCE(MAX(f_user_interactions.clicks_popover), 0) AS clicks_popover,\n  COALESCE(MAX(f_user_interactions.shows_popover), 0) AS shows_popover,\n  COALESCE(MAX(f_user_interactions.clicks_popover_rewards), 0) AS clicks_popover_rewards,\n  COALESCE(MAX(f_user_interactions.shows_popover_rewards), 0) AS shows_popover_rewards,\n  COALESCE(MAX(f_user_interactions.c1_r1_shows), 0) AS c1_r1_shows,\n  COALESCE(MAX(f_user_interactions.c1_r0_shows), 0) AS c1_r0_shows,\n  COALESCE(MAX(f_user_interactions.c1_r1_clicks), 0) AS c1_r1_clicks,\n  COALESCE(MAX(f_user_interactions.c1_r0_clicks), 0) AS c1_r0_clicks,\n  COALESCE(MAX(f_user_interactions.c1_r1_closes), 0) AS c1_r1_closes,\n  COALESCE(MAX(f_user_interactions.c1_r0_closes), 0) AS c1_r0_closes,\n  \n  -- Transaction metrics\n  COALESCE(MAX(f_user_transactions.total_transactions), 0) AS total_transactions,\n  COALESCE(MAX(f_user_transactions.confirmed_transactions), 0) AS confirmed_transactions,\n  COALESCE(MAX(f_user_transactions.total_millipoints), 0) AS total_millipoints,\n  COALESCE(MAX(f_user_transactions.total_millipoints_confirmed), 0) AS total_millipoints_confirmed,\n  COALESCE(MAX(f_user_transactions.earned_millipoints), 0) AS earned_millipoints,\n  COALESCE(MAX(f_user_transactions.total_revenue_cents), 0) AS total_revenue_cents,\n  COALESCE(MAX(f_user_transactions.gmv_cents), 0) AS gmv_cents,\n  COALESCE(MAX(f_user_transactions.commission_cents), 0) AS commission_cents,\n  COALESCE(MAX(f_user_transactions.confirmed_gmv_cents), 0) AS confirmed_gmv_cents,\n  COALESCE(MAX(f_user_transactions.confirmed_commission_cents), 0) AS confirmed_commission_cents,\n  \n  -- Transaction type metrics (Note: ad_offer_revenue_cents removed - budget data now tracked separately in campaigns_campaignbudgetevents)\n  COALESCE(MAX(f_user_transactions.total_ad_offers_transactions), 0) AS total_ad_offers_transactions,\n  COALESCE(MAX(f_user_transactions.ad_offer_millipoints), 0) AS ad_offer_millipoints,\n  COALESCE(MAX(f_user_transactions.retargeting_offers_transactions), 0) AS retargeting_offers_transactions,\n  COALESCE(MAX(f_user_transactions.retargeting_millipoints), 0) AS retargeting_millipoints,\n  COALESCE(MAX(f_user_transactions.search_offers_transactions), 0) AS search_offers_transactions,\n  COALESCE(MAX(f_user_transactions.search_millipoints), 0) AS search_millipoints,\n  COALESCE(MAX(f_user_transactions.ad_view_transactions), 0) AS ad_view_transactions,\n  COALESCE(MAX(f_user_transactions.ad_view_millipoints), 0) AS ad_view_millipoints,\n  COALESCE(MAX(f_user_transactions.manual_transactions), 0) AS manual_transactions,\n  COALESCE(MAX(f_user_transactions.manual_millipoints), 0) AS manual_millipoints,\n  COALESCE(MAX(f_user_transactions.onboarding_transactions), 0) AS onboarding_transactions,\n  COALESCE(MAX(f_user_transactions.onboarding_millipoints), 0) AS onboarding_millipoints,\n  COALESCE(MAX(f_user_transactions.payout_transactions), 0) AS payout_transactions,\n  COALESCE(MAX(f_user_transactions.payout_millipoints), 0) AS payout_millipoints,\n  COALESCE(MAX(f_user_transactions.affiliate_transactions), 0) AS affiliate_transactions,\n  COALESCE(MAX(f_user_transactions.affiliate_millipoints), 0) AS affiliate_millipoints,\n  COALESCE(MAX(f_user_transactions.referral_millipoints), 0) AS referral_millipoints,\n  \n  -- Rewards transaction metrics\n  COALESCE(MAX(f_user_transactions.rewards_shows), 0) AS rewards_shows,\n  COALESCE(MAX(f_user_transactions.rewards_clicks), 0) AS rewards_clicks,\n  COALESCE(MAX(f_user_transactions.rewards_closes), 0) AS rewards_closes,\n  COALESCE(MAX(f_user_transactions.rewards_no_shows), 0) AS rewards_no_shows,\n  COALESCE(MAX(f_user_transactions.rewards_success_toasts), 0) AS rewards_success_toasts,\n  MAX(f_user_transactions.ir_balance) AS ir_balance,\n  \n  -- Commerce metrics\n  COALESCE(MAX(f_user_commerce.total_affiliate_tags), 0) AS total_affiliate_tags,\n  COALESCE(MAX(f_user_commerce.total_tag_sessions), 0) AS total_tag_sessions,\n  COALESCE(MAX(f_user_commerce.total_order_confirmations), 0) AS total_order_confirmations,\n  COALESCE(MAX(f_user_commerce.order_confirmation_sessions), 0) AS order_confirmation_sessions,\n  COALESCE(MAX(f_user_commerce.tagged_order_confirmations), 0) AS tagged_order_confirmations,\n  COALESCE(MAX(f_user_commerce.total_redirects), 0) AS total_redirects,\n  COALESCE(MAX(f_user_commerce.total_redirect_sessions), 0) AS total_redirect_sessions,\n  COALESCE(MAX(f_user_commerce.rewards_transaction_popup_redirects), 0) AS rewards_transaction_popup_redirects,\n  COALESCE(MAX(f_user_commerce.coupon_popup_shopping_redirects), 0) AS coupon_popup_shopping_redirects,\n  COALESCE(MAX(f_user_commerce.cashback_popup_adblock_redirects), 0) AS cashback_popup_adblock_redirects,\n  COALESCE(MAX(f_user_commerce.rewards_popup_shopping_redirects), 0) AS rewards_popup_shopping_redirects,\n  COALESCE(MAX(f_user_commerce.popover_coupon_list_redirects), 0) AS popover_coupon_list_redirects,\n  COALESCE(MAX(f_user_commerce.login_retargeting_redirects), 0) AS login_retargeting_redirects,\n  COALESCE(MAX(f_user_commerce.standdown_redirects), 0) AS standdown_redirects,\n  \n  -- Install/Uninstall metrics\n  COALESCE(MAX(f_user_installs.total_installs), 0) AS total_installs,\n  COALESCE(MAX(f_user_installs.total_server_uninstalls), 0) AS total_server_uninstalls,\n  COALESCE(MAX(f_user_installs.total_web_uninstalls), 0) AS total_web_uninstalls,\n  COALESCE(MAX(f_user_installs.max_daily_uninstalls), 0) AS max_daily_uninstalls,\n  \n  -- Event metrics\n  COALESCE(MAX(f_user_events.total_standdowns), 0) AS total_standdowns,\n  COALESCE(MAX(f_user_events.stop_standdowns), 0) AS stop_standdowns,\n  COALESCE(MAX(f_user_events.notag_standdowns), 0) AS notag_standdowns,\n  COALESCE(MAX(f_user_events.suppress_standdowns), 0) AS suppress_standdowns,\n  COALESCE(MAX(f_user_events.total_pages_w_ads_seen), 0) AS total_pages_w_ads_seen,\n  COALESCE(MAX(f_user_events.total_ad_placements_seen), 0) AS total_ad_placements_seen,\n  COALESCE(MAX(f_user_events.total_pixels_seen), 0) AS total_pixels_seen,\n  MAX(f_user_events.other_adblockers) AS other_adblockers,\n  \n  -- Video event metrics  \n  COALESCE(MAX(f_user_video_events.total_youtube_ads_seen), 0) AS total_youtube_ads_seen,\n  COALESCE(MAX(f_user_video_events.total_youtube_errors), 0) AS total_youtube_errors,\n  COALESCE(MAX(f_user_video_events.total_youtube_embeds), 0) AS total_youtube_embeds,\n  COALESCE(MAX(f_user_video_events.total_youtube_successes), 0) AS total_youtube_successes,\n  COALESCE(MAX(f_user_video_events.total_twitch_ads_seen), 0) AS total_twitch_ads_seen,\n  COALESCE(MAX(f_user_video_events.total_adblock_errors), 0) AS total_adblock_errors\n\nFROM base_data\n\nGROUP BY final_anonymous_id, final_dt ",
      "dependencies": [
        "f_user_heartbeats",
        "f_user_sessions",
        "f_user_interactions",
        "f_user_transactions",
        "f_user_commerce",
        "f_user_installs",
        "f_user_events",
        "f_user_identity",
        "f_user_video_events"
      ],
      "uniqueKey": [
        "dt",
        "anonymous_id"
      ]
    },
    "user_day_funnel": {
      "name": "user_day_funnel",
      "filePath": "users_final/user_day_funnel.sqlx",
      "type": "incremental",
      "schema": "users_dev",
      "tags": [
        "users",
        "final",
        "daily"
      ],
      "description": "Final comprehensive user day funnel table - incremental with all-time lookback for transaction accuracy",
      "config": {
        "type": "incremental",
        "schema": "users_dev",
        "tags": [
          "users",
          "final",
          "daily"
        ],
        "description": "Final comprehensive user day funnel table - incremental with all-time lookback for transaction accuracy",
        "uniqueKey": [
          "dt",
          "anonymous_id"
        ],
        "bigquery": {
          "partitionBy": "dt"
        }
      },
      "sqlContent": "\n\n-- Final table: User day funnel\n-- Debug: Final comprehensive user funnel replicating original logic with full feature set\nSELECT\n  -- Core identifiers\n  dt,\n  anonymous_id,\n  userId,\n  context_app_name,\n  context_country,\n  context_user_agent,\n  other_adblockers,\n  \n  -- Heartbeat metrics\n  total_heartbeats,\n  max_app_version,\n  has_both_extensions_enabled,\n  \n  -- Session metrics\n  total_sessions_started,\n  non_pie_sessions_started,\n  total_carts_visited,\n  total_cart_sessions,\n  \n  -- Interaction metrics\n  total_clicks,\n  total_shows,\n  total_click_sessions,\n  total_show_sessions,\n  \n  -- Affiliate/Commerce metrics\n  total_affiliate_tags AS total_tags,\n  total_tag_sessions,\n  total_redirects,\n  total_redirect_sessions,\n  \n  -- IR Balance\n  ir_balance,\n  \n  -- Install/Uninstall metrics\n  max_daily_uninstalls AS uninstalls, -- replicates GREATEST_ARRAY logic\n  total_server_uninstalls AS server_uninstalls,\n  total_web_uninstalls AS web_uninstalls,\n  total_installs AS num_installs,\n  \n  -- Transaction metrics\n  total_transactions,\n  confirmed_transactions,\n  total_millipoints,\n  total_millipoints_confirmed,\n  earned_millipoints,\n  total_revenue_cents,\n  \n  -- Affiliate transaction metrics\n  gmv_cents,\n  commission_cents,\n  confirmed_gmv_cents,\n  confirmed_commission_cents,\n  \n  -- Ad offer metrics (Note: all_adoffer_revenue_cents removed - budget data now tracked separately in campaigns_campaignbudgetevents)\n  total_ad_offers_transactions AS all_offers_trx,\n  ad_offer_millipoints AS all_adoffer_millipoints,\n  \n  -- Retargeting metrics\n  retargeting_offers_transactions AS retargeting_offers_trx,\n  retargeting_millipoints,\n  \n  -- Search metrics\n  search_offers_transactions AS search_offers_trx,\n  search_millipoints,\n  \n  -- Ad view metrics\n  ad_view_transactions AS ad_view_trx,\n  ad_view_millipoints,\n  \n  -- Manual metrics\n  manual_transactions AS manual_trx,\n  manual_millipoints,\n  \n  -- Onboarding metrics\n  onboarding_transactions AS onboarding_trx,\n  onboarding_millipoints,\n  \n  -- Payout metrics\n  payout_transactions AS payout_trx,\n  payout_millipoints,\n  \n  -- Affiliate metrics\n  affiliate_transactions AS total_affiliate_transactions,\n  affiliate_millipoints,\n  \n  -- Referral metrics\n  referral_millipoints,\n  \n  -- Rewards transaction metrics\n  rewards_shows,\n  rewards_clicks,\n  rewards_closes,\n  rewards_no_shows,\n  \n  -- Order confirmation metrics\n  order_confirmation_sessions,\n  total_order_confirmations,\n  \n  -- Standdown metrics\n  total_standdowns AS all_standdowns,\n  stop_standdowns,\n  notag_standdowns,\n  suppress_standdowns,\n  \n  -- Ad metrics\n  total_pages_w_ads_seen,\n  total_ad_placements_seen,\n  \n  -- Video event metrics\n  total_youtube_ads_seen,\n  total_youtube_errors,\n  total_youtube_embeds,\n  total_youtube_successes,\n  total_twitch_ads_seen,\n  total_adblock_errors,\n  \n  -- Device arrays\n  all_device_ids,\n  all_user_ids,\n  \n  -- Cohort calculations\n  first_heartbeat_date,\n  install_timestamp,\n  install_day_pst,\n  puci,\n  cohort_date,\n  days_since_cohort_date,\n  most_recent_uninstall_date AS most_recent_uninstall\n\nFROM `piedotorg-production.user_intermediate_dev.int_user_cohort_logic` ",
      "dependencies": [
        "int_user_cohort_logic",
        "int_user_daily_base",
        "installs_base_w_reinstall"
      ],
      "uniqueKey": [
        "dt",
        "anonymous_id"
      ]
    },
    "ai_intent_engine_offer": {
      "name": "ai_intent_engine_offer",
      "filePath": "sources/ai_intent_engine_offer.sqlx",
      "type": "table",
      "schema": "backend_analytics",
      "tags": [],
      "description": "AI-powered personalized offers delivered through Pie's Intent Engine system with detailed engagement metrics",
      "config": {
        "type": "table",
        "schema": "backend_analytics",
        "tags": [],
        "description": "AI-powered personalized offers delivered through Pie's Intent Engine system with detailed engagement metrics"
      },
      "sqlContent": "",
      "dependencies": []
    },
    "amazon_dsp_campaign_funnel": {
      "name": "amazon_dsp_campaign_funnel",
      "filePath": "sources/amazon_dsp_campaign_funnel.sqlx",
      "type": "table",
      "schema": "growth_marketing",
      "tags": [],
      "description": "Amazon DSP campaign performance data with daily aggregation",
      "config": {
        "type": "table",
        "schema": "growth_marketing",
        "tags": [],
        "description": "Amazon DSP campaign performance data with daily aggregation"
      },
      "sqlContent": "",
      "dependencies": []
    },
    "apple_search_campaign_funnel": {
      "name": "apple_search_campaign_funnel",
      "filePath": "sources/apple_search_campaign_funnel.sqlx",
      "type": "table",
      "schema": "growth_marketing",
      "tags": [],
      "description": "Apple Search Ads campaign performance data with daily aggregation",
      "config": {
        "type": "table",
        "schema": "growth_marketing",
        "tags": [],
        "description": "Apple Search Ads campaign performance data with daily aggregation"
      },
      "sqlContent": "",
      "dependencies": []
    },
    "campaigns_campaignbudgetevents": {
      "name": "campaigns_campaignbudgetevents",
      "filePath": "sources/campaigns_campaignbudgetevents.sqlx",
      "type": "table",
      "schema": "analytics_etl",
      "tags": [],
      "description": "Campaign budget events tracking budget usage for offers and campaigns",
      "config": {
        "type": "table",
        "schema": "analytics_etl",
        "tags": [],
        "description": "Campaign budget events tracking budget usage for offers and campaigns"
      },
      "sqlContent": "",
      "dependencies": []
    },
    "campaigns_campaigns": {
      "name": "campaigns_campaigns",
      "filePath": "sources/campaigns_campaigns.sqlx",
      "type": "table",
      "schema": "analytics_etl",
      "tags": [],
      "description": "Campaign configuration data including state, budget, and lifecycle timestamps",
      "config": {
        "type": "table",
        "schema": "analytics_etl",
        "tags": [],
        "description": "Campaign configuration data including state, budget, and lifecycle timestamps"
      },
      "sqlContent": "",
      "dependencies": []
    },
    "campaigns_placements": {
      "name": "campaigns_placements",
      "filePath": "sources/campaigns_placements.sqlx",
      "type": "table",
      "schema": "analytics_etl",
      "tags": [],
      "description": "Campaign placements with placement hash, template, and match data",
      "config": {
        "type": "table",
        "schema": "analytics_etl",
        "tags": [],
        "description": "Campaign placements with placement hash, template, and match data"
      },
      "sqlContent": "",
      "dependencies": []
    },
    "dpr_manual_external": {
      "name": "dpr_manual_external",
      "filePath": "sources/dpr_manual_external.sqlx",
      "type": "table",
      "schema": "growth_marketing",
      "tags": [],
      "description": "Manual external CPI (cost per install) data for bizdev partnerships",
      "config": {
        "type": "table",
        "schema": "growth_marketing",
        "tags": [],
        "description": "Manual external CPI (cost per install) data for bizdev partnerships"
      },
      "sqlContent": "",
      "dependencies": []
    },
    "dpr_manual_mapping": {
      "name": "dpr_manual_mapping",
      "filePath": "sources/dpr_manual_mapping.sqlx",
      "type": "table",
      "schema": "growth_marketing",
      "tags": [],
      "description": "Manual mapping table for placement metadata including platform, media source, and funnel classification",
      "config": {
        "type": "table",
        "schema": "growth_marketing",
        "tags": [],
        "description": "Manual mapping table for placement metadata including platform, media source, and funnel classification"
      },
      "sqlContent": "",
      "dependencies": []
    },
    "dpr_manual_publisher_cpms": {
      "name": "dpr_manual_publisher_cpms",
      "filePath": "sources/dpr_manual_publisher_cpms.sqlx",
      "type": "table",
      "schema": "growth_marketing",
      "tags": [],
      "config": {
        "type": "table",
        "schema": "growth_marketing",
        "tags": []
      },
      "sqlContent": "",
      "dependencies": []
    },
    "dpr_manual_spend": {
      "name": "dpr_manual_spend",
      "filePath": "sources/dpr_manual_spend.sqlx",
      "type": "table",
      "schema": "growth_marketing",
      "tags": [],
      "description": "Manual influencer and partnership spend data with amortization settings",
      "config": {
        "type": "table",
        "schema": "growth_marketing",
        "tags": [],
        "description": "Manual influencer and partnership spend data with amortization settings"
      },
      "sqlContent": "",
      "dependencies": []
    },
    "adblock_error_msg": {
      "name": "adblock_error_msg",
      "filePath": "sources/ext_adblock_error_msg.sqlx",
      "type": "table",
      "schema": "extension_production_views",
      "tags": [],
      "config": {
        "type": "table",
        "schema": "extension_production_views",
        "tags": []
      },
      "sqlContent": "",
      "dependencies": []
    },
    "adblock_twitch_ad_seen": {
      "name": "adblock_twitch_ad_seen",
      "filePath": "sources/ext_adblock_twitch_ad_seen.sqlx",
      "type": "table",
      "schema": "extension_production_views",
      "tags": [],
      "config": {
        "type": "table",
        "schema": "extension_production_views",
        "tags": []
      },
      "sqlContent": "",
      "dependencies": []
    },
    "adblock_youtube_ad_seen": {
      "name": "adblock_youtube_ad_seen",
      "filePath": "sources/ext_adblock_youtube_ad_seen.sqlx",
      "type": "table",
      "schema": "extension_production_views",
      "tags": [],
      "config": {
        "type": "table",
        "schema": "extension_production_views",
        "tags": []
      },
      "sqlContent": "",
      "dependencies": []
    },
    "adblock_youtube_error_msg": {
      "name": "adblock_youtube_error_msg",
      "filePath": "sources/ext_adblock_youtube_error_msg.sqlx",
      "type": "table",
      "schema": "extension_production_views",
      "tags": [],
      "config": {
        "type": "table",
        "schema": "extension_production_views",
        "tags": []
      },
      "sqlContent": "",
      "dependencies": []
    },
    "adblock_youtube_video_embed": {
      "name": "adblock_youtube_video_embed",
      "filePath": "sources/ext_adblock_youtube_video_embed.sqlx",
      "type": "table",
      "schema": "extension_production_views",
      "tags": [],
      "config": {
        "type": "table",
        "schema": "extension_production_views",
        "tags": []
      },
      "sqlContent": "",
      "dependencies": []
    },
    "adblock_youtube_video_success": {
      "name": "adblock_youtube_video_success",
      "filePath": "sources/ext_adblock_youtube_video_success.sqlx",
      "type": "table",
      "schema": "extension_production_views",
      "tags": [],
      "config": {
        "type": "table",
        "schema": "extension_production_views",
        "tags": []
      },
      "sqlContent": "",
      "dependencies": []
    },
    "ext_affiliate_tag": {
      "name": "ext_affiliate_tag",
      "filePath": "sources/ext_affiliate_tag.sqlx",
      "type": "table",
      "schema": "extension_production_views",
      "tags": [],
      "config": {
        "type": "table",
        "schema": "extension_production_views",
        "tags": []
      },
      "sqlContent": "",
      "dependencies": []
    },
    "ext_context_detect": {
      "name": "ext_context_detect",
      "filePath": "sources/ext_context_detect.sqlx",
      "type": "table",
      "schema": "extension_production_views",
      "tags": [],
      "config": {
        "type": "table",
        "schema": "extension_production_views",
        "tags": []
      },
      "sqlContent": "",
      "dependencies": []
    },
    "ext_device_ad_metrics_rollup": {
      "name": "ext_device_ad_metrics_rollup",
      "filePath": "sources/ext_device_ad_metrics_rollup.sqlx",
      "type": "table",
      "schema": "extension_production_views",
      "tags": [],
      "config": {
        "type": "table",
        "schema": "extension_production_views",
        "tags": []
      },
      "sqlContent": "",
      "dependencies": []
    },
    "ext_feedback": {
      "name": "ext_feedback",
      "filePath": "sources/ext_feedback.sqlx",
      "type": "table",
      "schema": "extension_production_views",
      "tags": [],
      "config": {
        "type": "table",
        "schema": "extension_production_views",
        "tags": []
      },
      "sqlContent": "",
      "dependencies": []
    },
    "ext_heartbeat": {
      "name": "ext_heartbeat",
      "filePath": "sources/ext_heartbeat.sqlx",
      "type": "table",
      "schema": "extension_production_views",
      "tags": [],
      "config": {
        "type": "table",
        "schema": "extension_production_views",
        "tags": []
      },
      "sqlContent": "",
      "dependencies": []
    },
    "ext_intent_engine_offer": {
      "name": "ext_intent_engine_offer",
      "filePath": "sources/ext_intent_engine_offer.sqlx",
      "type": "table",
      "schema": "shopping_extension_production",
      "tags": [],
      "description": "Extension intent engine offer events and interactions",
      "config": {
        "type": "table",
        "schema": "shopping_extension_production",
        "tags": [],
        "description": "Extension intent engine offer events and interactions"
      },
      "sqlContent": "",
      "dependencies": []
    },
    "ext_order_confirmation": {
      "name": "ext_order_confirmation",
      "filePath": "sources/ext_order_confirmation.sqlx",
      "type": "table",
      "schema": "extension_production_views",
      "tags": [],
      "config": {
        "type": "table",
        "schema": "extension_production_views",
        "tags": []
      },
      "sqlContent": "",
      "dependencies": []
    },
    "ext_rewards_transaction": {
      "name": "ext_rewards_transaction",
      "filePath": "sources/ext_rewards_transaction.sqlx",
      "type": "table",
      "schema": "extension_production_views",
      "tags": [],
      "config": {
        "type": "table",
        "schema": "extension_production_views",
        "tags": []
      },
      "sqlContent": "",
      "dependencies": []
    },
    "ext_savings": {
      "name": "ext_savings",
      "filePath": "sources/ext_savings.sqlx",
      "type": "table",
      "schema": "extension_production_views",
      "tags": [],
      "config": {
        "type": "table",
        "schema": "extension_production_views",
        "tags": []
      },
      "sqlContent": "",
      "dependencies": []
    },
    "ext_session_started": {
      "name": "ext_session_started",
      "filePath": "sources/ext_session_started.sqlx",
      "type": "table",
      "schema": "extension_production_views",
      "tags": [],
      "config": {
        "type": "table",
        "schema": "extension_production_views",
        "tags": []
      },
      "sqlContent": "",
      "dependencies": []
    },
    "ext_standdown_detected": {
      "name": "ext_standdown_detected",
      "filePath": "sources/ext_standdown_detected.sqlx",
      "type": "table",
      "schema": "extension_production_views",
      "tags": [],
      "config": {
        "type": "table",
        "schema": "extension_production_views",
        "tags": []
      },
      "sqlContent": "",
      "dependencies": []
    },
    "ext_user_settings": {
      "name": "ext_user_settings",
      "filePath": "sources/ext_user_settings.sqlx",
      "type": "table",
      "schema": "extension_production_views",
      "tags": [],
      "config": {
        "type": "table",
        "schema": "extension_production_views",
        "tags": []
      },
      "sqlContent": "",
      "dependencies": []
    },
    "google_campaign_funnel": {
      "name": "google_campaign_funnel",
      "filePath": "sources/google_campaign_funnel.sqlx",
      "type": "table",
      "schema": "growth_marketing",
      "tags": [],
      "description": "Google Ads campaign performance data with daily aggregation",
      "config": {
        "type": "table",
        "schema": "growth_marketing",
        "tags": [],
        "description": "Google Ads campaign performance data with daily aggregation"
      },
      "sqlContent": "",
      "dependencies": []
    },
    "installs_base": {
      "name": "installs_base",
      "filePath": "sources/installs_base.sqlx",
      "type": "table",
      "schema": "growth_marketing",
      "tags": [],
      "config": {
        "type": "table",
        "schema": "growth_marketing",
        "tags": []
      },
      "sqlContent": "",
      "dependencies": []
    },
    "installs_base_w_reinstall": {
      "name": "installs_base_w_reinstall",
      "filePath": "sources/installs_base_w_reinstall.sqlx",
      "type": "table",
      "schema": "growth_marketing",
      "tags": [],
      "config": {
        "type": "table",
        "schema": "growth_marketing",
        "tags": []
      },
      "sqlContent": "",
      "dependencies": []
    },
    "intent_engine_cooldown_triggered": {
      "name": "intent_engine_cooldown_triggered",
      "filePath": "sources/intent_engine_cooldown_triggered.sqlx",
      "type": "table",
      "schema": "backend_analytics",
      "tags": [],
      "description": "Intent engine cooldown events with device and time range data",
      "config": {
        "type": "table",
        "schema": "backend_analytics",
        "tags": [],
        "description": "Intent engine cooldown events with device and time range data"
      },
      "sqlContent": "",
      "dependencies": []
    },
    "intent_engine_offer_group_match": {
      "name": "intent_engine_offer_group_match",
      "filePath": "sources/intent_engine_offer_group_match.sqlx",
      "type": "table",
      "schema": "backend_analytics",
      "tags": [],
      "description": "Intent engine offer group matching events with placement and campaign data",
      "config": {
        "type": "table",
        "schema": "backend_analytics",
        "tags": [],
        "description": "Intent engine offer group matching events with placement and campaign data"
      },
      "sqlContent": "",
      "dependencies": []
    },
    "meta_campaign_funnel": {
      "name": "meta_campaign_funnel",
      "filePath": "sources/meta_campaign_funnel.sqlx",
      "type": "table",
      "schema": "growth_marketing",
      "tags": [],
      "description": "Meta (Facebook/Instagram) campaign performance data with daily aggregation",
      "config": {
        "type": "table",
        "schema": "growth_marketing",
        "tags": [],
        "description": "Meta (Facebook/Instagram) campaign performance data with daily aggregation"
      },
      "sqlContent": "",
      "dependencies": []
    },
    "msft_campaign_funnel": {
      "name": "msft_campaign_funnel",
      "filePath": "sources/msft_campaign_funnel.sqlx",
      "type": "table",
      "schema": "growth_marketing",
      "tags": [],
      "description": "Microsoft Ads campaign performance data with daily aggregation",
      "config": {
        "type": "table",
        "schema": "growth_marketing",
        "tags": [],
        "description": "Microsoft Ads campaign performance data with daily aggregation"
      },
      "sqlContent": "",
      "dependencies": []
    },
    "outbound_redirect": {
      "name": "outbound_redirect",
      "filePath": "sources/outbound_redirect.sqlx",
      "type": "table",
      "schema": "backend_analytics",
      "tags": [],
      "config": {
        "type": "table",
        "schema": "backend_analytics",
        "tags": []
      },
      "sqlContent": "",
      "dependencies": []
    },
    "product_outbound_redirect": {
      "name": "product_outbound_redirect",
      "filePath": "sources/product_outbound_redirect.sqlx",
      "type": "table",
      "schema": "backend_analytics",
      "tags": [],
      "description": "Product outbound redirect events for tracking product-specific affiliate links",
      "config": {
        "type": "table",
        "schema": "backend_analytics",
        "tags": [],
        "description": "Product outbound redirect events for tracking product-specific affiliate links"
      },
      "sqlContent": "",
      "dependencies": []
    },
    "reviews": {
      "name": "reviews",
      "filePath": "sources/reviews.sqlx",
      "type": "table",
      "schema": "extensions_data",
      "tags": [],
      "config": {
        "type": "table",
        "schema": "extensions_data",
        "tags": []
      },
      "sqlContent": "",
      "dependencies": []
    },
    "tiktok_ads_campaign_funnel": {
      "name": "tiktok_ads_campaign_funnel",
      "filePath": "sources/tiktok_ads_campaign_funnel.sqlx",
      "type": "table",
      "schema": "growth_marketing",
      "tags": [],
      "description": "TikTok Ads campaign performance data with daily aggregation",
      "config": {
        "type": "table",
        "schema": "growth_marketing",
        "tags": [],
        "description": "TikTok Ads campaign performance data with daily aggregation"
      },
      "sqlContent": "",
      "dependencies": []
    },
    "transactions_adoffers": {
      "name": "transactions_adoffers",
      "filePath": "sources/transactions_adoffers.sqlx",
      "type": "table",
      "schema": "analytics_etl",
      "tags": [],
      "description": "Ad offers data including campaign associations and budget usage",
      "config": {
        "type": "table",
        "schema": "analytics_etl",
        "tags": [],
        "description": "Ad offers data including campaign associations and budget usage"
      },
      "sqlContent": "",
      "dependencies": []
    },
    "transactions_adviews": {
      "name": "transactions_adviews",
      "filePath": "sources/transactions_adviews.sqlx",
      "type": "table",
      "schema": "analytics_etl",
      "tags": [],
      "description": "Ad view transactions including FAIR_AD and AI_AD types with metadata about creators, offers, and display context",
      "config": {
        "type": "table",
        "schema": "analytics_etl",
        "tags": [],
        "description": "Ad view transactions including FAIR_AD and AI_AD types with metadata about creators, offers, and display context"
      },
      "sqlContent": "",
      "dependencies": []
    },
    "transactions_affiliatetransactions": {
      "name": "transactions_affiliatetransactions",
      "filePath": "sources/transactions_affiliatetransactions.sqlx",
      "type": "table",
      "schema": "analytics_etl",
      "tags": [],
      "config": {
        "type": "table",
        "schema": "analytics_etl",
        "tags": []
      },
      "sqlContent": "",
      "dependencies": []
    },
    "transactions_campaigns": {
      "name": "transactions_campaigns",
      "filePath": "sources/transactions_campaigns.sqlx",
      "type": "table",
      "schema": "analytics_etl",
      "tags": [],
      "description": "Campaign data including budget, merchant info, and campaign lifecycle",
      "config": {
        "type": "table",
        "schema": "analytics_etl",
        "tags": [],
        "description": "Campaign data including budget, merchant info, and campaign lifecycle"
      },
      "sqlContent": "",
      "dependencies": []
    },
    "transactions_transactions": {
      "name": "transactions_transactions",
      "filePath": "sources/transactions_transactions.sqlx",
      "type": "table",
      "schema": "analytics_etl",
      "tags": [],
      "description": "Core transactions table with transaction details and states",
      "config": {
        "type": "table",
        "schema": "analytics_etl",
        "tags": [],
        "description": "Core transactions table with transaction details and states"
      },
      "sqlContent": "",
      "dependencies": []
    },
    "user_anon_mapping": {
      "name": "user_anon_mapping",
      "filePath": "sources/user_anon_mapping.sqlx",
      "type": "table",
      "schema": "users",
      "tags": [],
      "description": "Mapping between user IDs and anonymous IDs for user identity resolution",
      "config": {
        "type": "table",
        "schema": "users",
        "tags": [],
        "description": "Mapping between user IDs and anonymous IDs for user identity resolution"
      },
      "sqlContent": "",
      "dependencies": []
    },
    "user_balances": {
      "name": "user_balances",
      "filePath": "sources/user_balances.sqlx",
      "type": "table",
      "schema": "users",
      "tags": [],
      "config": {
        "type": "table",
        "schema": "users",
        "tags": []
      },
      "sqlContent": "",
      "dependencies": []
    },
    "web_intent_engine_offer": {
      "name": "web_intent_engine_offer",
      "filePath": "sources/web_intent_engine_offer.sqlx",
      "type": "table",
      "schema": "website_production",
      "tags": [],
      "description": "Website intent engine offer events and interactions from Pie's web platform",
      "config": {
        "type": "table",
        "schema": "website_production",
        "tags": [],
        "description": "Website intent engine offer events and interactions from Pie's web platform"
      },
      "sqlContent": "",
      "dependencies": []
    },
    "web_report_bug": {
      "name": "web_report_bug",
      "filePath": "sources/web_report_bug.sqlx",
      "type": "table",
      "schema": "website_production",
      "tags": [],
      "config": {
        "type": "table",
        "schema": "website_production",
        "tags": []
      },
      "sqlContent": "",
      "dependencies": []
    },
    "web_server_uninstall": {
      "name": "web_server_uninstall",
      "filePath": "sources/web_server_uninstall.sqlx",
      "type": "table",
      "schema": "website_production",
      "tags": [],
      "config": {
        "type": "table",
        "schema": "website_production",
        "tags": []
      },
      "sqlContent": "",
      "dependencies": []
    },
    "web_uninstall": {
      "name": "web_uninstall",
      "filePath": "sources/web_uninstall.sqlx",
      "type": "table",
      "schema": "website_production",
      "tags": [],
      "config": {
        "type": "table",
        "schema": "website_production",
        "tags": []
      },
      "sqlContent": "",
      "dependencies": []
    },
    "growth_marketing_all_campaigns_assertions_uniqueKey_0": {
      "name": "growth_marketing_all_campaigns_assertions_uniqueKey_0",
      "filePath": "growth/all_campaigns.sqlx",
      "type": "table",
      "schema": "dataform_dev_assertions",
      "tags": [
        "growth",
        "campaigns",
        "daily",
        "marketing"
      ],
      "config": {
        "type": "table",
        "schema": "dataform_dev_assertions",
        "tags": [
          "growth",
          "campaigns",
          "daily",
          "marketing"
        ]
      },
      "sqlContent": "\nSELECT\n  *\nFROM (\n  SELECT\n    date, puci, ad_set_name,\n    COUNT(1) AS index_row_count\n  FROM `piedotorg-production.growth_marketing.all_campaigns`\n  GROUP BY date, puci, ad_set_name\n  ) AS data\nWHERE index_row_count > 1\n",
      "dependencies": [
        "all_campaigns"
      ]
    },
    "growth_marketing_all_campaigns_assertions_rowConditions": {
      "name": "growth_marketing_all_campaigns_assertions_rowConditions",
      "filePath": "growth/all_campaigns.sqlx",
      "type": "table",
      "schema": "dataform_dev_assertions",
      "tags": [
        "growth",
        "campaigns",
        "daily",
        "marketing"
      ],
      "config": {
        "type": "table",
        "schema": "dataform_dev_assertions",
        "tags": [
          "growth",
          "campaigns",
          "daily",
          "marketing"
        ]
      },
      "sqlContent": "\nSELECT\n  'date IS NOT NULL' AS failing_row_condition,\n  *\nFROM `piedotorg-production.growth_marketing.all_campaigns`\nWHERE NOT (date IS NOT NULL)\nUNION ALL\nSELECT\n  'puci IS NOT NULL' AS failing_row_condition,\n  *\nFROM `piedotorg-production.growth_marketing.all_campaigns`\nWHERE NOT (puci IS NOT NULL)\nUNION ALL\nSELECT\n  'source IS NOT NULL' AS failing_row_condition,\n  *\nFROM `piedotorg-production.growth_marketing.all_campaigns`\nWHERE NOT (source IS NOT NULL)\n",
      "dependencies": [
        "all_campaigns"
      ]
    },
    "all_campaigns_no_duplicates_after_2025": {
      "name": "all_campaigns_no_duplicates_after_2025",
      "filePath": "growth/all_campaigns_validation.sqlx",
      "type": "table",
      "schema": "growth_marketing",
      "tags": [
        "growth",
        "validation",
        "data_quality"
      ],
      "description": "Validates that there are no duplicate puci/date combinations after 2025-01-01",
      "config": {
        "type": "table",
        "schema": "growth_marketing",
        "tags": [
          "growth",
          "validation",
          "data_quality"
        ],
        "description": "Validates that there are no duplicate puci/date combinations after 2025-01-01"
      },
      "sqlContent": "\n\n-- This assertion will fail if any puci/date combination has more than 1 row after 2025\nSELECT\n  date,\n  puci,\n  COUNT(*) as row_count,\n  ARRAY_AGG(source ORDER BY source) as sources,\n  ARRAY_AGG(cost ORDER BY source) as costs\nFROM `piedotorg-production.growth_marketing.all_campaigns`\nWHERE date >= '2025-01-01'\nGROUP BY date, puci\nHAVING COUNT(*) > 1",
      "dependencies": [
        "all_campaigns"
      ]
    },
    "growth_marketing_dev_bizdev_spend_assertions_rowConditions": {
      "name": "growth_marketing_dev_bizdev_spend_assertions_rowConditions",
      "filePath": "growth/bizdev_spend.sqlx",
      "type": "table",
      "schema": "dataform_dev_assertions",
      "tags": [
        "growth",
        "bizdev",
        "daily"
      ],
      "config": {
        "type": "table",
        "schema": "dataform_dev_assertions",
        "tags": [
          "growth",
          "bizdev",
          "daily"
        ]
      },
      "sqlContent": "\nSELECT\n  'date IS NOT NULL' AS failing_row_condition,\n  *\nFROM `piedotorg-production.growth_marketing_dev.bizdev_spend`\nWHERE NOT (date IS NOT NULL)\nUNION ALL\nSELECT\n  'puci IS NOT NULL' AS failing_row_condition,\n  *\nFROM `piedotorg-production.growth_marketing_dev.bizdev_spend`\nWHERE NOT (puci IS NOT NULL)\nUNION ALL\nSELECT\n  'placement IS NOT NULL' AS failing_row_condition,\n  *\nFROM `piedotorg-production.growth_marketing_dev.bizdev_spend`\nWHERE NOT (placement IS NOT NULL)\nUNION ALL\nSELECT\n  'product IS NOT NULL' AS failing_row_condition,\n  *\nFROM `piedotorg-production.growth_marketing_dev.bizdev_spend`\nWHERE NOT (product IS NOT NULL)\n",
      "dependencies": [
        "bizdev_spend"
      ]
    },
    "backend_frontend_ratio_monitor": {
      "name": "backend_frontend_ratio_monitor",
      "filePath": "intent_engine/assertions/backend_frontend_ratio_monitor.sqlx",
      "type": "table",
      "schema": "intent_engine_dev",
      "tags": [
        "data_quality",
        "intent_engine",
        "offers",
        "monitoring"
      ],
      "description": "Monitors the ratio of backend events without frontend interactions - alerts if ratio deviates significantly from expected ~8-10%",
      "config": {
        "type": "table",
        "schema": "intent_engine_dev",
        "tags": [
          "data_quality",
          "intent_engine",
          "offers",
          "monitoring"
        ],
        "description": "Monitors the ratio of backend events without frontend interactions - alerts if ratio deviates significantly from expected ~8-10%"
      },
      "sqlContent": "\n\n-- Monitor backend→frontend conversion rate with offer_presented dimension\n-- Expected: Events marked offer_presented=true should have frontend matches\n-- Events marked offer_presented=false/NULL are legitimate consideration-only events\n-- Excludes AI offers which naturally have high consideration rates (~35%)\n\nWITH backend_frontend_stats AS (\n  SELECT \n    intent_engine_type,\n    \n    -- Total events breakdown\n    COUNT(*) as total_backend_events,\n    COUNT(CASE WHEN offer_presented = true THEN 1 END) as presented_events,\n    COUNT(CASE WHEN offer_presented != true OR offer_presented IS NULL THEN 1 END) as consideration_only_events,\n    \n    -- Frontend match breakdown\n    COUNT(CASE WHEN source_type IS NOT NULL THEN 1 END) as events_with_frontend_match,\n    COUNT(CASE WHEN offer_presented = true AND source_type IS NOT NULL THEN 1 END) as presented_with_frontend_match,\n    COUNT(CASE WHEN offer_presented = true AND source_type IS NULL THEN 1 END) as presented_without_frontend_match,\n    \n    -- Key ratios\n    ROUND(COUNT(CASE WHEN offer_presented = true AND source_type IS NULL THEN 1 END) * 100.0 / \n          NULLIF(COUNT(CASE WHEN offer_presented = true THEN 1 END), 0), 2) as presented_orphaned_pct,\n    ROUND(COUNT(CASE WHEN source_type IS NULL THEN 1 END) * 100.0 / COUNT(*), 2) as total_orphaned_pct\n    \n  FROM `piedotorg-production.intent_engine_dev.offer_expanded_view`\n  WHERE DATE(ts) >= DATE_SUB(CURRENT_DATE(), INTERVAL 1 DAY)\n    AND intent_engine_type NOT IN ('AI', 'MCP')  -- Exclude AI offers\n  GROUP BY intent_engine_type\n)\n\n-- Alert on data quality issues: presented events without frontend matches\nSELECT \n  intent_engine_type,\n  total_backend_events,\n  presented_events,\n  consideration_only_events,\n  events_with_frontend_match,\n  presented_with_frontend_match,\n  presented_without_frontend_match,\n  presented_orphaned_pct,\n  total_orphaned_pct,\n  CASE \n    WHEN presented_orphaned_pct > 5 THEN \n      CONCAT('DATA QUALITY ISSUE: ', CAST(presented_orphaned_pct AS STRING), \n             '% of presented events have no frontend match for ', intent_engine_type, ' (expected ~0%)')\n    WHEN intent_engine_type IN ('WEBSITE', 'WEBSITE_ONBOARDING') AND presented_events = 0 THEN\n      CONCAT('BACKEND LOGGING ISSUE: 0 events marked as presented for ', intent_engine_type, \n             ' but frontend events exist')\n    ELSE NULL\n  END as alert_message\nFROM backend_frontend_stats\nWHERE \n  presented_orphaned_pct > 5  -- Data quality issue: presented but no frontend match\n  OR (intent_engine_type IN ('WEBSITE', 'WEBSITE_ONBOARDING') AND presented_events = 0)  -- Backend logging issue",
      "dependencies": [
        "offer_expanded_view"
      ]
    },
    "chatgpt_null_tag_monitor": {
      "name": "chatgpt_null_tag_monitor",
      "filePath": "intent_engine/assertions/chatgpt_null_tag_monitor.sqlx",
      "type": "table",
      "schema": "intent_engine_dev_assertions",
      "tags": [],
      "description": "Monitor for ChatGPT transactions without tag attribution from Sept 4, 2025 onward. These indicate direct affiliate purchases bypassing the offer system.",
      "config": {
        "type": "table",
        "schema": "intent_engine_dev_assertions",
        "tags": [],
        "description": "Monitor for ChatGPT transactions without tag attribution from Sept 4, 2025 onward. These indicate direct affiliate purchases bypassing the offer system."
      },
      "sqlContent": "\n\n-- Alert if we see ChatGPT transactions without ext_tag_id from Sept 4, 2025 onward\n-- This helps monitor if ChatGPT feature is properly routing through offer system\nSELECT \n  transactionId,\n  userId,\n  merchantId,\n  DATE(created_coalesce_ts) as transaction_date,\n  type,\n  state,\n  externalSaleValue,\n  trackId,\n  affiliateLinkId,\n  'ChatGPT transaction without tag - bypassed offer system' as alert_reason\nFROM `piedotorg-production.data_science_dev.transactions_expanded_view`\nWHERE feature = 'chatgpt'\n  AND ext_tag_id IS NULL\n  AND DATE(created_coalesce_ts) >= '2025-09-04'\n  -- This query should return 0 rows if all ChatGPT transactions are properly tagged",
      "dependencies": [
        "transactions_expanded_view"
      ]
    },
    "frontend_offers_have_backend_match": {
      "name": "frontend_offers_have_backend_match",
      "filePath": "intent_engine/assertions/frontend_offers_have_backend_match.sqlx",
      "type": "table",
      "schema": "intent_engine_dev",
      "tags": [
        "data_quality",
        "intent_engine",
        "offers"
      ],
      "description": "Ensures all frontend offer events (ext + AI) have corresponding backend matching events",
      "config": {
        "type": "table",
        "schema": "intent_engine_dev",
        "tags": [
          "data_quality",
          "intent_engine",
          "offers"
        ],
        "description": "Ensures all frontend offer events (ext + AI) have corresponding backend matching events"
      },
      "sqlContent": "\n\n-- Assert that all frontend offer events have backend matches\n-- This validates our LEFT JOIN assumption in offer_expanded_view\n\nWITH unified_frontend_offers AS (\n  -- Extension offers\n  SELECT \n    request_id,\n    'ext' as source_type,\n    timestamp\n  FROM `piedotorg-production.shopping_extension_production.ext_intent_engine_offer`\n  WHERE DATE(timestamp) >= DATE_SUB(CURRENT_DATE(), INTERVAL 1 DAY)\n  \n  UNION ALL\n  \n  -- AI offers  \n  SELECT\n    request_id,\n    'ai' as source_type,\n    TIMESTAMP_MILLIS(timestamp_ms) as timestamp\n  FROM `piedotorg-production.backend_analytics.ai_intent_engine_offer`\n  WHERE DATE(TIMESTAMP_MILLIS(timestamp_ms)) >= DATE_SUB(CURRENT_DATE(), INTERVAL 1 DAY)\n),\n\norphaned_frontend_events AS (\n  SELECT \n    fe.request_id,\n    fe.source_type,\n    fe.timestamp as frontend_timestamp,\n    be.request_id IS NULL as is_orphaned\n  FROM unified_frontend_offers fe\n  LEFT JOIN `piedotorg-production.backend_analytics.intent_engine_offer_group_match` be\n    ON fe.request_id = be.request_id\n  WHERE be.request_id IS NULL  -- Only orphaned events\n)\n\n-- Assertion fails if ANY orphaned frontend events exist\nSELECT \n  request_id,\n  source_type,\n  frontend_timestamp,\n  CONCAT('Orphaned ', source_type, ' offer event with request_id: ', request_id) as error_message\nFROM orphaned_frontend_events",
      "dependencies": [
        "ext_intent_engine_offer",
        "ai_intent_engine_offer",
        "intent_engine_offer_group_match"
      ]
    },
    "raw_vs_distinct_variance_monitor": {
      "name": "raw_vs_distinct_variance_monitor",
      "filePath": "intent_engine/assertions/raw_vs_distinct_variance_monitor.sqlx",
      "type": "table",
      "schema": "dataform_dev_assertions",
      "tags": [],
      "description": "Monitor variance between raw and distinct counts for shows, clicks, redeems. Expected variance is 1.0-1.15 (up to 15%) for shows/redeems due to duplicate events. Clicks may be higher due to re-clicks. Alerts on variance above 15% or below 95%.",
      "config": {
        "type": "table",
        "schema": "dataform_dev_assertions",
        "tags": [],
        "description": "Monitor variance between raw and distinct counts for shows, clicks, redeems. Expected variance is 1.0-1.15 (up to 15%) for shows/redeems due to duplicate events. Clicks may be higher due to re-clicks. Alerts on variance above 15% or below 95%."
      },
      "sqlContent": "\n\n-- Monitor raw vs distinct count variance\n-- Expected: Some variance is normal due to:\n-- 1. Multiple frontend events per offer (show + view, multiple clicks, etc.)\n-- 2. User behavior patterns (re-clicks, multiple interactions)\n-- 3. Duplicate events from dual tracking systems\n-- Alert threshold set at 1.15 (15% variance) for normal operations\n\nWITH variance_check AS (\n  SELECT \n    dt,\n    campaign_id,\n    merchant_id,\n    period,\n    \n    -- Shows variance - expect ~1.0-1.15 with fixed GROUPING SETS\n    CASE \n      WHEN shows > 0 THEN SAFE_DIVIDE(shows_raw, shows)\n      ELSE 0\n    END as shows_ratio,\n    \n    -- Clicks variance - may be higher due to re-clicks  \n    CASE \n      WHEN clicks > 0 THEN SAFE_DIVIDE(clicks_raw, clicks)\n      ELSE 0\n    END as clicks_ratio,\n    \n    -- Redeems variance - should be close to shows ratio\n    CASE \n      WHEN redeems > 0 THEN SAFE_DIVIDE(redeems_raw, redeems)\n      ELSE 0\n    END as redeems_ratio,\n    \n    shows,\n    shows_raw,\n    clicks,\n    clicks_raw,\n    redeems,\n    redeems_raw\n    \n  FROM `piedotorg-production.intent_engine_dev.offer_campaign_ir_base`\n  WHERE DATE(dt) >= DATE_SUB(CURRENT_DATE(), INTERVAL 3 DAY)\n    AND period = 'day'  -- Daily aggregation only\n    AND intent_engine_type IN ('AI', 'MCP')  -- Focus on AI offers where we expect some variance\n    AND (shows > 0 OR clicks > 0 OR redeems > 0)  -- Only check rows with actual activity\n)\n\nSELECT \n  dt,\n  campaign_id, \n  merchant_id,\n  shows_ratio,\n  clicks_ratio,\n  redeems_ratio,\n  CONCAT('Shows: ', shows_raw, '/', shows, ' = ', ROUND(shows_ratio, 2), 'x') as shows_detail,\n  CONCAT('Clicks: ', clicks_raw, '/', clicks, ' = ', ROUND(clicks_ratio, 2), 'x') as clicks_detail,\n  CONCAT('Redeems: ', redeems_raw, '/', redeems, ' = ', ROUND(redeems_ratio, 2), 'x') as redeems_detail\nFROM variance_check\nWHERE \n  -- Alert on unexpectedly high variance (above 15% for shows/redeems, higher for clicks)\n  shows_ratio > 1.15 \n  OR clicks_ratio > 2.0  -- Clicks can be higher due to legitimate re-clicks\n  OR redeems_ratio > 1.15\n  -- Alert on unexpectedly low variance (below 0.95 suggests possible data loss)  \n  OR (shows_ratio < 0.95 AND shows > 5)\n  OR (clicks_ratio < 0.95 AND clicks > 5)\n  OR (redeems_ratio < 0.95 AND redeems > 5)",
      "dependencies": [
        "offer_campaign_ir_base"
      ]
    },
    "tag_consistency_check": {
      "name": "tag_consistency_check",
      "filePath": "intent_engine/assertions/tag_consistency_check.sqlx",
      "type": "table",
      "schema": "intent_engine_dev_assertions",
      "tags": [],
      "description": "Ensures that when both tag_id and ext_tag_id are present in transactions, they are always equal",
      "config": {
        "type": "table",
        "schema": "intent_engine_dev_assertions",
        "tags": [],
        "description": "Ensures that when both tag_id and ext_tag_id are present in transactions, they are always equal"
      },
      "sqlContent": "\n\n-- Check that transactions never have conflicting tag values\n-- When both tag_id and ext_tag_id exist, they must be equal\nSELECT \n  transactionId,\n  ext_tag_id,\n  tag_id,\n  trackId,\n  merchantId,\n  created_coalesce_ts\nFROM `piedotorg-production.data_science_dev.transactions_expanded_view`\nWHERE ext_tag_id IS NOT NULL \n  AND tag_id IS NOT NULL\n  AND ext_tag_id != tag_id  -- This should return 0 rows",
      "dependencies": [
        "transactions_expanded_view"
      ]
    },
    "tenant_field_consistency_check": {
      "name": "tenant_field_consistency_check",
      "filePath": "intent_engine/assertions/tenant_field_consistency.sqlx",
      "type": "table",
      "schema": "dataform_dev_assertions",
      "tags": [
        "intent_engine",
        "data_quality",
        "tenant_validation"
      ],
      "description": "Ensures tenant fields (tenant_id, tenant_client_id) are consistently present or absent across backend and AI offers for the same request_id",
      "config": {
        "type": "table",
        "schema": "dataform_dev_assertions",
        "tags": [
          "intent_engine",
          "data_quality",
          "tenant_validation"
        ],
        "description": "Ensures tenant fields (tenant_id, tenant_client_id) are consistently present or absent across backend and AI offers for the same request_id"
      },
      "sqlContent": "\n\n-- Check for requests where tenant fields are inconsistent between backend and AI offers\n-- Only checks requests that have BOTH backend and AI frontend events\n-- It's OK if both have NULL tenant data or both have tenant data, but not mixed\nWITH request_summary AS (\n  SELECT \n    request_id,\n    -- Check if this request has backend rows\n    MAX(CASE WHEN source_type IS NULL THEN 1 ELSE 0 END) AS has_backend_rows,\n    -- Check if this request has AI frontend events\n    MAX(CASE WHEN source_type = 'ai' THEN 1 ELSE 0 END) AS has_ai_rows,\n    -- Check if backend rows have tenant data\n    MAX(CASE WHEN source_type IS NULL AND (tenant_id IS NOT NULL OR tenant_client_id IS NOT NULL) THEN 1 ELSE 0 END) AS backend_has_tenant,\n    -- Check if AI rows have tenant data\n    MAX(CASE WHEN source_type = 'ai' AND (tenant_id IS NOT NULL OR tenant_client_id IS NOT NULL) THEN 1 ELSE 0 END) AS ai_has_tenant\n  FROM `piedotorg-production.intent_engine_dev.offer_expanded_view`\n  WHERE DATE(ts) >= CURRENT_DATE() - 7 -- Check last 7 days\n  GROUP BY request_id\n),\ninconsistent_requests AS (\n  SELECT \n    request_id,\n    backend_has_tenant,\n    ai_has_tenant,\n    CASE \n      WHEN backend_has_tenant = 1 AND ai_has_tenant = 0 THEN 'Backend has tenant, AI missing'\n      WHEN backend_has_tenant = 0 AND ai_has_tenant = 1 THEN 'AI has tenant, Backend missing'\n    END AS inconsistency_type\n  FROM request_summary\n  WHERE \n    -- Only check requests that have BOTH backend AND AI rows\n    has_backend_rows = 1 AND has_ai_rows = 1\n    -- Flag inconsistency: one has tenant data but the other doesn't\n    AND (\n      (backend_has_tenant = 1 AND ai_has_tenant = 0) \n      OR (backend_has_tenant = 0 AND ai_has_tenant = 1)\n    )\n)\nSELECT \n  request_id,\n  inconsistency_type,\n  backend_has_tenant,\n  ai_has_tenant\nFROM inconsistent_requests\nLIMIT 1 -- Assertion fails if any inconsistent records exist",
      "dependencies": [
        "offer_expanded_view"
      ]
    },
    "check_missing_backend": {
      "name": "check_missing_backend",
      "filePath": "fact_tables/check_missing_backend.sqlx",
      "type": "table",
      "schema": "fact_tables_dev",
      "tags": [],
      "config": {
        "type": "table",
        "schema": "fact_tables_dev",
        "tags": []
      },
      "sqlContent": "",
      "dependencies": [
        "offer_expanded_view"
      ]
    }
  },
  "dependencyGraph": {
    "nodes": [
      {
        "id": "fact_ai_intent_engine",
        "model": {
          "name": "fact_ai_intent_engine",
          "filePath": "fact_tables/fact_ai_intent_engine.sqlx",
          "type": "table",
          "schema": "fact_tables_dev",
          "tags": [
            "fact_tables",
            "intent_engine",
            "ai_offers"
          ],
          "description": "Fact table for AI intent engine frontend events, enriched with campaign/offer data from mapping",
          "config": {
            "type": "table",
            "schema": "fact_tables_dev",
            "tags": [
              "fact_tables",
              "intent_engine",
              "ai_offers"
            ],
            "description": "Fact table for AI intent engine frontend events, enriched with campaign/offer data from mapping",
            "bigquery": {
              "partitionBy": "DATE(event_ts)",
              "clusterBy": [
                "action",
                "campaign_id",
                "merchant_id"
              ]
            }
          },
          "sqlContent": "\n\n-- Fact table for AI Intent Engine frontend events only\nSELECT\n  -- Timestamps\n  TIMESTAMP_MILLIS(ae.timestamp_ms) AS event_ts,\n  m.backend_ts,\n  UNIX_MILLIS(m.backend_ts) AS timestamp_ms,\n  \n  -- Action mapping for funnel\n  CASE\n    WHEN ae.action IN ('show', 'view') THEN 'impression'\n    WHEN ae.action = 'click' THEN 'click'\n    WHEN ae.action = 'close' THEN 'dismissal'\n    ELSE COALESCE(ae.action, 'unknown')\n  END AS action,\n  \n  ae.action AS original_action,\n  \n  -- Core identifiers\n  ae.request_id,\n  ae.offer_id,\n  \n  -- From mapping\n  m.campaign_id,\n  m.merchant_id,\n  m.device_id,\n  \n  -- User identifiers\n  COALESCE(m.user_id, ae.user_id) AS user_id,\n  ae.id AS anonymous_id,\n  \n  -- Source info\n  m.intent_engine_type,\n  'ai' AS source_type,\n  \n  -- Tenant fields\n  ae.tenant_id,\n  ae.tenant_client_id,\n  ae.tenant_rewards_enabled,\n  \n  -- AI-specific fields\n  ae.outbound_url,\n  ae.surface,\n  ae.is_rewards,\n  ae.user_agent,\n  ae.tag_id,\n  \n  -- From mapping\n  m.req_offer,\n  m.top_offer,\n  m.offer_award,\n  m.offer_content,\n  m.offer_cta,\n  m.campaign_boost,\n  m.campaign_active,\n  m.campaign_state,\n  m.campaign_budget,\n  m.offergroup_id,\n  m.offergroup_min_bid,\n  m.offergroup_max_bid,\n  m.offergroup_bid_type\n\nFROM `piedotorg-production.backend_analytics.ai_intent_engine_offer` ae\nLEFT JOIN `piedotorg-production.fact_tables_dev.request_offer_campaign_mapping` m\n  ON ae.request_id = m.request_id\n  AND ae.offer_id = m.offer_id\n  -- Match on tenant_client_id for AI offers\n  AND ae.tenant_client_id = m.tenant_client_id",
          "dependencies": [
            "ai_intent_engine_offer",
            "request_offer_campaign_mapping"
          ]
        }
      },
      {
        "id": "fact_ext_intent_engine_offer",
        "model": {
          "name": "fact_ext_intent_engine_offer",
          "filePath": "fact_tables/fact_ext_intent_engine_offer.sqlx",
          "type": "table",
          "schema": "fact_tables_dev",
          "tags": [
            "fact_tables",
            "intent_engine",
            "ext_offers"
          ],
          "description": "Fact table for extension intent engine frontend events, enriched with campaign/offer data from mapping",
          "config": {
            "type": "table",
            "schema": "fact_tables_dev",
            "tags": [
              "fact_tables",
              "intent_engine",
              "ext_offers"
            ],
            "description": "Fact table for extension intent engine frontend events, enriched with campaign/offer data from mapping",
            "bigquery": {
              "partitionBy": "DATE(event_ts)",
              "clusterBy": [
                "action",
                "campaign_id",
                "merchant_id"
              ]
            }
          },
          "sqlContent": "\n\n-- Fact table for Extension Intent Engine frontend events only\nSELECT\n  -- Timestamps\n  ee.timestamp AS event_ts,\n  m.backend_ts,\n  UNIX_MILLIS(m.backend_ts) AS timestamp_ms,\n  \n  -- Action mapping for funnel\n  CASE\n    WHEN ee.action IN ('show', 'view') THEN 'impression'\n    WHEN ee.action = 'click' THEN 'click'\n    WHEN ee.action = 'close' THEN 'dismissal'\n    ELSE COALESCE(ee.action, 'unknown')\n  END AS action,\n  \n  ee.action AS original_action,\n  \n  -- Core identifiers\n  ee.request_id,\n  ee.offer_id,\n  \n  -- From mapping\n  m.campaign_id,\n  m.merchant_id,\n  m.device_id,\n  \n  -- User identifiers\n  COALESCE(m.user_id, ee.user_id) AS user_id,\n  ee.anonymous_id,\n  \n  -- Source info\n  m.intent_engine_type,\n  'ext' AS source_type,\n  \n  -- Extension-specific fields\n  ee.surface,\n  ee.is_rewards,\n  ee.ext_tag_id,\n  ee.platform,\n  ee.referer_url,\n  \n  -- From mapping\n  m.req_offer,\n  m.top_offer,\n  m.offer_award,\n  m.offer_content,\n  m.offer_cta,\n  m.campaign_boost,\n  m.campaign_active,\n  m.campaign_state,\n  m.campaign_budget,\n  m.offergroup_id,\n  m.offergroup_min_bid,\n  m.offergroup_max_bid,\n  m.offergroup_bid_type,\n  \n  -- Tenant fields from mapping (extension doesn't have its own tenant fields)\n  m.tenant_id,\n  m.tenant_client_id\n\nFROM `piedotorg-production.shopping_extension_production.ext_intent_engine_offer` ee\nLEFT JOIN `piedotorg-production.fact_tables_dev.request_offer_campaign_mapping` m\n  ON ee.request_id = m.request_id\n  AND ee.offer_id = m.offer_id",
          "dependencies": [
            "ext_intent_engine_offer",
            "request_offer_campaign_mapping"
          ]
        }
      },
      {
        "id": "fact_intent_engine_offer_group_match",
        "model": {
          "name": "fact_intent_engine_offer_group_match",
          "filePath": "fact_tables/fact_intent_engine_offer_group_match.sqlx",
          "type": "table",
          "schema": "fact_tables_dev",
          "tags": [
            "fact_tables",
            "backend",
            "intent_engine",
            "offers"
          ],
          "description": "Backend offer matching events enriched with campaign data from mapping table",
          "config": {
            "type": "table",
            "schema": "fact_tables_dev",
            "tags": [
              "fact_tables",
              "backend",
              "intent_engine",
              "offers"
            ],
            "description": "Backend offer matching events enriched with campaign data from mapping table",
            "bigquery": {
              "partitionBy": "DATE(backend_ts)",
              "clusterBy": [
                "campaign_id",
                "merchant_id",
                "request_id"
              ]
            }
          },
          "sqlContent": "\n\n-- Fact table for backend offer matching events\nSELECT\n  -- Timestamps\n  TIMESTAMP_MILLIS(og.timestamp_ms) AS backend_ts,\n  og.timestamp_ms,\n  \n  -- Action\n  'consideration' AS action,\n  \n  -- Request level\n  og.request_id,\n  og.device_id,\n  og.user_id,\n  \n  -- Offer level  \n  og.offer_id,\n  og.offer_content,\n  og.offer_click_url,\n  og.offer_cta,\n  og.offer_award,\n  og.offer_distribution,\n  og.top_offer,\n  \n  -- From mapping\n  m.campaign_id,\n  m.campaign_boost,\n  m.campaign_active,\n  m.campaign_state,\n  m.campaign_budget,\n  \n  -- Merchant level\n  og.merchant_id,\n  \n  -- Offer group level\n  og.offergroup_id,\n  og.offergroup_min_bid,\n  og.offergroup_max_bid,\n  og.offergroup_bid_type,\n  \n  -- Tenant level\n  og.tenant_id,\n  og.tenant_client_id,\n  \n  -- Source info\n  og.intent_engine_type,\n  og.client,\n  \n  -- From mapping\n  m.req_offer,\n  \n  -- Placement fields from mapping\n  m.first_placement_template,\n  m.first_placement_id,\n  m.first_placement_match,\n  m.first_placement_hostname,\n  m.placement_count,\n  \n  -- Search context\n  og.keywords\n\nFROM `piedotorg-production.backend_analytics.intent_engine_offer_group_match` og\nLEFT JOIN `piedotorg-production.fact_tables_dev.request_offer_campaign_mapping` m\n  ON og.request_id = m.request_id\n  AND og.offer_id = m.offer_id",
          "dependencies": [
            "intent_engine_offer_group_match",
            "request_offer_campaign_mapping"
          ]
        }
      },
      {
        "id": "fact_offer_attribution_models",
        "model": {
          "name": "fact_offer_attribution_models",
          "filePath": "fact_tables/fact_offer_attribution_models.sqlx",
          "type": "table",
          "schema": "fact_tables_dev",
          "tags": [
            "fact_tables",
            "attribution",
            "transactions"
          ],
          "description": "Multi-model attribution table with 5 attribution models. Only includes transactions that successfully match at least one attribution model. Creates rows for ALL matching attribution models per transaction.",
          "config": {
            "type": "table",
            "schema": "fact_tables_dev",
            "tags": [
              "fact_tables",
              "attribution",
              "transactions"
            ],
            "description": "Multi-model attribution table with 5 attribution models. Only includes transactions that successfully match at least one attribution model. Creates rows for ALL matching attribution models per transaction.",
            "bigquery": {
              "partitionBy": "DATE(transaction_ts)",
              "clusterBy": [
                "attribution_model",
                "campaign_id",
                "merchant_id"
              ]
            }
          },
          "sqlContent": "\n\n-- Multi-model attribution fact table\n-- Creates one row per transaction per attribution model\nWITH \n-- Base transaction data (AFFILIATE only)\ntransaction_base AS (\n  SELECT\n    DATETIME(created_coalesce_ts) AS transaction_ts,\n    transactionId AS transaction_id,\n    anonymous_id,\n    userId AS user_id,\n    CASE WHEN merchantId = 'logitechg' THEN 'logitech' ELSE merchantId END AS merchant_id,\n    CASE \n      WHEN merchantId = 'verizon' AND IFNULL(externalSaleValue, 0) = 0 \n      THEN externalCommission \n      ELSE externalSaleValue \n    END AS external_sale_value_cents,\n    externalCommission AS external_commission_cents,\n    millipoints,\n    type AS transaction_type,\n    ext_tag_id,\n    campaignId AS direct_campaign_id -- For direct AD_OFFER transactions\n  FROM `piedotorg-production.data_science_dev.transactions_expanded_view`\n  WHERE type = 'AFFILIATE'  -- Only AFFILIATE transactions for attribution\n    AND created_coalesce_ts IS NOT NULL\n    AND merchantId IS NOT NULL\n),\n\n-- Get all click events from enriched int_fe_offer table\nclick_events AS (\n  SELECT\n    event_ts,\n    campaign_id,\n    merchant_id,\n    offer_id,\n    request_id,\n    user_id,\n    anonymous_id,\n    device_id,\n    source_type,\n    intent_engine_type,\n    req_offer,\n    tenant_id,\n    offer_award,\n    offer_content,\n    COALESCE(ext_tag_id, tag_id) AS ext_tag_id,  -- Use ext_tag_id for Extension, tag_id for AI\n    first_placement_template,\n    first_placement_id,\n    first_placement_match,\n    first_placement_hostname,\n    placement_count\n  FROM `piedotorg-production.fact_tables_dev.int_fe_offer`\n  WHERE action = 'click'\n    AND campaign_id IS NOT NULL\n    AND merchant_id IS NOT NULL\n),\n\n-- Get all impression events from enriched int_fe_offer table\nimpression_events AS (\n  SELECT\n    event_ts,\n    campaign_id,\n    merchant_id,\n    offer_id,\n    request_id,\n    user_id,\n    anonymous_id,\n    device_id,\n    source_type,\n    intent_engine_type,\n    req_offer,\n    tenant_id,\n    offer_award,\n    offer_content,\n    COALESCE(ext_tag_id, tag_id) AS ext_tag_id,  -- Use ext_tag_id for Extension, tag_id for AI\n    first_placement_template,\n    first_placement_id,\n    first_placement_match,\n    first_placement_hostname,\n    placement_count\n  FROM `piedotorg-production.fact_tables_dev.int_fe_offer`\n  WHERE action = 'impression'\n    AND campaign_id IS NOT NULL\n    AND merchant_id IS NOT NULL\n),\n\n-- 1. Tag ID Attribution (Deterministic)\ntag_id_attribution AS (\n  SELECT\n    tb.transaction_ts,\n    tb.transaction_id,\n    'tag_id' AS attribution_model,\n    TRUE AS attributed,\n    'deterministic' AS attribution_confidence,\n    \n    -- Transaction details\n    tb.merchant_id,\n    ce.campaign_id,\n    ce.offer_id,\n    ce.request_id,\n    ce.req_offer,\n    \n    -- User identifiers\n    COALESCE(tb.user_id, ce.user_id) AS user_id,\n    COALESCE(tb.anonymous_id, ce.anonymous_id) AS anonymous_id,\n    ce.device_id,\n    \n    -- Transaction metrics\n    tb.transaction_type,\n    tb.external_sale_value_cents / 100 AS external_sale_value_dollars,\n    tb.external_commission_cents / 100 AS external_commission_dollars,\n    tb.millipoints,\n    \n    -- Attribution event details\n    ce.event_ts AS attribution_event_ts,\n    'click' AS attribution_event_action,\n    ce.source_type AS attribution_event_source,\n    NULL AS attribution_window_hours, -- Deterministic, no window\n    DATETIME_DIFF(tb.transaction_ts, DATETIME(ce.event_ts), HOUR) AS time_to_conversion_hours,\n    \n    -- Tag-specific fields\n    tb.ext_tag_id,\n    \n    -- Campaign metadata\n    ce.intent_engine_type,\n    ce.source_type,\n    ce.tenant_id,\n    ce.offer_award,\n    ce.offer_content,\n    \n    -- Placement fields\n    ce.first_placement_template,\n    ce.first_placement_id,\n    ce.first_placement_match,\n    ce.first_placement_hostname,\n    ce.placement_count\n    \n  FROM transaction_base tb\n  INNER JOIN click_events ce\n    ON tb.ext_tag_id = ce.ext_tag_id\n    AND tb.merchant_id = ce.merchant_id\n    AND (\n      -- Primary: match on user_id if both have it\n      (tb.user_id IS NOT NULL AND ce.user_id = tb.user_id)\n      -- Fallback: match on anonymous_id if user_id is NULL\n      OR (tb.user_id IS NULL AND tb.anonymous_id IS NOT NULL AND ce.anonymous_id = tb.anonymous_id)\n    )\n    AND DATETIME(ce.event_ts) <= tb.transaction_ts  -- Click must be before transaction\n  WHERE tb.ext_tag_id IS NOT NULL\n    AND ce.ext_tag_id IS NOT NULL\n),\n\n-- 2. Click 24h Last-Touch Attribution\nclick_24h_attribution AS (\n  SELECT \n    transaction_ts,\n    transaction_id,\n    attribution_model,\n    attributed,\n    attribution_confidence,\n    merchant_id,\n    campaign_id,\n    offer_id,\n    request_id,\n    req_offer,\n    user_id,\n    anonymous_id,\n    device_id,\n    transaction_type,\n    external_sale_value_dollars,\n    external_commission_dollars,\n    millipoints,\n    attribution_event_ts,\n    attribution_event_action,\n    attribution_event_source,\n    attribution_window_hours,\n    time_to_conversion_hours,\n    ext_tag_id,\n    intent_engine_type,\n    source_type,\n    tenant_id,\n    offer_award,\n    offer_content,\n    first_placement_template,\n    first_placement_id,\n    first_placement_match,\n    first_placement_hostname,\n    placement_count\n  FROM (\n    SELECT\n      tb.transaction_ts,\n      tb.transaction_id,\n      'click_24h' AS attribution_model,\n      TRUE AS attributed,\n      'last_touch' AS attribution_confidence,\n      \n      -- Transaction details\n      tb.merchant_id,\n      ce.campaign_id,\n      ce.offer_id,\n      ce.request_id,\n      ce.req_offer,\n      \n      -- User identifiers\n      COALESCE(tb.user_id, ce.user_id) AS user_id,\n      COALESCE(tb.anonymous_id, ce.anonymous_id) AS anonymous_id,\n      ce.device_id,\n      \n      -- Transaction metrics\n      tb.transaction_type,\n      tb.external_sale_value_cents / 100 AS external_sale_value_dollars,\n      tb.external_commission_cents / 100 AS external_commission_dollars,\n      tb.millipoints,\n      \n      -- Attribution event details\n      ce.event_ts AS attribution_event_ts,\n      'click' AS attribution_event_action,\n      ce.source_type AS attribution_event_source,\n      24 AS attribution_window_hours,\n      DATETIME_DIFF(tb.transaction_ts, DATETIME(ce.event_ts), HOUR) AS time_to_conversion_hours,\n      \n      -- Tag-specific fields\n      tb.ext_tag_id,\n      \n      -- Campaign metadata\n      ce.intent_engine_type,\n      ce.source_type,\n      ce.tenant_id,\n      ce.offer_award,\n      ce.offer_content,\n      \n      -- Placement fields\n      ce.first_placement_template,\n      ce.first_placement_id,\n      ce.first_placement_match,\n      ce.first_placement_hostname,\n      ce.placement_count,\n      \n      -- Rank for last-touch logic\n      ROW_NUMBER() OVER (\n        PARTITION BY tb.transaction_id \n        ORDER BY DATETIME(ce.event_ts) DESC\n      ) AS click_rank\n      \n    FROM transaction_base tb\n    INNER JOIN click_events ce\n      ON tb.merchant_id = ce.merchant_id\n      AND (\n        -- Primary: match on user_id if both have it\n        (tb.user_id IS NOT NULL AND ce.user_id = tb.user_id)\n        -- Fallback: match on anonymous_id if user_id is NULL\n        OR (tb.user_id IS NULL AND tb.anonymous_id IS NOT NULL AND ce.anonymous_id = tb.anonymous_id)\n      )\n      AND DATETIME(ce.event_ts) <= tb.transaction_ts\n      AND DATETIME_DIFF(tb.transaction_ts, DATETIME(ce.event_ts), HOUR) <= 24\n  )\n  WHERE click_rank = 1  -- Last touch only\n),\n\n-- 3. Click 7d Last-Touch Attribution  \nclick_7d_attribution AS (\n  SELECT \n    transaction_ts,\n    transaction_id,\n    attribution_model,\n    attributed,\n    attribution_confidence,\n    merchant_id,\n    campaign_id,\n    offer_id,\n    request_id,\n    req_offer,\n    user_id,\n    anonymous_id,\n    device_id,\n    transaction_type,\n    external_sale_value_dollars,\n    external_commission_dollars,\n    millipoints,\n    attribution_event_ts,\n    attribution_event_action,\n    attribution_event_source,\n    attribution_window_hours,\n    time_to_conversion_hours,\n    ext_tag_id,\n    intent_engine_type,\n    source_type,\n    tenant_id,\n    offer_award,\n    offer_content,\n    first_placement_template,\n    first_placement_id,\n    first_placement_match,\n    first_placement_hostname,\n    placement_count\n  FROM (\n    SELECT\n      tb.transaction_ts,\n      tb.transaction_id,\n      'click_7d' AS attribution_model,\n      TRUE AS attributed,\n      'last_touch' AS attribution_confidence,\n      \n      -- Transaction details\n      tb.merchant_id,\n      ce.campaign_id,\n      ce.offer_id,\n      ce.request_id,\n      ce.req_offer,\n      \n      -- User identifiers\n      COALESCE(tb.user_id, ce.user_id) AS user_id,\n      COALESCE(tb.anonymous_id, ce.anonymous_id) AS anonymous_id,\n      ce.device_id,\n      \n      -- Transaction metrics\n      tb.transaction_type,\n      tb.external_sale_value_cents / 100 AS external_sale_value_dollars,\n      tb.external_commission_cents / 100 AS external_commission_dollars,\n      tb.millipoints,\n      \n      -- Attribution event details\n      ce.event_ts AS attribution_event_ts,\n      'click' AS attribution_event_action,\n      ce.source_type AS attribution_event_source,\n      168 AS attribution_window_hours, -- 7 days * 24 hours\n      DATETIME_DIFF(tb.transaction_ts, DATETIME(ce.event_ts), HOUR) AS time_to_conversion_hours,\n      \n      -- Tag-specific fields\n      tb.ext_tag_id,\n      \n      -- Campaign metadata\n      ce.intent_engine_type,\n      ce.source_type,\n      ce.tenant_id,\n      ce.offer_award,\n      ce.offer_content,\n      \n      -- Placement fields\n      ce.first_placement_template,\n      ce.first_placement_id,\n      ce.first_placement_match,\n      ce.first_placement_hostname,\n      ce.placement_count,\n      \n      -- Rank for last-touch logic\n      ROW_NUMBER() OVER (\n        PARTITION BY tb.transaction_id \n        ORDER BY DATETIME(ce.event_ts) DESC\n      ) AS click_rank\n      \n    FROM transaction_base tb\n    INNER JOIN click_events ce\n      ON tb.merchant_id = ce.merchant_id\n      AND (\n        -- Primary: match on user_id if both have it\n        (tb.user_id IS NOT NULL AND ce.user_id = tb.user_id)\n        -- Fallback: match on anonymous_id if user_id is NULL\n        OR (tb.user_id IS NULL AND tb.anonymous_id IS NOT NULL AND ce.anonymous_id = tb.anonymous_id)\n      )\n      AND DATETIME(ce.event_ts) <= tb.transaction_ts\n      AND DATETIME_DIFF(tb.transaction_ts, DATETIME(ce.event_ts), HOUR) <= 168 -- 7 days\n  )\n  WHERE click_rank = 1  -- Last touch only\n),\n\n-- 4. View 24h Last-Touch Attribution (independent of click attribution)\nview_24h_attribution AS (\n  SELECT \n    transaction_ts,\n    transaction_id,\n    attribution_model,\n    attributed,\n    attribution_confidence,\n    merchant_id,\n    campaign_id,\n    offer_id,\n    request_id,\n    req_offer,\n    user_id,\n    anonymous_id,\n    device_id,\n    transaction_type,\n    external_sale_value_dollars,\n    external_commission_dollars,\n    millipoints,\n    attribution_event_ts,\n    attribution_event_action,\n    attribution_event_source,\n    attribution_window_hours,\n    time_to_conversion_hours,\n    ext_tag_id,\n    intent_engine_type,\n    source_type,\n    tenant_id,\n    offer_award,\n    offer_content,\n    first_placement_template,\n    first_placement_id,\n    first_placement_match,\n    first_placement_hostname,\n    placement_count\n  FROM (\n    SELECT\n      tb.transaction_ts,\n      tb.transaction_id,\n      'view_24h' AS attribution_model,\n      TRUE AS attributed,\n      'view_assist' AS attribution_confidence,\n      \n      -- Transaction details\n      tb.merchant_id,\n      ie.campaign_id,\n      ie.offer_id,\n      ie.request_id,\n      ie.req_offer,\n      \n      -- User identifiers\n      COALESCE(tb.user_id, ie.user_id) AS user_id,\n      COALESCE(tb.anonymous_id, ie.anonymous_id) AS anonymous_id,\n      ie.device_id,\n      \n      -- Transaction metrics\n      tb.transaction_type,\n      tb.external_sale_value_cents / 100 AS external_sale_value_dollars,\n      tb.external_commission_cents / 100 AS external_commission_dollars,\n      tb.millipoints,\n      \n      -- Attribution event details\n      ie.event_ts AS attribution_event_ts,\n      'impression' AS attribution_event_action,\n      ie.source_type AS attribution_event_source,\n      24 AS attribution_window_hours,\n      DATETIME_DIFF(tb.transaction_ts, DATETIME(ie.event_ts), HOUR) AS time_to_conversion_hours,\n      \n      -- Tag-specific fields\n      tb.ext_tag_id,\n      \n      -- Campaign metadata\n      ie.intent_engine_type,\n      ie.source_type,\n      ie.tenant_id,\n      ie.offer_award,\n      ie.offer_content,\n      \n      -- Placement fields\n      ie.first_placement_template,\n      ie.first_placement_id,\n      ie.first_placement_match,\n      ie.first_placement_hostname,\n      ie.placement_count,\n      \n      -- Rank for last-touch logic\n      ROW_NUMBER() OVER (\n        PARTITION BY tb.transaction_id \n        ORDER BY DATETIME(ie.event_ts) DESC\n      ) AS impression_rank\n      \n    FROM transaction_base tb\n    INNER JOIN impression_events ie\n      ON tb.merchant_id = ie.merchant_id\n      AND (\n        -- Primary: match on user_id if both have it\n        (tb.user_id IS NOT NULL AND ie.user_id = tb.user_id)\n        -- Fallback: match on anonymous_id if user_id is NULL\n        OR (tb.user_id IS NULL AND tb.anonymous_id IS NOT NULL AND ie.anonymous_id = tb.anonymous_id)\n      )\n      AND DATETIME(ie.event_ts) <= tb.transaction_ts\n      AND DATETIME_DIFF(tb.transaction_ts, DATETIME(ie.event_ts), HOUR) <= 24\n  )\n  WHERE impression_rank = 1  -- Last touch only\n),\n\n-- 5. View 7d Last-Touch Attribution (independent of click attribution)\nview_7d_attribution AS (\n  SELECT \n    transaction_ts,\n    transaction_id,\n    attribution_model,\n    attributed,\n    attribution_confidence,\n    merchant_id,\n    campaign_id,\n    offer_id,\n    request_id,\n    req_offer,\n    user_id,\n    anonymous_id,\n    device_id,\n    transaction_type,\n    external_sale_value_dollars,\n    external_commission_dollars,\n    millipoints,\n    attribution_event_ts,\n    attribution_event_action,\n    attribution_event_source,\n    attribution_window_hours,\n    time_to_conversion_hours,\n    ext_tag_id,\n    intent_engine_type,\n    source_type,\n    tenant_id,\n    offer_award,\n    offer_content,\n    first_placement_template,\n    first_placement_id,\n    first_placement_match,\n    first_placement_hostname,\n    placement_count\n  FROM (\n    SELECT\n      tb.transaction_ts,\n      tb.transaction_id,\n      'view_7d' AS attribution_model,\n      TRUE AS attributed,\n      'view_assist' AS attribution_confidence,\n      \n      -- Transaction details\n      tb.merchant_id,\n      ie.campaign_id,\n      ie.offer_id,\n      ie.request_id,\n      ie.req_offer,\n      \n      -- User identifiers\n      COALESCE(tb.user_id, ie.user_id) AS user_id,\n      COALESCE(tb.anonymous_id, ie.anonymous_id) AS anonymous_id,\n      ie.device_id,\n      \n      -- Transaction metrics\n      tb.transaction_type,\n      tb.external_sale_value_cents / 100 AS external_sale_value_dollars,\n      tb.external_commission_cents / 100 AS external_commission_dollars,\n      tb.millipoints,\n      \n      -- Attribution event details\n      ie.event_ts AS attribution_event_ts,\n      'impression' AS attribution_event_action,\n      ie.source_type AS attribution_event_source,\n      168 AS attribution_window_hours, -- 7 days * 24 hours\n      DATETIME_DIFF(tb.transaction_ts, DATETIME(ie.event_ts), HOUR) AS time_to_conversion_hours,\n      \n      -- Tag-specific fields\n      tb.ext_tag_id,\n      \n      -- Campaign metadata\n      ie.intent_engine_type,\n      ie.source_type,\n      ie.tenant_id,\n      ie.offer_award,\n      ie.offer_content,\n      \n      -- Placement fields\n      ie.first_placement_template,\n      ie.first_placement_id,\n      ie.first_placement_match,\n      ie.first_placement_hostname,\n      ie.placement_count,\n      \n      -- Rank for last-touch logic\n      ROW_NUMBER() OVER (\n        PARTITION BY tb.transaction_id \n        ORDER BY DATETIME(ie.event_ts) DESC\n      ) AS impression_rank\n      \n    FROM transaction_base tb\n    INNER JOIN impression_events ie\n      ON tb.merchant_id = ie.merchant_id\n      AND (\n        -- Primary: match on user_id if both have it\n        (tb.user_id IS NOT NULL AND ie.user_id = tb.user_id)\n        -- Fallback: match on anonymous_id if user_id is NULL\n        OR (tb.user_id IS NULL AND tb.anonymous_id IS NOT NULL AND ie.anonymous_id = tb.anonymous_id)\n      )\n      AND DATETIME(ie.event_ts) <= tb.transaction_ts\n      AND DATETIME_DIFF(tb.transaction_ts, DATETIME(ie.event_ts), HOUR) <= 168 -- 7 days\n  )\n  WHERE impression_rank = 1  -- Last touch only\n)\n\n-- Union all attribution models (only attributed transactions)\nSELECT * FROM tag_id_attribution\nUNION ALL\nSELECT * FROM click_24h_attribution\nUNION ALL  \nSELECT * FROM click_7d_attribution\nUNION ALL\nSELECT * FROM view_24h_attribution\nUNION ALL\nSELECT * FROM view_7d_attribution",
          "dependencies": [
            "transactions_expanded_view",
            "int_fe_offer"
          ]
        }
      },
      {
        "id": "fact_web_intent_engine_offer",
        "model": {
          "name": "fact_web_intent_engine_offer",
          "filePath": "fact_tables/fact_web_intent_engine_offer.sqlx",
          "type": "table",
          "schema": "fact_tables_dev",
          "tags": [
            "fact_tables",
            "intent_engine",
            "web_offers"
          ],
          "description": "Fact table for web intent engine frontend events, enriched with campaign/offer data from mapping",
          "config": {
            "type": "table",
            "schema": "fact_tables_dev",
            "tags": [
              "fact_tables",
              "intent_engine",
              "web_offers"
            ],
            "description": "Fact table for web intent engine frontend events, enriched with campaign/offer data from mapping",
            "bigquery": {
              "partitionBy": "DATE(event_ts)",
              "clusterBy": [
                "action",
                "campaign_id",
                "merchant_id"
              ]
            }
          },
          "sqlContent": "\n\n-- Fact table for Web Intent Engine frontend events only\nSELECT\n  -- Timestamps\n  we.timestamp AS event_ts,\n  m.backend_ts,\n  UNIX_MILLIS(m.backend_ts) AS timestamp_ms,\n  \n  -- Action mapping for funnel\n  CASE\n    WHEN we.action IN ('show', 'view') THEN 'impression'\n    WHEN we.action = 'click' THEN 'click'\n    WHEN we.action = 'close' THEN 'dismissal'\n    ELSE COALESCE(we.action, 'unknown')\n  END AS action,\n  \n  we.action AS original_action,\n  \n  -- Core identifiers\n  we.request_id,\n  we.offer_id,\n  \n  -- From mapping\n  m.campaign_id,\n  m.merchant_id,\n  m.device_id,\n  \n  -- User identifiers\n  COALESCE(m.user_id, we.user_id) AS user_id,\n  we.anonymous_id,\n  \n  -- Source info\n  m.intent_engine_type,\n  'web' AS source_type,\n  \n  -- Web-specific fields\n  we.surface,\n  we.is_rewards,\n  we.context_locale,\n  we.context_device_type,\n  \n  -- From mapping\n  m.req_offer,\n  m.top_offer,\n  m.offer_award,\n  m.offer_content,\n  m.offer_cta,\n  m.campaign_boost,\n  m.campaign_active,\n  m.campaign_state,\n  m.campaign_budget,\n  m.offergroup_id,\n  m.offergroup_min_bid,\n  m.offergroup_max_bid,\n  m.offergroup_bid_type,\n  \n  -- Tenant fields from mapping (web doesn't have its own tenant fields)\n  m.tenant_id,\n  m.tenant_client_id\n\nFROM `piedotorg-production.website_production.web_intent_engine_offer` we\nLEFT JOIN `piedotorg-production.fact_tables_dev.request_offer_campaign_mapping` m\n  ON we.request_id = m.request_id\n  AND we.offer_id = m.offer_id",
          "dependencies": [
            "web_intent_engine_offer",
            "request_offer_campaign_mapping"
          ]
        }
      },
      {
        "id": "int_fe_offer",
        "model": {
          "name": "int_fe_offer",
          "filePath": "fact_tables/int_fe_offer.sqlx",
          "type": "table",
          "schema": "fact_tables_dev",
          "tags": [
            "fact_tables",
            "frontend_offers",
            "enriched"
          ],
          "description": "Intermediate table that unions all frontend offer events (AI, Extension, Web) with backend mapping data. Single source of truth for enriched frontend events with campaign/offer metadata.",
          "config": {
            "type": "table",
            "schema": "fact_tables_dev",
            "tags": [
              "fact_tables",
              "frontend_offers",
              "enriched"
            ],
            "description": "Intermediate table that unions all frontend offer events (AI, Extension, Web) with backend mapping data. Single source of truth for enriched frontend events with campaign/offer metadata.",
            "bigquery": {
              "partitionBy": "DATE(event_ts)",
              "clusterBy": [
                "source_type",
                "action",
                "campaign_id",
                "merchant_id"
              ]
            }
          },
          "sqlContent": "\n\n-- Unified frontend offer events with backend mapping enrichment\n-- Combines all frontend sources (AI, Extension, Web) with request_offer_campaign_mapping\nWITH unified_frontend AS (\n  -- AI events\n  SELECT\n    request_id,\n    offer_id,\n    TIMESTAMP_MILLIS(timestamp_ms) AS event_ts,\n    CASE\n      WHEN action IN ('show', 'view') THEN 'impression'\n      WHEN action = 'click' THEN 'click'\n      WHEN action = 'close' THEN 'dismissal'\n      ELSE COALESCE(action, 'unknown')\n    END AS action,\n    action AS original_action,\n    user_id,\n    id AS anonymous_id,\n    'ai' AS source_type,\n    surface,\n    is_rewards,\n    outbound_url,\n    user_agent,\n    tag_id,\n    NULL AS ext_tag_id,\n    tenant_id,\n    tenant_client_id,\n    tenant_rewards_enabled,\n    NULL AS platform,\n    NULL AS referer_url,\n    NULL AS context_locale,\n    NULL AS context_device_type,\n    NULL AS context_app_name,\n    NULL AS context_app_version,\n    NULL AS context_browser,\n    NULL AS context_browser_version,\n    NULL AS context_device_id,\n    NULL AS context_id,\n    NULL AS context_ip,\n    NULL AS context_library_name,\n    NULL AS context_library_version,\n    NULL AS context_os_os,\n    NULL AS context_os_version,\n    NULL AS context_os_name,\n    NULL AS context_time_zone,\n    NULL AS event,\n    NULL AS event_text,\n    NULL AS loaded_at,\n    NULL AS original_timestamp,\n    NULL AS received_at,\n    NULL AS sent_at,\n    NULL AS uuid_ts\n  FROM `piedotorg-production.backend_analytics.ai_intent_engine_offer`\n  \n  UNION ALL\n  \n  -- Extension events\n  SELECT\n    request_id,\n    offer_id,\n    timestamp AS event_ts,\n    CASE\n      WHEN action IN ('show', 'view') THEN 'impression'\n      WHEN action = 'click' THEN 'click'\n      WHEN action = 'close' THEN 'dismissal'\n      ELSE COALESCE(action, 'unknown')\n    END AS action,\n    action AS original_action,\n    user_id,\n    anonymous_id,\n    'ext' AS source_type,\n    surface,\n    is_rewards,\n    NULL AS outbound_url,\n    context_user_agent AS user_agent,\n    NULL AS tag_id,\n    ext_tag_id,\n    NULL AS tenant_id,\n    NULL AS tenant_client_id,\n    NULL AS tenant_rewards_enabled,\n    platform,\n    referer_url,\n    context_locale,\n    context_device_type,\n    context_app_name,\n    context_app_version,\n    context_browser,\n    context_browser_version,\n    context_device_id,\n    context_id,\n    context_ip,\n    context_library_name,\n    context_library_version,\n    context_os_os,\n    context_os_version,\n    context_os_name,\n    context_time_zone,\n    event,\n    event_text,\n    loaded_at,\n    original_timestamp,\n    received_at,\n    sent_at,\n    uuid_ts\n  FROM `piedotorg-production.shopping_extension_production.ext_intent_engine_offer`\n  \n  UNION ALL\n  \n  -- Web events\n  SELECT\n    request_id,\n    offer_id,\n    timestamp AS event_ts,\n    CASE\n      WHEN action IN ('show', 'view') THEN 'impression'\n      WHEN action = 'click' THEN 'click'\n      WHEN action = 'close' THEN 'dismissal'\n      ELSE COALESCE(action, 'unknown')\n    END AS action,\n    action AS original_action,\n    user_id,\n    anonymous_id,\n    'web' AS source_type,\n    surface,\n    is_rewards,\n    NULL AS outbound_url,\n    context_user_agent AS user_agent,\n    NULL AS tag_id,\n    NULL AS ext_tag_id,\n    NULL AS tenant_id,\n    NULL AS tenant_client_id,\n    NULL AS tenant_rewards_enabled,\n    NULL AS platform,\n    NULL AS referer_url,\n    context_locale,\n    context_device_type,\n    NULL AS context_app_name,\n    NULL AS context_app_version,\n    NULL AS context_browser,\n    NULL AS context_browser_version,\n    NULL AS context_device_id,\n    NULL AS context_id,\n    NULL AS context_ip,\n    NULL AS context_library_name,\n    NULL AS context_library_version,\n    NULL AS context_os_os,\n    NULL AS context_os_version,\n    NULL AS context_os_name,\n    context_timezone AS context_time_zone,\n    event,\n    event_text,\n    loaded_at,\n    original_timestamp,\n    received_at,\n    sent_at,\n    uuid_ts\n  FROM `piedotorg-production.website_production.web_intent_engine_offer`\n)\n\n-- Join frontend events with backend mapping data\nSELECT\n  -- Core identifiers\n  fe.request_id,\n  fe.offer_id,\n  \n  -- Timestamps\n  fe.event_ts,\n  m.backend_ts,\n  UNIX_MILLIS(m.backend_ts) AS timestamp_ms,\n  \n  -- Actions\n  fe.action,\n  fe.original_action,\n  \n  -- User identifiers\n  COALESCE(m.user_id, fe.user_id) AS user_id,\n  fe.anonymous_id,\n  m.device_id,\n  \n  -- Source identification\n  fe.source_type,\n  m.intent_engine_type,\n  fe.surface,\n  fe.is_rewards,\n  \n  -- Campaign/Offer metadata from mapping\n  m.campaign_id,\n  m.merchant_id,\n  m.req_offer,\n  m.top_offer,\n  m.offer_award,\n  m.offer_content,\n  m.offer_cta,\n  m.campaign_boost,\n  m.campaign_active,\n  m.campaign_state,\n  m.campaign_budget,\n  m.offergroup_id,\n  m.offergroup_min_bid,\n  m.offergroup_max_bid,\n  m.offergroup_bid_type,\n  \n  -- Placement fields from mapping\n  m.first_placement_template,\n  m.first_placement_id,\n  m.first_placement_match,\n  m.first_placement_hostname,\n  m.placement_count,\n  \n  -- Search context from mapping\n  m.keywords,\n  \n  -- Source-specific fields from frontend\n  fe.outbound_url,\n  fe.user_agent,\n  fe.tag_id,\n  fe.ext_tag_id,\n  COALESCE(fe.tenant_id, m.tenant_id) AS tenant_id,\n  COALESCE(fe.tenant_client_id, m.tenant_client_id) AS tenant_client_id,\n  fe.tenant_rewards_enabled,\n  fe.platform,\n  fe.referer_url,\n  fe.context_locale,\n  fe.context_device_type,\n  \n  -- Context fields from frontend\n  fe.context_app_name,\n  fe.context_app_version,\n  fe.context_browser,\n  fe.context_browser_version,\n  fe.context_device_id,\n  fe.context_id,\n  fe.context_ip,\n  fe.context_library_name,\n  fe.context_library_version,\n  fe.context_os_os,\n  fe.context_os_version,\n  fe.context_os_name,\n  fe.context_time_zone,\n  fe.event,\n  fe.event_text,\n  fe.loaded_at,\n  fe.original_timestamp,\n  fe.received_at,\n  fe.sent_at,\n  fe.uuid_ts\n\nFROM unified_frontend fe\nLEFT JOIN `piedotorg-production.fact_tables_dev.request_offer_campaign_mapping` m\n  ON fe.request_id = m.request_id\n  AND fe.offer_id = m.offer_id\n  -- Special matching for AI offers using tenant_client_id (handle NULL values)\n  AND (fe.source_type != 'ai' OR COALESCE(fe.tenant_client_id, '') = COALESCE(m.tenant_client_id, ''))",
          "dependencies": [
            "ai_intent_engine_offer",
            "ext_intent_engine_offer",
            "web_intent_engine_offer",
            "request_offer_campaign_mapping"
          ]
        }
      },
      {
        "id": "request_offer_campaign_mapping",
        "model": {
          "name": "request_offer_campaign_mapping",
          "filePath": "fact_tables/request_offer_campaign_mapping.sqlx",
          "type": "table",
          "schema": "fact_tables_dev",
          "tags": [
            "fact_tables",
            "mapping",
            "intent_engine"
          ],
          "description": "Mapping table that joins backend offer data with campaign and tenant information. Provides a clean reference for request-offer-campaign relationships without event duplication.",
          "config": {
            "type": "table",
            "schema": "fact_tables_dev",
            "tags": [
              "fact_tables",
              "mapping",
              "intent_engine"
            ],
            "description": "Mapping table that joins backend offer data with campaign and tenant information. Provides a clean reference for request-offer-campaign relationships without event duplication.",
            "bigquery": {
              "partitionBy": "DATE(backend_ts)",
              "clusterBy": [
                "campaign_id",
                "merchant_id",
                "offer_id"
              ]
            }
          },
          "sqlContent": "\n\n-- Request-Offer-Campaign mapping table\n-- This provides a clean reference without event duplication\nWITH backend_offers AS (\n  SELECT DISTINCT\n    -- Request level\n    request_id,\n    TIMESTAMP_MILLIS(timestamp_ms) AS backend_ts,\n    device_id,\n    user_id,\n    placement_hashes,\n    \n    -- Offer level  \n    offer_id,\n    offer_content,\n    offer_click_url,\n    offer_cta,\n    offer_award,\n    offer_distribution,\n    top_offer,\n    \n    -- Campaign level (from backend)\n    campaign_id,\n    campaign_boost,\n    \n    -- Merchant level\n    merchant_id,\n    \n    -- Offer group level\n    offergroup_id,\n    offergroup_min_bid,\n    offergroup_max_bid,\n    offergroup_bid_type,\n    \n    -- Tenant level\n    tenant_id,\n    tenant_client_id,\n    \n    -- Source info\n    intent_engine_type,\n    client,\n    \n    -- Search context\n    keywords,\n    \n    -- Composite key\n    CONCAT(request_id, '|', offer_id) AS req_offer\n    \n  FROM `piedotorg-production.backend_analytics.intent_engine_offer_group_match`\n  WHERE request_id IS NOT NULL\n    AND offer_id IS NOT NULL\n),\n\n-- Get placement data\nplacement_data AS (\n  SELECT DISTINCT\n    placementHash,\n    template,\n    placementId,\n    match,\n    hostname,\n    offerGroupId\n  FROM `piedotorg-production.analytics_etl.campaigns_placements`\n),\n\n-- Get campaign metadata\ncampaign_data AS (\n  SELECT \n    campaignId,\n    merchantId,\n    budget,\n    TIMESTAMP_MILLIS(created) AS campaign_created_ts,\n    COALESCE(TIMESTAMP_MILLIS(updated), TIMESTAMP_MILLIS(created)) AS campaign_updated_ts,\n    CASE \n      WHEN endDate IS NOT NULL THEN TIMESTAMP_MILLIS(endDate)\n      WHEN state IN ('PAUSED', 'ENDED', 'CANCELLED', 'ARCHIVED') THEN COALESCE(TIMESTAMP_MILLIS(updated), TIMESTAMP_MILLIS(created))\n      ELSE NULL \n    END AS campaign_ended_ts,\n    CASE WHEN state = 'ACTIVE' THEN true ELSE false END AS campaign_active,\n    state AS campaign_state,\n    CASE WHEN startDate IS NOT NULL THEN TIMESTAMP_MILLIS(startDate) ELSE TIMESTAMP_MILLIS(created) END AS campaign_start_ts\n  FROM `piedotorg-production.analytics_etl.campaigns_campaigns`\n)\n\nSELECT\n  -- Request level\n  bo.request_id,\n  bo.backend_ts,\n  bo.device_id,\n  bo.user_id,\n  bo.placement_hashes,\n  \n  -- Offer level\n  bo.offer_id,\n  bo.offer_content,\n  bo.offer_click_url,\n  bo.offer_cta,\n  bo.offer_award,\n  bo.offer_distribution,\n  bo.top_offer,\n  \n  -- Campaign level (merged)\n  bo.campaign_id,\n  bo.campaign_boost,\n  cd.campaign_active,\n  cd.campaign_state,\n  cd.budget AS campaign_budget,\n  cd.campaign_created_ts,\n  cd.campaign_updated_ts,\n  cd.campaign_ended_ts,\n  cd.campaign_start_ts,\n  \n  -- Merchant level\n  bo.merchant_id,\n  \n  -- Offer group level\n  bo.offergroup_id,\n  bo.offergroup_min_bid,\n  bo.offergroup_max_bid,\n  bo.offergroup_bid_type,\n  \n  -- Tenant level\n  bo.tenant_id,\n  bo.tenant_client_id,\n  \n  -- Source info\n  bo.intent_engine_type,\n  bo.client,\n  \n  -- Composite key\n  bo.req_offer,\n  \n  -- Placement fields (from first matching placement)\n  pd.template AS first_placement_template,\n  pd.placementId AS first_placement_id,\n  pd.match AS first_placement_match,\n  pd.hostname AS first_placement_hostname,\n  ARRAY_LENGTH(bo.placement_hashes) AS placement_count,\n  \n  -- Search context\n  bo.keywords\n\nFROM backend_offers bo\nLEFT JOIN campaign_data cd\n  ON bo.campaign_id = cd.campaignId\n  AND bo.merchant_id = cd.merchantId\n  -- Only join campaigns that were active during the offer\n  AND DATE(bo.backend_ts) >= DATE(cd.campaign_start_ts)\n--  AND (cd.campaign_ended_ts IS NULL OR DATE(bo.backend_ts) <= DATE(cd.campaign_ended_ts))\nLEFT JOIN placement_data pd\n  ON pd.placementHash = bo.placement_hashes[SAFE_OFFSET(0)]  -- Join on first placement hash\n  AND pd.offerGroupId = bo.offergroup_id",
          "dependencies": [
            "intent_engine_offer_group_match",
            "campaigns_placements",
            "campaigns_campaigns"
          ]
        }
      },
      {
        "id": "all_campaigns",
        "model": {
          "name": "all_campaigns",
          "filePath": "growth/all_campaigns.sqlx",
          "type": "table",
          "schema": "growth_marketing",
          "tags": [
            "growth",
            "campaigns",
            "daily",
            "marketing"
          ],
          "description": "Consolidated campaign data from all marketing channels including paid campaigns, influencer spend, and manual CPM data",
          "config": {
            "type": "table",
            "schema": "growth_marketing",
            "tags": [
              "growth",
              "campaigns",
              "daily",
              "marketing"
            ],
            "description": "Consolidated campaign data from all marketing channels including paid campaigns, influencer spend, and manual CPM data",
            "bigquery": {
              "partitionBy": "date",
              "clusterBy": [
                "source",
                "placement",
                "puci"
              ]
            }
          },
          "sqlContent": "\n\nWITH\n  \n  influencer_data AS (\n    SELECT\n      influencer_name,\n      vanity_url,\n      puci,\n      cost,\n      SAFE_CAST(start_date AS DATE) start_date,\n      amortize_days\n    FROM `piedotorg-production.growth_marketing.dpr_manual_spend`\n  ),\n  \n  publisher_cpms AS (\n    SELECT \n      NET.REG_DOMAIN(website) AS domain,\n      concept,\n      puci,\n      cpm,\n      SAFE_CAST(start_date AS DATE) start_date,\n      SAFE_CAST(end_date AS DATE) end_date\n    FROM `piedotorg-production.growth_marketing.dpr_manual_publisher_cpms`\n    where puci is not null\n  ),\n  \n  expanded_data AS (\n    SELECT\n      influencer_name,\n      vanity_url,\n      puci,\n      cost,\n      amortize_days,\n      DATE_ADD(start_date, INTERVAL day_offset DAY) AS date,\n      cost / amortize_days AS daily_cost\n    FROM\n      influencer_data,\n      UNNEST(GENERATE_ARRAY(0, amortize_days - 1)) AS day_offset\n  ),\n  \n  influencer_daily AS (\n    SELECT\n      date,\n      'infl' AS source,\n      influencer_name AS campaign_name,\n      puci,\n      CAST(NULL AS STRING) AS ad_set_name,\n      NULL AS impressions,\n      NULL AS clicks,\n      daily_cost AS cost,\n      NULL AS conversions_app_installs,\n      NULL AS conversions_ext_installs\n    FROM expanded_data\n  ),\n  \n  apple_campaigns AS (\n    SELECT\n      date,\n      'apple' AS source,\n      campaign_name,\n      puci,\n      CAST(NULL AS STRING) AS ad_set_name,\n      impressions,\n      clicks,\n      cost,\n      conversions_app_installs,\n      NULL AS conversions_ext_installs\n    FROM `piedotorg-production.growth_marketing.apple_search_campaign_funnel`\n  ),\n  \n  google_campaigns AS (\n    SELECT\n      date,\n      'google' AS source,\n      campaign_name,\n      -- temp hack to get pmax\n      IF(SPLIT(campaign_name, '_')[SAFE_OFFSET(3)] IN (\"pmax\", \"pmax-desktop\", \"pmax-mobile\"), \n         campaign_name, puci) AS puci,\n      CAST(NULL AS STRING) AS ad_set_name,\n      impressions,\n      clicks,\n      cost,\n      NULL AS conversions_app_installs,\n      conversions_ext_installs\n    FROM `piedotorg-production.growth_marketing.google_campaign_funnel`\n  ),\n  \n  msft_campaigns AS (\n    SELECT\n      date,\n      'microsoft' AS source,\n      campaign_name,\n      ad_group_name AS puci,\n      ad_group_name AS ad_set_name,\n      impressions,\n      clicks,\n      cost,\n      NULL AS conversions_app_installs,\n      conversions AS conversions_ext_installs\n    FROM `piedotorg-production.growth_marketing.msft_campaign_funnel`\n  ),\n  \n  amazon_campaigns AS (\n    SELECT\n      date,\n      'amazon_dsp' AS source,\n      campaign_name,\n      ad_name AS puci,\n      ad_group_name AS ad_set_name,\n      impressions,\n      clicks,\n      cost,\n      NULL AS conversions_app_installs,\n      conversions AS conversions_ext_installs\n    FROM `piedotorg-production.growth_marketing.amazon_dsp_campaign_funnel`\n  ),\n  \n  meta_campaigns AS (\n    SELECT\n      date,\n      'meta' AS source,\n      campaign_name,\n      puci,\n      ad_set_name,\n      impressions,\n      clicks,\n      costs AS cost,\n      NULL AS conversions_app_installs,\n      NULL AS conversions_ext_installs\n    FROM `piedotorg-production.growth_marketing.meta_campaign_funnel`\n  ),\n  \n  tik_tok_campaigns AS (\n    SELECT\n      date,\n      'tiktok' AS source,\n      campaign_name,\n      puci,\n      ad_group_name AS ad_set_name,\n      impressions,\n      clicks,\n      cost,\n      conversions_app_installs,\n      NULL AS conversions_ext_installs\n    FROM `piedotorg-production.growth_marketing.tiktok_ads_campaign_funnel`\n  ),\n  \n  bizdev AS (\n    SELECT\n      date,\n      'bizdev_manual' AS source,\n      CAST(NULL AS STRING) AS campaign_name,\n      puci,\n      CAST(NULL AS STRING) AS ad_set_name,\n      NULL AS impressions,\n      NULL AS clicks,\n      SUM(payout_total) AS cost,\n      NULL AS conversions_app_installs,\n      NULL AS conversions_ext_installs\n    FROM `piedotorg-production.growth_marketing_dev.bizdev_spend`\n    WHERE cpi > 0  -- Only include countries with actual CPI rates for cost calculations\n    GROUP BY date, puci\n  ),\n  \n  impression_cost AS (\n    -- Step 1: count events per pixel and cap at 2\n    WITH pixel_daily AS (\n      SELECT\n        DATE(TIMESTAMP_MILLIS(timestamp), 'America/Los_Angeles') AS date,\n        NET.REG_DOMAIN(url) AS domain,\n        pixel_id,\n        COUNT(*) AS ev_count\n      FROM `piedotorg-production.backend_analytics.pixel`\n      WHERE source = 'wall_view'\n      GROUP BY date, domain, pixel_id\n    )\n    -- Step 2: sum the capped impressions per day/domain\n    SELECT\n      a.date,\n      'manual_cpms' AS source,\n      CAST(NULL AS STRING) AS campaign_name,\n      publisher_cpms.puci,\n      CAST(NULL AS STRING) AS ad_set_name,\n      a.pxid_impressions AS impressions,\n      NULL AS clicks,\n      a.pxid_impressions *\n        IF((a.date BETWEEN publisher_cpms.start_date AND publisher_cpms.end_date)\n           OR (a.date >= publisher_cpms.start_date AND publisher_cpms.end_date IS NULL),\n           publisher_cpms.cpm, 0) / 1000 AS cost,\n      NULL AS conversions_app_installs,\n      NULL AS conversions_ext_installs\n    FROM (\n      SELECT\n        date,\n        domain,\n        SUM(LEAST(ev_count, 2)) AS pxid_impressions\n      FROM pixel_daily\n      GROUP BY date, domain\n    ) AS a\n    LEFT JOIN publisher_cpms ON a.domain = publisher_cpms.domain\n    WHERE publisher_cpms.puci IS NOT NULL\n  ),\n  \n  -- Combine all campaign sources\n  all_campaigns_union AS (\n    SELECT * FROM apple_campaigns\n    UNION ALL\n    SELECT * FROM google_campaigns\n    UNION ALL\n    SELECT * FROM amazon_campaigns\n    UNION ALL\n    SELECT * FROM meta_campaigns\n    UNION ALL\n    SELECT * FROM tik_tok_campaigns\n    UNION ALL\n    SELECT * FROM influencer_daily\n    UNION ALL\n    SELECT * FROM bizdev\n    UNION ALL\n    SELECT * FROM msft_campaigns \n    UNION ALL\n    SELECT * FROM impression_cost\n  ),\n  \n  -- Add PUCI parsing and aggregation to prevent duplicates\n  final AS (\n    SELECT\n      date,\n      source,\n      campaign_name,\n      puci,\n      ad_set_name,\n      SUM(impressions) AS impressions,\n      SUM(clicks) AS clicks,\n      SUM(cost) AS cost,\n      SUM(conversions_app_installs) AS conversions_app_installs,\n      SUM(conversions_ext_installs) AS conversions_ext_installs,\n      SPLIT(puci, '_')[SAFE_OFFSET(2)] AS puci_geo,\n      SPLIT(puci, '_')[SAFE_OFFSET(3)] AS placement,\n      `piedotorg-production.data_science.TopN`(puci, '_', 16) AS puci_16,\n      `piedotorg-production.data_science.TopN`(puci, '_', 8) AS puci_8\n    FROM all_campaigns_union\n    GROUP BY date, source, campaign_name, puci, ad_set_name, puci_geo, placement, puci_16, puci_8\n  )\n\nSELECT\n  final.*,\n  mapping.platform,\n  mapping.media_source,\n  mapping.spend_type,\n  mapping.funnel,\n  mapping.device_target\nFROM final\nLEFT JOIN `piedotorg-production.growth_marketing.dpr_manual_mapping` mapping\n  USING (placement)",
          "dependencies": [
            "dpr_manual_spend",
            "dpr_manual_publisher_cpms",
            "apple_search_campaign_funnel",
            "google_campaign_funnel",
            "msft_campaign_funnel",
            "amazon_dsp_campaign_funnel",
            "meta_campaign_funnel",
            "tiktok_ads_campaign_funnel",
            "bizdev_spend",
            "dpr_manual_mapping"
          ]
        }
      },
      {
        "id": "bizdev_spend",
        "model": {
          "name": "bizdev_spend",
          "filePath": "growth/bizdev_spend.sqlx",
          "type": "table",
          "schema": "growth_marketing_dev",
          "tags": [
            "growth",
            "bizdev",
            "daily"
          ],
          "description": "Business development spend calculations based on CPI rates and extension install data",
          "config": {
            "type": "table",
            "schema": "growth_marketing_dev",
            "tags": [
              "growth",
              "bizdev",
              "daily"
            ],
            "description": "Business development spend calculations based on CPI rates and extension install data",
            "bigquery": {
              "partitionBy": "date",
              "clusterBy": [
                "puci",
                "placement",
                "product"
              ]
            }
          },
          "sqlContent": "\n\nWITH\n  cpi_manual AS (\n    SELECT\n      geo,\n      placement,\n      puci,\n      cpi, \n      CAST(start_date AS DATE) start_date,\n      ifnull(CAST(end_date AS DATE), current_date(\"America/Los_Angeles\")) end_date\n    FROM\n      `piedotorg-production.growth_marketing.dpr_manual_external`\n  ),\n  \n  adblock_installs AS (\n    SELECT\n      DATE(timestamp, 'America/Los_Angeles') AS date,\n      context_locale,\n      anonymous_id AS ext_anonymous_id,\n      extension_type,\n      context_country,\n      puci, -- this accounts for pre 1.1.1 pucis in the installs_base logic\n      placement,\n      product,\n      CASE\n        WHEN context_country IS NOT NULL THEN context_country\n        WHEN context_locale IN ('en-US', 'es-US') THEN 'US'\n        WHEN context_locale IN ('en-AU') THEN 'AU'\n        WHEN context_locale IN ('en-CA', 'fr-CA') THEN 'CA'\n        WHEN context_locale IN ('en-GB', 'en-GB-oxendict', 'en') THEN 'GB'\n        WHEN context_locale IN ('en-DE', 'de', 'de-DE') THEN 'DE'\n        ELSE \"OTHER_LOCALE\" -- this is for pre 2/25 context_country being added\n      END AS country_coalesce\n    FROM `piedotorg-production.growth_marketing.installs_base_w_reinstall`\n    WHERE\n      extension_type IN ('adblock', 'adblocker') \n      AND IFNULL(NOT is_synced_install, is_first_install)\n      AND puci IS NOT NULL\n      AND placement IS NOT NULL\n      AND product IS NOT NULL\n  ),\n  \n  base AS (\n    SELECT\n      date,\n      adblock_installs.placement,\n      product,\n      adblock_installs.puci,\n      country_coalesce,\n      MAX(IF(date BETWEEN start_date AND end_date, cpi, 0)) as cpi, -- get the actual CPI rate\n      FORMAT_DATE('%Y-%m', date) AS year_month,\n      COUNT(DISTINCT ext_anonymous_id) AS extension_install_count\n    FROM\n      adblock_installs\n    LEFT JOIN\n      cpi_manual\n    ON\n      cpi_manual.geo = adblock_installs.country_coalesce\n      AND adblock_installs.placement = cpi_manual.placement\n      AND ((cpi_manual.puci IS NOT NULL AND adblock_installs.puci = cpi_manual.puci)\n           OR (cpi_manual.puci IS NULL))\n    GROUP BY date, placement, product, puci, country_coalesce, year_month\n  )\n\nSELECT\n  date,\n  country_coalesce,\n  placement,\n  puci,\n  product,\n  extension_install_count,\n  cpi,\n  cpi AS payout_amount,\n  cpi * extension_install_count AS payout_total,\n  year_month\nFROM base",
          "dependencies": [
            "dpr_manual_external",
            "installs_base_w_reinstall"
          ]
        }
      },
      {
        "id": "int_publisher_cpms",
        "model": {
          "name": "int_publisher_cpms",
          "filePath": "growth_int/int_publisher_cpms.sqlx",
          "type": "view",
          "schema": "growth_int_dev",
          "tags": [
            "growth",
            "intermediate"
          ],
          "config": {
            "type": "view",
            "schema": "growth_int_dev",
            "tags": [
              "growth",
              "intermediate"
            ]
          },
          "sqlContent": "-- int_publisher_cpms.sqlx\n-- Intermediate view for publisher_cpms logic from the original query\n-- Dataset: growth_int\n-- Debug: This view extracts publisher CPM data for further processing\n\n\n\nselect\n  net.reg_domain(website) as domain,\n  concept,\n  puci,\n  cpm,\n  SAFE_CAST(start_date AS date) as start_date,\n  SAFE_CAST(end_date as date) as end_date\nfrom\n    `piedotorg-production.growth_marketing.dpr_manual_publisher_cpms` l\n-- Debug: End of int_publisher_cpms view ",
          "dependencies": [
            "dpr_manual_publisher_cpms"
          ]
        }
      },
      {
        "id": "offer_campaign_ir_base",
        "model": {
          "name": "offer_campaign_ir_base",
          "filePath": "intent_engine/offer_campaign_ir_base.sqlx",
          "type": "table",
          "schema": "intent_engine_dev",
          "tags": [
            "campaign_analytics"
          ],
          "description": "Base table for offer campaign metrics using GROUPING SETS for multi-grain aggregation - single source of truth. In dev environments, filters to last 7 days of offer data and 30 days of transaction data for faster processing. Fixed Cartesian product issue. Includes consideration metrics for AI offers.",
          "config": {
            "type": "table",
            "schema": "intent_engine_dev",
            "tags": [
              "campaign_analytics"
            ],
            "description": "Base table for offer campaign metrics using GROUPING SETS for multi-grain aggregation - single source of truth. In dev environments, filters to last 7 days of offer data and 30 days of transaction data for faster processing. Fixed Cartesian product issue. Includes consideration metrics for AI offers.",
            "bigquery": {
              "partitionBy": "DATE(dt)",
              "clusterBy": [
                "period",
                "campaign_id",
                "merchant_id"
              ]
            }
          },
          "sqlContent": "\n\n\n\n-- Base Campaign Analytics using ROLLUP/GROUPING SETS for multi-grain aggregation\nWITH \n-- Base data from offer_expanded_view\noffer_base AS (\n  SELECT\n    DATETIME(oe.ts) AS ts,\n    DATETIME_TRUNC(DATETIME(oe.ts), HOUR) AS dt_hour,\n    oe.campaign_id,\n    oe.merchant_id,\n    oe.anonymous_id,\n    oe.user_id,\n    oe.request_id,\n    oe.offer_id,\n    oe.action,\n    oe.surface,\n    oe.offer_presented,\n    oe.source_type,\n    oe.intent_engine_type,\n    oe.req_offer\n  FROM `piedotorg-production.intent_engine_dev.offer_expanded_view` oe\n  WHERE oe.campaign_id IS NOT NULL\n    AND oe.merchant_id IS NOT NULL\n    -- Include both frontend events (with actions) and backend-only events (considerations without frontend)\n    AND (oe.action IN ('show', 'view', 'click', 'close', 'redeem') OR oe.action IS NULL)\n    AND DATE(oe.ts) >= '1970-01-01'\n),\n\n-- Campaign metadata\ncampaign_data AS (\n  SELECT \n    campaignId,\n    budget,\n    merchantId,\n    DATETIME(TIMESTAMP_MILLIS(created)) AS campaign_created_ts,\n    DATETIME(COALESCE(TIMESTAMP_MILLIS(updated), TIMESTAMP_MILLIS(created))) AS campaign_updated_ts,\n    CASE \n      WHEN endDate IS NOT NULL THEN DATETIME(TIMESTAMP_MILLIS(endDate))\n      WHEN state IN ('PAUSED', 'ENDED', 'CANCELLED', 'ARCHIVED') THEN DATETIME(COALESCE(TIMESTAMP_MILLIS(updated), TIMESTAMP_MILLIS(created)))\n      ELSE NULL \n    END AS campaign_ended_ts,\n    CASE WHEN state = 'ACTIVE' THEN true ELSE false END AS active,\n    state AS campaign_state,\n    CASE WHEN startDate IS NOT NULL THEN DATETIME(TIMESTAMP_MILLIS(startDate)) ELSE DATETIME(TIMESTAMP_MILLIS(created)) END AS campaign_start_ts\n  FROM `piedotorg-production.analytics_etl.campaigns_campaigns`\n),\n\n-- Transaction data for affiliate attribution\ntransactions_base AS (\n  SELECT\n    DATETIME(created_coalesce_ts) AS created_ts,\n    transactionId,\n    anonymous_id,\n    CASE \n      WHEN merchantId = 'verizon' AND IFNULL(externalSaleValue, 0) = 0 \n      THEN externalCommission \n      ELSE externalSaleValue \n    END AS externalSaleValue,\n    externalCommission,\n    CASE WHEN merchantId = 'logitechg' THEN 'logitech' ELSE merchantId END AS merchantId,\n    adOfferId,\n    campaignId AS adoffercampaignId,\n    subsrc,\n    userId,\n    type,\n    balance_burned_millipoints,\n    millipoints,\n    LOWER(adOfferType) AS transaction_type\n  FROM `piedotorg-production.data_science_dev.transactions_expanded_view`\n  WHERE (\n    -- AD_OFFER transactions need campaignId (direct offer claims)\n    (type = 'AD_OFFER' AND campaignId IS NOT NULL)\n    OR \n    -- AFFILIATE transactions can have NULL campaignId (attribution-based)\n    (type = 'AFFILIATE')\n  )\n  AND DATE(created_coalesce_ts) >= '1970-01-01'\n),\n\n-- Direct affiliate transactions - DAILY ONLY (no hourly breakdown needed)\ndirect_transactions AS (\n  SELECT\n    DATETIME_TRUNC(aff.created_ts, DAY) AS dt_day,\n    aff.adoffercampaignId AS campaign_id,\n    aff.merchantId AS merchant_id,\n    COUNT(*) AS offer_aff_trx,\n    COUNT(DISTINCT aff.anonymous_id) AS trx_anonymous_ids,\n    COUNT(DISTINCT aff.userId) AS trx_devices, -- Using userId as device proxy\n    COUNT(DISTINCT aff.transactionId) AS dist_trx_offer_aff,\n    SUM(aff.externalSaleValue) / 100 AS gmv_dollars,\n    SUM(aff.externalCommission) / 100 AS commission_dollars\n  FROM transactions_base aff\n  INNER JOIN transactions_base offer \n    ON aff.userId = offer.userId \n    AND aff.merchantId = offer.merchantId\n    AND aff.created_ts BETWEEN offer.created_ts AND COALESCE(\n      -- Use campaign end logic similar to old version\n      DATETIME_ADD(offer.created_ts, INTERVAL 30 DAY), \n      CURRENT_DATETIME()\n    )\n  WHERE aff.type = 'AFFILIATE'\n    AND offer.type = 'AD_OFFER'\n    AND aff.subsrc IN ('pie_offer_search', 'pie_offer_retargeting', 'pie_offer_login_search')\n  GROUP BY dt_day, campaign_id, merchant_id\n),\n\n-- Budget and awards tracking - DAILY ONLY (no hourly breakdown needed)\nbudget_awards AS (\n  SELECT\n    DATETIME_TRUNC(created_ts, DAY) AS dt_day,\n    adoffercampaignId AS campaign_id,\n    merchantId AS merchant_id,\n    SUM(millipoints) / 100000 AS dollars_awarded,\n    SUM(balance_burned_millipoints) / 1000 / 100 AS budget_usedindollars,\n    SUM(balance_burned_millipoints) AS budget_usedinmillipoints,\n    SUM(millipoints) AS millipoints_awarded,\n    COUNT(*) AS unique_awards,\n    COUNT(DISTINCT userId) AS awarded_devices,\n    COUNT(DISTINCT anonymous_id) AS awarded_anonymous_ids,\n    ARRAY_AGG(DISTINCT adOfferId IGNORE NULLS) AS award_offer_ids\n  FROM transactions_base\n  WHERE type = 'AD_OFFER'\n    AND adoffercampaignId IS NOT NULL\n  GROUP BY dt_day, campaign_id, merchant_id\n),\n\n-- Click attribution 24h - affiliate transactions attributed to click events within 24h\nclick_attribution_24h AS (\n  SELECT\n    DATETIME_TRUNC(aff.created_ts, HOUR) AS dt_hour,\n    DATETIME_TRUNC(aff.created_ts, DAY) AS dt_day,\n    click_events.campaign_id,\n    aff.merchantId AS merchant_id,\n    COUNT(*) AS click_transactions_24h,\n    COUNT(DISTINCT aff.anonymous_id) AS click_anonymous_ids_24h,\n    COUNT(DISTINCT aff.userId) AS click_devices_24h,\n    SUM(aff.externalSaleValue) / 100 AS click_gmv_dollars_24h,\n    SUM(aff.externalCommission) / 100 AS click_commission_dollars_24h\n  FROM transactions_base aff\n  INNER JOIN (\n    -- Get click events from our offer_base data\n    SELECT DISTINCT\n      anonymous_id,\n      campaign_id,\n      merchant_id,\n      ts\n    FROM offer_base\n    WHERE action = 'click'\n      AND campaign_id IS NOT NULL\n  ) click_events\n    ON aff.anonymous_id = click_events.anonymous_id\n    AND aff.merchantId = click_events.merchant_id\n    AND DATETIME_DIFF(aff.created_ts, click_events.ts, HOUR) BETWEEN 0 AND 24\n    AND aff.created_ts >= click_events.ts\n  WHERE aff.type = 'AFFILIATE'\n  GROUP BY dt_hour, dt_day, campaign_id, merchant_id\n),\n\n-- Click attribution 7d - affiliate transactions attributed to click events within 7d\nclick_attribution_7d AS (\n  SELECT\n    DATETIME_TRUNC(aff.created_ts, HOUR) AS dt_hour,\n    DATETIME_TRUNC(aff.created_ts, DAY) AS dt_day,\n    click_events.campaign_id,\n    aff.merchantId AS merchant_id,\n    COUNT(*) AS click_transactions_7d,\n    COUNT(DISTINCT aff.anonymous_id) AS click_anonymous_ids_7d,\n    COUNT(DISTINCT aff.userId) AS click_devices_7d,\n    SUM(aff.externalSaleValue) / 100 AS click_gmv_dollars_7d,\n    SUM(aff.externalCommission) / 100 AS click_commission_dollars_7d\n  FROM transactions_base aff\n  INNER JOIN (\n    -- Get click events from our offer_base data\n    SELECT DISTINCT\n      anonymous_id,\n      campaign_id,\n      merchant_id,\n      ts\n    FROM offer_base\n    WHERE action = 'click'\n      AND campaign_id IS NOT NULL\n  ) click_events\n    ON aff.anonymous_id = click_events.anonymous_id\n    AND aff.merchantId = click_events.merchant_id\n    AND DATETIME_DIFF(aff.created_ts, click_events.ts, DAY) BETWEEN 0 AND 7\n    AND aff.created_ts >= click_events.ts\n  WHERE aff.type = 'AFFILIATE'\n  GROUP BY dt_hour, dt_day, campaign_id, merchant_id\n),\n\n-- View attribution 24h - affiliate transactions attributed to show events within 24h\nview_attribution_24h AS (\n  SELECT\n    DATETIME_TRUNC(aff.created_ts, HOUR) AS dt_hour,\n    DATETIME_TRUNC(aff.created_ts, DAY) AS dt_day,\n    view_events.campaign_id,\n    aff.merchantId AS merchant_id,\n    COUNT(*) AS view_transactions_24h,\n    COUNT(DISTINCT aff.anonymous_id) AS view_anonymous_ids_24h,\n    COUNT(DISTINCT aff.userId) AS view_devices_24h,\n    SUM(aff.externalSaleValue) / 100 AS view_gmv_dollars_24h,\n    SUM(aff.externalCommission) / 100 AS view_commission_dollars_24h\n  FROM transactions_base aff\n  INNER JOIN (\n    -- Get show events from our offer_base data\n    SELECT DISTINCT\n      anonymous_id,\n      campaign_id,\n      merchant_id,\n      ts\n    FROM offer_base\n    WHERE action IN ('show', 'view')\n      AND campaign_id IS NOT NULL\n  ) view_events\n    ON aff.anonymous_id = view_events.anonymous_id\n    AND aff.merchantId = view_events.merchant_id\n    AND DATETIME_DIFF(aff.created_ts, view_events.ts, HOUR) BETWEEN 0 AND 24\n    AND aff.created_ts >= view_events.ts\n  WHERE aff.type = 'AFFILIATE'\n  GROUP BY dt_hour, dt_day, campaign_id, merchant_id\n),\n\n-- View attribution 7d - affiliate transactions attributed to show events within 7d\nview_attribution_7d AS (\n  SELECT\n    DATETIME_TRUNC(aff.created_ts, HOUR) AS dt_hour,\n    DATETIME_TRUNC(aff.created_ts, DAY) AS dt_day,\n    view_events.campaign_id,\n    aff.merchantId AS merchant_id,\n    COUNT(*) AS view_transactions_7d,\n    COUNT(DISTINCT aff.anonymous_id) AS view_anonymous_ids_7d,\n    COUNT(DISTINCT aff.userId) AS view_devices_7d,\n    SUM(aff.externalSaleValue) / 100 AS view_gmv_dollars_7d,\n    SUM(aff.externalCommission) / 100 AS view_commission_dollars_7d\n  FROM transactions_base aff\n  INNER JOIN (\n    -- Get show events from our offer_base data\n    SELECT DISTINCT\n      anonymous_id,\n      campaign_id,\n      merchant_id,\n      ts\n    FROM offer_base\n    WHERE action IN ('show', 'view')\n      AND campaign_id IS NOT NULL\n  ) view_events\n    ON aff.anonymous_id = view_events.anonymous_id\n    AND aff.merchantId = view_events.merchant_id\n    AND DATETIME_DIFF(aff.created_ts, view_events.ts, DAY) BETWEEN 0 AND 7\n    AND aff.created_ts >= view_events.ts\n  WHERE aff.type = 'AFFILIATE'\n  GROUP BY dt_hour, dt_day, campaign_id, merchant_id\n),\n\n-- Checkout detection base data\ncheckout_detection_base AS (\n  SELECT\n    DATETIME(timestamp) AS detected_ts,\n    anonymous_id,\n    merchant_id,\n    final_score\n  FROM `piedotorg-production.backend_analytics.checkout_detection`\n  WHERE classified_as_checkout = true\n    AND anonymous_id IS NOT NULL\n    AND merchant_id IS NOT NULL\n),\n\n-- Checkout attribution 24h - checkout detections attributed to click events within 24h\ncheckout_attribution_24h AS (\n  SELECT\n    DATETIME_TRUNC(cd.detected_ts, HOUR) AS dt_hour,\n    DATETIME_TRUNC(cd.detected_ts, DAY) AS dt_day,\n    click_events.campaign_id,\n    cd.merchant_id,\n    COUNT(*) AS checkout_detections_24h,\n    COUNT(DISTINCT cd.anonymous_id) AS checkout_anonymous_ids_24h,\n    AVG(cd.final_score) AS avg_checkout_score_24h\n  FROM checkout_detection_base cd\n  INNER JOIN (\n    -- Get click events from our offer_base data\n    SELECT DISTINCT\n      anonymous_id,\n      campaign_id,\n      merchant_id,\n      ts\n    FROM offer_base\n    WHERE action = 'click'\n      AND campaign_id IS NOT NULL\n  ) click_events\n    ON cd.anonymous_id = click_events.anonymous_id\n    AND cd.merchant_id = click_events.merchant_id\n    AND DATETIME_DIFF(cd.detected_ts, click_events.ts, HOUR) BETWEEN 0 AND 24\n    AND cd.detected_ts >= click_events.ts\n  GROUP BY dt_hour, dt_day, campaign_id, merchant_id\n),\n\n-- Checkout attribution 7d - checkout detections attributed to click events within 7d\ncheckout_attribution_7d AS (\n  SELECT\n    DATETIME_TRUNC(cd.detected_ts, HOUR) AS dt_hour,\n    DATETIME_TRUNC(cd.detected_ts, DAY) AS dt_day,\n    click_events.campaign_id,\n    cd.merchant_id,\n    COUNT(*) AS checkout_detections_7d,\n    COUNT(DISTINCT cd.anonymous_id) AS checkout_anonymous_ids_7d,\n    AVG(cd.final_score) AS avg_checkout_score_7d\n  FROM checkout_detection_base cd\n  INNER JOIN (\n    -- Get click events from our offer_base data\n    SELECT DISTINCT\n      anonymous_id,\n      campaign_id,\n      merchant_id,\n      ts\n    FROM offer_base\n    WHERE action = 'click'\n      AND campaign_id IS NOT NULL\n  ) click_events\n    ON cd.anonymous_id = click_events.anonymous_id\n    AND cd.merchant_id = click_events.merchant_id\n    AND DATETIME_DIFF(cd.detected_ts, click_events.ts, DAY) BETWEEN 0 AND 7\n    AND cd.detected_ts >= click_events.ts\n  GROUP BY dt_hour, dt_day, campaign_id, merchant_id\n),\n\n-- Placement metrics - using GROUPING SETS for consistent multi-grain aggregation\nplacement_metrics AS (\n  SELECT\n    -- Time dimension using GROUPING SETS approach\n    COALESCE(hour_grain, day_grain) AS dt_time,\n    \n    -- Period indicator using GROUPING function\n    CASE \n      WHEN GROUPING(hour_grain) = 0 THEN 'hour'\n      WHEN GROUPING(day_grain) = 0 THEN 'day'\n    END AS grain,\n    \n    campaign_id,\n    merchant_id,\n    COUNT(*) AS total_placements,\n    COUNT(DISTINCT CONCAT(campaign_id, '-', merchant_id, '-', anonymous_id, '-', DATE(ts))) AS total_placement_hashes,\n    COUNT(DISTINCT anonymous_id) AS total_audience_ids\n  FROM (\n    SELECT \n      DATETIME_TRUNC(ts, HOUR) AS hour_grain,\n      DATETIME_TRUNC(ts, DAY) AS day_grain,\n      campaign_id,\n      merchant_id,\n      anonymous_id,\n      ts\n    FROM offer_base\n    WHERE campaign_id IS NOT NULL AND merchant_id IS NOT NULL\n  )\n  \n  -- GROUPING SETS for both hourly and daily aggregation\n  GROUP BY GROUPING SETS (\n    (hour_grain, campaign_id, merchant_id),   -- Hourly grain\n    (day_grain, campaign_id, merchant_id)     -- Daily grain  \n  )\n),\n\n-- User balance and claims tracking - DAILY ONLY (no hourly breakdown needed)\nbalance_claims AS (\n  SELECT\n    DATETIME_TRUNC(created_ts, DAY) AS dt_day,\n    adoffercampaignId AS campaign_id,\n    merchantId AS merchant_id,\n    -- Claims metrics (AD_OFFER transactions are essentially claims)\n    COUNT(*) AS total_claims,\n    COUNT(DISTINCT userId) AS claimed_devices,\n    COUNT(DISTINCT anonymous_id) AS claimed_anonymous_ids,\n    ARRAY_AGG(DISTINCT adOfferId IGNORE NULLS) AS claimed_offer_ids,\n    -- Balance burned metrics (assume millipoints represent burned balance)\n    SUM(millipoints) AS user_balance_burned_millipoints,\n    SUM(millipoints) / 100000 AS user_balance_burned_millipoints_dollars\n  FROM transactions_base\n  WHERE type = 'AD_OFFER'\n    AND adoffercampaignId IS NOT NULL\n    AND millipoints > 0  -- Only count actual balance usage\n  GROUP BY dt_day, campaign_id, merchant_id\n),\n\n-- Prepare time dimensions for GROUPING SETS\ntime_dimensions AS (\n  SELECT\n    ob.*,\n    cd.campaign_created_ts,\n    cd.campaign_updated_ts,\n    cd.campaign_ended_ts,\n    cd.active,\n    cd.budget,\n    cd.campaign_state,\n    cd.campaign_start_ts,\n    -- Pre-calculate both time grains\n    ob.dt_hour AS hour_grain,\n    DATETIME_TRUNC(ob.dt_hour, DAY) AS day_grain\n  FROM offer_base ob\n  LEFT JOIN campaign_data cd ON ob.campaign_id = cd.campaignId AND ob.merchant_id = cd.merchantId\n),\n\n-- Multi-grain aggregation using GROUPING SETS approach with transaction data\nmulti_grain_base AS (\n  SELECT\n    -- Time dimension - use COALESCE to handle NULL from GROUPING SETS\n    COALESCE(td.hour_grain, td.day_grain) AS dt_hour,\n    \n    -- Period indicator using GROUPING function (used for join logic)\n    CASE \n      WHEN GROUPING(td.hour_grain) = 0 THEN 'hour'\n      WHEN GROUPING(td.day_grain) = 0 THEN 'day'\n    END AS period,\n    \n    td.campaign_id,\n    td.merchant_id,\n    td.source_type,\n    td.intent_engine_type,\n    \n    -- Campaign metadata\n    ANY_VALUE(td.campaign_created_ts) AS campaign_created_ts,\n    ANY_VALUE(td.campaign_updated_ts) AS campaign_updated_ts,\n    ANY_VALUE(td.campaign_ended_ts) AS campaign_ended_ts,\n    ANY_VALUE(td.active) AS campaign_active,\n    ANY_VALUE(td.budget) AS campaign_budget,\n    ANY_VALUE(td.campaign_state) AS campaign_state,\n    ANY_VALUE(td.campaign_start_ts) AS campaign_start_ts,\n    \n    CAST([] AS ARRAY<STRUCT<offergroup_id STRING>>) AS offergroups,\n    \n    -- Core engagement metrics with proper COUNT DISTINCT\n    -- These will be correctly deduplicated at both hourly and daily levels\n    \n    -- Consideration metrics (AI offers only - backend events with or without frontend events)\n    COUNT(DISTINCT CASE WHEN td.intent_engine_type IN ('AI', 'MCP') THEN td.user_id END) AS consideration_users,\n    COUNT(DISTINCT CASE WHEN td.intent_engine_type IN ('AI', 'MCP') THEN td.req_offer END) AS considerations,\n    -- COUNT(DISTINCT CASE WHEN td.intent_engine_type = 'AI' THEN td.anonymous_id END) AS consideration_anonymous_ids,\n    \n    -- Expanded surface filters using JavaScript variable\n    COUNT(DISTINCT CASE WHEN td.action IN ('show', 'view') AND td.surface IN ('prompt', 'login_prompt', 'chatgpt', 'chat_gpt', 'gpt', 'ai_offers', 'rewards_transaction_popup', 'offers_popup', 'intent_engine', 'search_prompt', 'retargeting_prompt') AND td.offer_presented = true THEN td.user_id END) AS show_users,\n    COUNT(DISTINCT CASE WHEN td.action IN ('show', 'view') AND td.surface IN ('prompt', 'login_prompt', 'chatgpt', 'chat_gpt', 'gpt', 'ai_offers', 'rewards_transaction_popup', 'offers_popup', 'intent_engine', 'search_prompt', 'retargeting_prompt') AND td.offer_presented = true THEN td.req_offer END) AS shows,\n    COUNT(CASE WHEN td.action IN ('show', 'view') AND td.surface IN ('prompt', 'login_prompt', 'chatgpt', 'chat_gpt', 'gpt', 'ai_offers', 'rewards_transaction_popup', 'offers_popup', 'intent_engine', 'search_prompt', 'retargeting_prompt') AND td.offer_presented = true THEN 1 END) AS shows_raw,\n    -- COUNT(DISTINCT CASE WHEN td.action IN ('show', 'view') AND td.surface IN (${OFFER_SURFACES.map(s => `'${s}'`).join(', ')}) AND td.offer_presented = true THEN td.anonymous_id END) AS show_anonymous_ids,\n    COUNT(DISTINCT CASE WHEN td.action = 'click' AND td.surface IN ('prompt', 'login_prompt', 'chatgpt', 'chat_gpt', 'gpt', 'ai_offers', 'rewards_transaction_popup', 'offers_popup', 'intent_engine', 'search_prompt', 'retargeting_prompt') AND td.offer_presented = true THEN td.user_id END) AS click_users,\n    COUNT(DISTINCT CASE WHEN td.action = 'click' AND td.surface IN ('prompt', 'login_prompt', 'chatgpt', 'chat_gpt', 'gpt', 'ai_offers', 'rewards_transaction_popup', 'offers_popup', 'intent_engine', 'search_prompt', 'retargeting_prompt') AND td.offer_presented = true THEN td.req_offer END) AS clicks,\n    COUNT(CASE WHEN td.action = 'click' AND td.surface IN ('prompt', 'login_prompt', 'chatgpt', 'chat_gpt', 'gpt', 'ai_offers', 'rewards_transaction_popup', 'offers_popup', 'intent_engine', 'search_prompt', 'retargeting_prompt') AND td.offer_presented = true THEN 1 END) AS clicks_raw,\n    -- COUNT(DISTINCT CASE WHEN td.action = 'click' AND td.surface IN (${OFFER_SURFACES.map(s => `'${s}'`).join(', ')}) AND td.offer_presented = true THEN td.anonymous_id END) AS click_anonymous_ids,\n    COUNT(DISTINCT CASE WHEN td.action = 'close' AND td.surface IN ('prompt', 'login_prompt', 'chatgpt', 'chat_gpt', 'gpt', 'ai_offers', 'rewards_transaction_popup', 'offers_popup', 'intent_engine', 'search_prompt', 'retargeting_prompt') AND td.offer_presented = true THEN td.user_id END) AS close_users,\n    COUNT(CASE WHEN td.action = 'close' AND td.surface IN ('prompt', 'login_prompt', 'chatgpt', 'chat_gpt', 'gpt', 'ai_offers', 'rewards_transaction_popup', 'offers_popup', 'intent_engine', 'search_prompt', 'retargeting_prompt') AND td.offer_presented = true THEN 1 END) AS closes,\n    -- COUNT(DISTINCT CASE WHEN td.action = 'close' AND td.surface IN (${OFFER_SURFACES.map(s => `'${s}'`).join(', ')}) AND td.offer_presented = true THEN td.anonymous_id END) AS close_anonymous_ids,\n    COUNT(DISTINCT CASE WHEN td.action = 'redeem' AND td.surface IN ('prompt', 'login_prompt', 'chatgpt', 'chat_gpt', 'gpt', 'ai_offers', 'rewards_transaction_popup', 'offers_popup', 'intent_engine', 'search_prompt', 'retargeting_prompt') AND td.offer_presented = true THEN td.user_id END) AS redeem_users,\n    COUNT(DISTINCT CASE WHEN td.action = 'redeem' AND td.surface IN ('prompt', 'login_prompt', 'chatgpt', 'chat_gpt', 'gpt', 'ai_offers', 'rewards_transaction_popup', 'offers_popup', 'intent_engine', 'search_prompt', 'retargeting_prompt') AND td.offer_presented = true THEN td.req_offer END) AS redeems,\n    COUNT(CASE WHEN td.action = 'redeem' AND td.surface IN ('prompt', 'login_prompt', 'chatgpt', 'chat_gpt', 'gpt', 'ai_offers', 'rewards_transaction_popup', 'offers_popup', 'intent_engine', 'search_prompt', 'retargeting_prompt') AND td.offer_presented = true THEN 1 END) AS redeems_raw,\n    -- COUNT(DISTINCT CASE WHEN td.action = 'redeem' AND td.surface IN (${OFFER_SURFACES.map(s => `'${s}'`).join(', ')}) AND td.offer_presented = true THEN td.anonymous_id END) AS redeem_anonymous_ids,\n    COUNT(DISTINCT CASE WHEN td.action IN ('show', 'view') AND td.surface = 'error_prompt' AND td.offer_presented = true THEN td.user_id END) AS error_users,\n    COUNT(CASE WHEN td.action IN ('show', 'view') AND td.surface = 'error_prompt' AND td.offer_presented = true THEN 1 END) AS errors,\n    -- COUNT(DISTINCT CASE WHEN td.action IN ('show', 'view') AND td.surface = 'error_prompt' AND td.offer_presented = true THEN td.anonymous_id END) AS error_anonymous_ids,\n    \n    -- No-show metrics (Phase 3 - Limited implementation, data not available for all reasons)\n    0 AS no_shows_cooldown, 0 AS no_shows_tied_lost, 0 AS no_shows_not_funded, 0 AS no_shows_lower_bid, 0 AS no_shows_lower_campaign_boost, 0 AS no_shows_lower_offergroup_boost, 0 AS total_no_shows,\n    \n    -- Placement metrics (both hourly and daily using grain-aware JOIN)\n    COALESCE(MAX(pm.total_placements), 0) AS total_placements,\n    COALESCE(MAX(pm.total_placement_hashes), 0) AS total_placement_hashes,\n    COALESCE(MAX(pm.total_audience_ids), 0) AS total_audience_ids, \n    \n    -- Direct transaction metrics (DAILY ONLY - used for both grains)\n    COALESCE(MAX(dt_day.offer_aff_trx), 0) AS offer_aff_trx,\n    COALESCE(MAX(dt_day.trx_devices), 0) AS trx_devices,\n    COALESCE(MAX(dt_day.trx_anonymous_ids), 0) AS trx_anonymous_ids,\n    COALESCE(MAX(dt_day.gmv_dollars), 0.0) AS gmv_dollars,\n    COALESCE(MAX(dt_day.commission_dollars), 0.0) AS commission_dollars,\n    \n    -- Budget and awards metrics (DAILY ONLY - used for both grains)\n    COALESCE(MAX(ba_day.millipoints_awarded), 0) AS millipoints_awarded,\n    COALESCE(MAX(ba_day.dollars_awarded), 0.0) AS dollars_awarded,\n    COALESCE(MAX(ba_day.unique_awards), 0) AS unique_awards,\n    COALESCE(MAX(ba_day.awarded_devices), 0) AS awarded_devices,\n    COALESCE(MAX(ba_day.awarded_anonymous_ids), 0) AS awarded_anonymous_ids,\n    IFNULL(ANY_VALUE(ba_day.award_offer_ids), []) AS award_offer_ids,\n    COALESCE(MAX(ba_day.budget_usedinmillipoints), 0) AS budget_usedinmillipoints,\n    COALESCE(MAX(ba_day.budget_usedindollars), 0.0) AS budget_usedindollars,\n    \n    -- Click attribution metrics (Phase 2 - ALL PERIODS, filtered later)\n    COALESCE(MAX(ca24h_day.click_transactions_24h), 0) AS click_transactions_24h,\n    COALESCE(MAX(ca24h_day.click_devices_24h), 0) AS click_devices_24h,\n    COALESCE(MAX(ca24h_day.click_anonymous_ids_24h), 0) AS click_anonymous_ids_24h,\n    COALESCE(MAX(ca24h_day.click_gmv_dollars_24h), 0.0) AS click_gmv_dollars_24h,\n    COALESCE(MAX(ca24h_day.click_commission_dollars_24h), 0.0) AS click_commission_dollars_24h,\n    COALESCE(MAX(ca7d_day.click_transactions_7d), 0) AS click_transactions_7d,\n    COALESCE(MAX(ca7d_day.click_devices_7d), 0) AS click_devices_7d,\n    COALESCE(MAX(ca7d_day.click_anonymous_ids_7d), 0) AS click_anonymous_ids_7d,\n    COALESCE(MAX(ca7d_day.click_gmv_dollars_7d), 0.0) AS click_gmv_dollars_7d,\n    COALESCE(MAX(ca7d_day.click_commission_dollars_7d), 0.0) AS click_commission_dollars_7d,\n    \n    -- View attribution metrics (Phase 2 - ALL PERIODS, filtered later) \n    COALESCE(MAX(va24h_day.view_transactions_24h), 0) AS view_transactions_24h,\n    COALESCE(MAX(va24h_day.view_devices_24h), 0) AS view_devices_24h,\n    COALESCE(MAX(va24h_day.view_anonymous_ids_24h), 0) AS view_anonymous_ids_24h,\n    COALESCE(MAX(va24h_day.view_gmv_dollars_24h), 0.0) AS view_gmv_dollars_24h,\n    COALESCE(MAX(va24h_day.view_commission_dollars_24h), 0.0) AS view_commission_dollars_24h,\n    COALESCE(MAX(va7d_day.view_transactions_7d), 0) AS view_transactions_7d,\n    COALESCE(MAX(va7d_day.view_devices_7d), 0) AS view_devices_7d,\n    COALESCE(MAX(va7d_day.view_anonymous_ids_7d), 0) AS view_anonymous_ids_7d,\n    COALESCE(MAX(va7d_day.view_gmv_dollars_7d), 0.0) AS view_gmv_dollars_7d,\n    COALESCE(MAX(va7d_day.view_commission_dollars_7d), 0.0) AS view_commission_dollars_7d,\n    \n    -- Checkout attribution metrics (Phase 2 - ALL PERIODS, filtered later)\n    COALESCE(MAX(co24h_day.checkout_detections_24h), 0) AS checkout_detections_24h,\n    COALESCE(MAX(co24h_day.checkout_anonymous_ids_24h), 0) AS checkout_anonymous_ids_24h,\n    COALESCE(MAX(co24h_day.avg_checkout_score_24h), 0.0) AS avg_checkout_score_24h,\n    COALESCE(MAX(co7d_day.checkout_detections_7d), 0) AS checkout_detections_7d,\n    COALESCE(MAX(co7d_day.checkout_anonymous_ids_7d), 0) AS checkout_anonymous_ids_7d,\n    COALESCE(MAX(co7d_day.avg_checkout_score_7d), 0.0) AS avg_checkout_score_7d, \n    \n    -- Balance and claims metrics (DAILY ONLY - used for both grains)\n    COALESCE(MAX(bc_day.user_balance_burned_millipoints), 0) AS user_balance_burned_millipoints,\n    COALESCE(MAX(bc_day.user_balance_burned_millipoints_dollars), 0.0) AS user_balance_burned_millipoints_dollars,\n    COALESCE(MAX(bc_day.total_claims), 0) AS total_claims,\n    COALESCE(MAX(bc_day.claimed_devices), 0) AS claimed_devices,\n    COALESCE(MAX(bc_day.claimed_anonymous_ids), 0) AS claimed_anonymous_ids,\n    IFNULL(ANY_VALUE(bc_day.claimed_offer_ids), []) AS claimed_offer_ids\n    \n  FROM time_dimensions td\n  -- Join direct transaction data (DAILY ONLY - used for both hourly and daily GROUPING SETS)\n  LEFT JOIN direct_transactions dt_day \n    ON dt_day.campaign_id = td.campaign_id \n    AND dt_day.merchant_id = td.merchant_id \n    AND dt_day.dt_day = td.day_grain\n  -- Join budget/awards data (DAILY ONLY - used for both hourly and daily GROUPING SETS)\n  LEFT JOIN budget_awards ba_day \n    ON ba_day.campaign_id = td.campaign_id \n    AND ba_day.merchant_id = td.merchant_id \n    AND ba_day.dt_day = td.day_grain\n  -- Join attribution data (DAILY ONLY - optimized performance)\n  LEFT JOIN click_attribution_24h ca24h_day\n    ON ca24h_day.campaign_id = td.campaign_id \n    AND ca24h_day.merchant_id = td.merchant_id \n    AND ca24h_day.dt_day = td.day_grain\n  LEFT JOIN click_attribution_7d ca7d_day\n    ON ca7d_day.campaign_id = td.campaign_id \n    AND ca7d_day.merchant_id = td.merchant_id \n    AND ca7d_day.dt_day = td.day_grain\n  LEFT JOIN view_attribution_24h va24h_day\n    ON va24h_day.campaign_id = td.campaign_id \n    AND va24h_day.merchant_id = td.merchant_id \n    AND va24h_day.dt_day = td.day_grain\n  LEFT JOIN view_attribution_7d va7d_day\n    ON va7d_day.campaign_id = td.campaign_id \n    AND va7d_day.merchant_id = td.merchant_id \n    AND va7d_day.dt_day = td.day_grain\n  -- Join checkout attribution data (DAILY ONLY - optimized performance)\n  LEFT JOIN checkout_attribution_24h co24h_day\n    ON co24h_day.campaign_id = td.campaign_id \n    AND co24h_day.merchant_id = td.merchant_id \n    AND co24h_day.dt_day = td.day_grain\n  LEFT JOIN checkout_attribution_7d co7d_day\n    ON co7d_day.campaign_id = td.campaign_id \n    AND co7d_day.merchant_id = td.merchant_id \n    AND co7d_day.dt_day = td.day_grain\n  -- Join placement metrics - simply match on the coalesced time and let period handle grain selection\n  LEFT JOIN placement_metrics pm\n    ON pm.campaign_id = td.campaign_id \n    AND pm.merchant_id = td.merchant_id \n    AND pm.dt_time = COALESCE(td.hour_grain, td.day_grain)\n  -- Join balance/claims data (DAILY ONLY - used for both hourly and daily GROUPING SETS)\n  LEFT JOIN balance_claims bc_day\n    ON bc_day.campaign_id = td.campaign_id \n    AND bc_day.merchant_id = td.merchant_id \n    AND bc_day.dt_day = td.day_grain\n  \n  -- GROUPING SETS to get both hourly and daily aggregations in one pass\n  GROUP BY GROUPING SETS (\n    (td.hour_grain, td.campaign_id, td.merchant_id, td.source_type, td.intent_engine_type),  -- Hourly grain\n    (td.day_grain, td.campaign_id, td.merchant_id, td.source_type, td.intent_engine_type)    -- Daily grain\n  )\n),\n\n-- Apply attribution filtering based on period\nmulti_grain_data AS (\n  SELECT\n    *,\n    -- Click attribution metrics (DAILY ONLY to prevent overcounting)\n    CASE WHEN period = 'day' THEN click_transactions_24h ELSE NULL END AS click_transactions_24h_final,\n    CASE WHEN period = 'day' THEN click_devices_24h ELSE NULL END AS click_devices_24h_final,\n    CASE WHEN period = 'day' THEN click_anonymous_ids_24h ELSE NULL END AS click_anonymous_ids_24h_final,\n    CASE WHEN period = 'day' THEN click_gmv_dollars_24h ELSE NULL END AS click_gmv_dollars_24h_final,\n    CASE WHEN period = 'day' THEN click_commission_dollars_24h ELSE NULL END AS click_commission_dollars_24h_final,\n    CASE WHEN period = 'day' THEN click_transactions_7d ELSE NULL END AS click_transactions_7d_final,\n    CASE WHEN period = 'day' THEN click_devices_7d ELSE NULL END AS click_devices_7d_final,\n    CASE WHEN period = 'day' THEN click_anonymous_ids_7d ELSE NULL END AS click_anonymous_ids_7d_final,\n    CASE WHEN period = 'day' THEN click_gmv_dollars_7d ELSE NULL END AS click_gmv_dollars_7d_final,\n    CASE WHEN period = 'day' THEN click_commission_dollars_7d ELSE NULL END AS click_commission_dollars_7d_final,\n    -- View attribution metrics (DAILY ONLY to prevent overcounting)\n    CASE WHEN period = 'day' THEN view_transactions_24h ELSE NULL END AS view_transactions_24h_final,\n    CASE WHEN period = 'day' THEN view_devices_24h ELSE NULL END AS view_devices_24h_final,\n    CASE WHEN period = 'day' THEN view_anonymous_ids_24h ELSE NULL END AS view_anonymous_ids_24h_final,\n    CASE WHEN period = 'day' THEN view_gmv_dollars_24h ELSE NULL END AS view_gmv_dollars_24h_final,\n    CASE WHEN period = 'day' THEN view_commission_dollars_24h ELSE NULL END AS view_commission_dollars_24h_final,\n    CASE WHEN period = 'day' THEN view_transactions_7d ELSE NULL END AS view_transactions_7d_final,\n    CASE WHEN period = 'day' THEN view_devices_7d ELSE NULL END AS view_devices_7d_final,\n    CASE WHEN period = 'day' THEN view_anonymous_ids_7d ELSE NULL END AS view_anonymous_ids_7d_final,\n    CASE WHEN period = 'day' THEN view_gmv_dollars_7d ELSE NULL END AS view_gmv_dollars_7d_final,\n    CASE WHEN period = 'day' THEN view_commission_dollars_7d ELSE NULL END AS view_commission_dollars_7d_final,\n    -- Checkout attribution metrics (DAILY ONLY to prevent overcounting)\n    CASE WHEN period = 'day' THEN checkout_detections_24h ELSE NULL END AS checkout_detections_24h_final,\n    CASE WHEN period = 'day' THEN checkout_anonymous_ids_24h ELSE NULL END AS checkout_anonymous_ids_24h_final,\n    CASE WHEN period = 'day' THEN avg_checkout_score_24h ELSE NULL END AS avg_checkout_score_24h_final,\n    CASE WHEN period = 'day' THEN checkout_detections_7d ELSE NULL END AS checkout_detections_7d_final,\n    CASE WHEN period = 'day' THEN checkout_anonymous_ids_7d ELSE NULL END AS checkout_anonymous_ids_7d_final,\n    CASE WHEN period = 'day' THEN avg_checkout_score_7d ELSE NULL END AS avg_checkout_score_7d_final\n  FROM multi_grain_base\n)\n\n-- Select final result with proper column names\nSELECT \n  -- Context-aware dt field: DATETIME truncated to appropriate granularity\n  CASE \n    WHEN period = 'day' THEN DATETIME_TRUNC(dt_hour, DAY)\n    WHEN period = 'hour' THEN DATETIME_TRUNC(dt_hour, HOUR)\n    ELSE dt_hour\n  END AS dt,\n  period,\n  campaign_id,\n  merchant_id,\n  source_type,\n  intent_engine_type,\n  campaign_created_ts,\n  campaign_updated_ts,\n  campaign_ended_ts,\n  campaign_active,\n  campaign_budget,\n  campaign_state,\n  campaign_start_ts,\n  offergroups,\n  consideration_users,\n  considerations,\n  -- consideration_anonymous_ids,\n  show_users,\n  shows,\n  shows_raw,\n  -- show_anonymous_ids,\n  click_users,\n  clicks,\n  clicks_raw,\n  -- click_anonymous_ids,\n  close_users,\n  closes,\n  -- close_anonymous_ids,\n  redeem_users,\n  redeems,\n  redeems_raw,\n  -- redeem_anonymous_ids,\n  error_users,\n  errors,\n  -- error_anonymous_ids,\n  no_shows_cooldown,\n  no_shows_tied_lost,\n  no_shows_not_funded,\n  no_shows_lower_bid,\n  no_shows_lower_campaign_boost,\n  no_shows_lower_offergroup_boost,\n  total_no_shows,\n  total_placements,\n  total_placement_hashes,\n  total_audience_ids,\n  offer_aff_trx,\n  trx_devices,\n  trx_anonymous_ids,\n  gmv_dollars,\n  commission_dollars,\n  millipoints_awarded,\n  dollars_awarded,\n  unique_awards,\n  awarded_devices,\n  awarded_anonymous_ids,\n  award_offer_ids,\n  budget_usedinmillipoints,\n  budget_usedindollars,\n  -- Attribution metrics with proper names (NULL for hourly records)\n  click_transactions_24h_final AS click_transactions_24h,\n  click_devices_24h_final AS click_devices_24h,\n  click_anonymous_ids_24h_final AS click_anonymous_ids_24h,\n  click_gmv_dollars_24h_final AS click_gmv_dollars_24h,\n  click_commission_dollars_24h_final AS click_commission_dollars_24h,\n  click_transactions_7d_final AS click_transactions_7d,\n  click_devices_7d_final AS click_devices_7d,\n  click_anonymous_ids_7d_final AS click_anonymous_ids_7d,\n  click_gmv_dollars_7d_final AS click_gmv_dollars_7d,\n  click_commission_dollars_7d_final AS click_commission_dollars_7d,\n  view_transactions_24h_final AS view_transactions_24h,\n  view_devices_24h_final AS view_devices_24h,\n  view_anonymous_ids_24h_final AS view_anonymous_ids_24h,\n  view_gmv_dollars_24h_final AS view_gmv_dollars_24h,\n  view_commission_dollars_24h_final AS view_commission_dollars_24h,\n  view_transactions_7d_final AS view_transactions_7d,\n  view_devices_7d_final AS view_devices_7d,\n  view_anonymous_ids_7d_final AS view_anonymous_ids_7d,\n  view_gmv_dollars_7d_final AS view_gmv_dollars_7d,\n  view_commission_dollars_7d_final AS view_commission_dollars_7d,\n  -- Checkout attribution metrics (NULL for hourly records)\n  checkout_detections_24h_final AS checkout_detections_24h,\n  checkout_anonymous_ids_24h_final AS checkout_anonymous_ids_24h,\n  avg_checkout_score_24h_final AS avg_checkout_score_24h,\n  checkout_detections_7d_final AS checkout_detections_7d,\n  checkout_anonymous_ids_7d_final AS checkout_anonymous_ids_7d,\n  avg_checkout_score_7d_final AS avg_checkout_score_7d,\n  user_balance_burned_millipoints,\n  user_balance_burned_millipoints_dollars,\n  total_claims,\n  claimed_devices,\n  claimed_anonymous_ids,\n  claimed_offer_ids\nFROM multi_grain_data",
          "dependencies": [
            "offer_expanded_view",
            "campaigns_campaigns",
            "transactions_expanded_view"
          ]
        }
      },
      {
        "id": "offer_campaign_ir_day",
        "model": {
          "name": "offer_campaign_ir_day",
          "filePath": "intent_engine/offer_campaign_ir_day.sqlx",
          "type": "view",
          "schema": "intent_engine_dev",
          "tags": [
            "intent_engine",
            "analytics",
            "campaigns",
            "day",
            "view"
          ],
          "description": "Daily aggregated metrics for ALL offer campaigns - filtered view from base table",
          "config": {
            "type": "view",
            "schema": "intent_engine_dev",
            "tags": [
              "intent_engine",
              "analytics",
              "campaigns",
              "day",
              "view"
            ],
            "description": "Daily aggregated metrics for ALL offer campaigns - filtered view from base table"
          },
          "sqlContent": "\n\n-- Daily Campaign Analytics for ALL campaigns - Filtered view from base table\nSELECT \n  * EXCEPT(dt),\n  DATE(dt) AS dt  -- Convert DATETIME to DATE for daily views\nFROM `piedotorg-production.intent_engine_dev.offer_campaign_ir_base`\nWHERE period = 'day'  -- Daily data only",
          "dependencies": [
            "offer_campaign_ir_base"
          ]
        }
      },
      {
        "id": "offer_campaign_ir_day_ai_only",
        "model": {
          "name": "offer_campaign_ir_day_ai_only",
          "filePath": "intent_engine/offer_campaign_ir_day_ai_only.sqlx",
          "type": "view",
          "schema": "intent_engine_dev",
          "tags": [
            "intent_engine",
            "analytics",
            "campaigns",
            "day",
            "ai_only",
            "view"
          ],
          "description": "Daily aggregated metrics for AI-only offer campaigns - filtered view from base table",
          "config": {
            "type": "view",
            "schema": "intent_engine_dev",
            "tags": [
              "intent_engine",
              "analytics",
              "campaigns",
              "day",
              "ai_only",
              "view"
            ],
            "description": "Daily aggregated metrics for AI-only offer campaigns - filtered view from base table"
          },
          "sqlContent": "\n\n-- AI-Only Daily Campaign Analytics - Filtered view from base table\nSELECT \n  * EXCEPT(dt, intent_engine_type),\n  DATE(dt) AS dt  -- Convert DATETIME to DATE for daily views\nFROM `piedotorg-production.intent_engine_dev.offer_campaign_ir_base`\nWHERE period = 'day'  -- Daily data only\n  AND (intent_engine_type IN ('AI', 'MCP') OR source_type = 'ai')  -- AI offers only (defensive filter)",
          "dependencies": [
            "offer_campaign_ir_base"
          ]
        }
      },
      {
        "id": "offer_campaign_ir_hour",
        "model": {
          "name": "offer_campaign_ir_hour",
          "filePath": "intent_engine/offer_campaign_ir_hour.sqlx",
          "type": "view",
          "schema": "intent_engine_dev",
          "tags": [
            "intent_engine",
            "analytics",
            "campaigns",
            "hour",
            "view"
          ],
          "description": "Hourly aggregated metrics for ALL offer campaigns - filtered view from base table",
          "config": {
            "type": "view",
            "schema": "intent_engine_dev",
            "tags": [
              "intent_engine",
              "analytics",
              "campaigns",
              "hour",
              "view"
            ],
            "description": "Hourly aggregated metrics for ALL offer campaigns - filtered view from base table"
          },
          "sqlContent": "\n\n-- Hourly Campaign Analytics for ALL campaigns - Filtered view from base table\n-- Attribution metrics excluded (always NULL for hourly data)\nSELECT * EXCEPT(\n  period,\n  -- Click attribution fields (NULL for hourly data)\n  click_transactions_24h, click_devices_24h, click_anonymous_ids_24h, \n  click_gmv_dollars_24h, click_commission_dollars_24h,\n  click_transactions_7d, click_devices_7d, click_anonymous_ids_7d,\n  click_gmv_dollars_7d, click_commission_dollars_7d,\n  -- View attribution fields (NULL for hourly data)  \n  view_transactions_24h, view_devices_24h, view_anonymous_ids_24h,\n  view_gmv_dollars_24h, view_commission_dollars_24h,\n  view_transactions_7d, view_devices_7d, view_anonymous_ids_7d,\n  view_gmv_dollars_7d, view_commission_dollars_7d\n)\nFROM `piedotorg-production.intent_engine_dev.offer_campaign_ir_base`\nWHERE period = 'hour'  -- Hourly data only",
          "dependencies": [
            "offer_campaign_ir_base"
          ]
        }
      },
      {
        "id": "offer_campaign_ir_hour_ai_only",
        "model": {
          "name": "offer_campaign_ir_hour_ai_only",
          "filePath": "intent_engine/offer_campaign_ir_hour_ai_only.sqlx",
          "type": "view",
          "schema": "intent_engine_dev",
          "tags": [
            "intent_engine",
            "analytics",
            "campaigns",
            "hour",
            "ai_only",
            "view"
          ],
          "description": "Hourly aggregated metrics for AI-only offer campaigns - filtered view from base table",
          "config": {
            "type": "view",
            "schema": "intent_engine_dev",
            "tags": [
              "intent_engine",
              "analytics",
              "campaigns",
              "hour",
              "ai_only",
              "view"
            ],
            "description": "Hourly aggregated metrics for AI-only offer campaigns - filtered view from base table"
          },
          "sqlContent": "\n\n-- AI-Only Hourly Campaign Analytics - Filtered view from base table  \n-- Attribution metrics excluded (always NULL for hourly data)\nSELECT * EXCEPT(\n  period, intent_engine_type,\n  -- Click attribution fields (NULL for hourly data)\n  click_transactions_24h, click_devices_24h, click_anonymous_ids_24h,\n  click_gmv_dollars_24h, click_commission_dollars_24h,\n  click_transactions_7d, click_devices_7d, click_anonymous_ids_7d,\n  click_gmv_dollars_7d, click_commission_dollars_7d,\n  -- View attribution fields (NULL for hourly data)\n  view_transactions_24h, view_devices_24h, view_anonymous_ids_24h,\n  view_gmv_dollars_24h, view_commission_dollars_24h,\n  view_transactions_7d, view_devices_7d, view_anonymous_ids_7d,\n  view_gmv_dollars_7d, view_commission_dollars_7d\n)\nFROM `piedotorg-production.intent_engine_dev.offer_campaign_ir_base`\nWHERE period = 'hour'  -- Hourly data only\n  AND (intent_engine_type IN ('AI', 'MCP') OR source_type = 'ai')   -- AI offers only (defensive filter)",
          "dependencies": [
            "offer_campaign_ir_base"
          ]
        }
      },
      {
        "id": "offer_expanded_view",
        "model": {
          "name": "offer_expanded_view",
          "filePath": "intent_engine/offer_expanded_view.sqlx",
          "type": "table",
          "schema": "intent_engine_dev",
          "tags": [
            "intent_engine",
            "sources",
            "offers"
          ],
          "description": "Unified view of intent engine offers combining extension and AI offer data with placement, cooldown, and enrichment data - captures all ground-level events including duplicates from dual tracking",
          "config": {
            "type": "table",
            "schema": "intent_engine_dev",
            "tags": [
              "intent_engine",
              "sources",
              "offers"
            ],
            "description": "Unified view of intent engine offers combining extension and AI offer data with placement, cooldown, and enrichment data - captures all ground-level events including duplicates from dual tracking",
            "bigquery": {
              "partitionBy": "DATE(ts)",
              "clusterBy": [
                "campaign_id",
                "merchant_id",
                "action"
              ]
            }
          },
          "sqlContent": "\n\n-- Intent Engine Offer Expanded View - Ground-level Event Stream\n-- Debug: Preserves all events including duplicates from dual tracking systems (analytics.js + @segment/analytics-node)\nWITH deduplicated_placements AS (\n  SELECT DISTINCT\n    placementHash,\n    template,\n    placementId,\n    match,\n    hostname,\n    offerGroupId\n  FROM `piedotorg-production.analytics_etl.campaigns_placements`\n),\n\n-- Campaign metadata to enrich offers\ncampaign_data AS (\n  SELECT \n    campaignId,\n    budget,\n    merchantId,\n    TIMESTAMP_MILLIS(created) AS campaign_created_ts,\n    COALESCE(TIMESTAMP_MILLIS(updated), TIMESTAMP_MILLIS(created)) AS campaign_updated_ts,\n    CASE \n      WHEN endDate IS NOT NULL THEN TIMESTAMP_MILLIS(endDate)\n      WHEN state IN ('PAUSED', 'ENDED', 'CANCELLED', 'ARCHIVED') THEN COALESCE(TIMESTAMP_MILLIS(updated), TIMESTAMP_MILLIS(created))\n      ELSE NULL \n    END AS campaign_ended_ts,\n    CASE WHEN state = 'ACTIVE' THEN true ELSE false END AS active,\n    state AS campaign_state,\n    CASE WHEN startDate IS NOT NULL THEN TIMESTAMP_MILLIS(startDate) ELSE TIMESTAMP_MILLIS(created) END AS campaign_start_ts\n  FROM `piedotorg-production.analytics_etl.campaigns_campaigns`\n),\n\n-- Parse transactions_adviews for AI_AD transactions\nai_ad_transactions AS (\n  SELECT\n    userId,\n    adViewId,\n    state AS transaction_state,\n    created AS transaction_created_ms,\n    millipoints,\n    type AS transaction_type,\n    updated AS transaction_updated_ms,\n    JSON_EXTRACT_SCALAR(metadata, '$.offerId') AS offer_id,\n    JSON_EXTRACT_SCALAR(metadata, '$.requestId') AS request_id\n  FROM `piedotorg-production.analytics_etl.transactions_adviews`\n  WHERE type = 'AI_AD'\n    AND metadata IS NOT NULL\n),\n\n-- Unified frontend offer data (ext + AI + web)\nunified_frontend_offers AS (\n  -- Extension table with AI/web fields as NULL\n  SELECT \n    request_id,\n    offer_id,\n    action,\n    surface,\n    is_rewards,\n    user_id,\n    id,\n    timestamp AS timestamp_frontend,\n    NULL AS outbound_url,\n    context_user_agent AS user_agent,\n    ext_tag_id,\n    'ext' AS source_type,\n    -- Extension offer type classification\n    CASE \n      WHEN is_rewards = true THEN 'extension_rewards'\n      WHEN is_rewards = false THEN 'extension_regular'\n      ELSE 'extension_unknown'\n    END AS offer_type,\n    -- Tenant fields (NULL for extension)\n    NULL AS ai_tenant_id,\n    NULL AS ai_tenant_client_id,\n    NULL AS tenant_rewards_enabled,\n    -- Ext-specific fields (keep as-is)\n    anonymous_id,\n    referer_url,\n    platform,\n    context_app_name,\n    context_app_version,\n    context_browser,\n    context_browser_version,\n    context_device_id,\n    context_id,\n    context_ip,\n    context_library_name,\n    context_library_version,\n    context_locale,\n    context_os_os,\n    context_os_version,\n    context_os_name,\n    context_device_type,\n    context_time_zone,\n    event,\n    event_text,\n    loaded_at,\n    original_timestamp,\n    received_at,\n    sent_at,\n    uuid_ts\n  FROM `piedotorg-production.shopping_extension_production.ext_intent_engine_offer`\n  \n  UNION ALL\n  \n  -- AI table with ext/web fields as NULL  \n  SELECT\n    request_id,\n    offer_id, \n    action,\n    surface,\n    is_rewards,\n    user_id,\n    id,\n    TIMESTAMP_MILLIS(timestamp_ms) AS timestamp_frontend,\n    outbound_url,\n    user_agent,\n    tag_id AS ext_tag_id,\n    'ai' AS source_type,\n    -- AI offer type classification\n    CASE \n      WHEN REGEXP_CONTAINS(outbound_url, r'rewardsType=RATE_MAX') THEN 'cashback'\n      WHEN REGEXP_CONTAINS(outbound_url, r'rewardsType=RATE_PERCENT') THEN 'cashback'\n      WHEN REGEXP_CONTAINS(outbound_url, r'rewardsType=&|rewardsType=$') THEN 'regular_offer'\n      WHEN REGEXP_CONTAINS(outbound_url, r'rewardsType=FIXED') THEN 'fixed_reward'\n      ELSE 'other'\n    END AS offer_type,\n    -- Tenant fields from AI offers\n    tenant_id AS ai_tenant_id,\n    tenant_client_id AS ai_tenant_client_id,\n    tenant_rewards_enabled,\n    -- NULL for all ext-specific fields\n    NULL AS anonymous_id,\n    NULL AS referer_url,\n    NULL AS platform,\n    NULL AS context_app_name,\n    NULL AS context_app_version,\n    NULL AS context_browser,\n    NULL AS context_browser_version,\n    NULL AS context_device_id,\n    NULL AS context_id,\n    NULL AS context_ip,\n    NULL AS context_library_name,\n    NULL AS context_library_version,\n    NULL AS context_locale,\n    NULL AS context_os_os,\n    NULL AS context_os_version,\n    NULL AS context_os_name,\n    NULL AS context_device_type,\n    NULL AS context_time_zone,\n    NULL AS event,\n    NULL AS event_text,\n    NULL AS loaded_at,\n    NULL AS original_timestamp,\n    NULL AS received_at,\n    NULL AS sent_at,\n    NULL AS uuid_ts\n  FROM `piedotorg-production.backend_analytics.ai_intent_engine_offer`\n  \n  UNION ALL\n  \n  -- Website table with ext/AI fields as NULL\n  SELECT\n    request_id,\n    offer_id,\n    action,\n    surface,\n    is_rewards,\n    user_id,\n    id,\n    timestamp AS timestamp_frontend,\n    NULL AS outbound_url,  -- Website doesn't have outbound_url like AI\n    context_user_agent AS user_agent,\n    NULL AS ext_tag_id,  -- Website doesn't have tag_id\n    'web' AS source_type,\n    -- Website offer type classification\n    CASE \n      WHEN is_rewards = true THEN 'website_rewards'\n      WHEN is_rewards = false THEN 'website_regular'\n      ELSE 'website_unknown'\n    END AS offer_type,\n    -- Tenant fields (NULL for website)\n    NULL AS ai_tenant_id,\n    NULL AS ai_tenant_client_id,\n    NULL AS tenant_rewards_enabled,\n    -- Use website anonymous_id for counting\n    anonymous_id,\n    NULL AS referer_url,  -- Ignoring context fields per plan\n    NULL AS platform,\n    NULL AS context_app_name,\n    NULL AS context_app_version,\n    NULL AS context_browser,\n    NULL AS context_browser_version,\n    NULL AS context_device_id,\n    NULL AS context_id,\n    NULL AS context_ip,\n    NULL AS context_library_name,\n    NULL AS context_library_version,\n    context_locale,\n    NULL AS context_os_os,\n    NULL AS context_os_version,\n    NULL AS context_os_name,\n    context_device_type,\n    context_timezone AS context_time_zone,\n    event,\n    event_text,\n    loaded_at,\n    original_timestamp,\n    received_at,\n    sent_at,\n    uuid_ts\n  FROM `piedotorg-production.website_production.web_intent_engine_offer`\n)\n\nSELECT\n  TIMESTAMP_MILLIS(be.timestamp_ms) AS ts,\n  COALESCE(be.request_id, fe.request_id) request_id,\n  be.* EXCEPT(request_id, tenant_id, tenant_client_id),\n  fe.* EXCEPT(request_id, offer_id, user_id, ai_tenant_id, ai_tenant_client_id, tenant_rewards_enabled),\n  fe.offer_id as fe_offer_id,\n  fe.offer_id = be.offer_id AS offer_id_match,\n  cooldown_id IS NOT NULL AS cooldown_active,\n  cooldown_id,\n  cooldown_code,\n  cooldown_start,\n  cooldown_end,\n  scope,\n  \n  -- Campaign metadata\n  cd.active AS campaign_active,\n  cd.campaign_state,\n  cd.budget AS campaign_budget,\n  cd.campaign_created_ts,\n  cd.campaign_updated_ts,\n  cd.campaign_ended_ts,\n  cd.campaign_start_ts,\n\n  -- Computed offer_presented field  \n  be.top_offer = true OR (be.intent_engine_type IN ('AI', 'MCP') AND fe.request_id IS NOT NULL) AS offer_presented,\n\n  -- Collect an array of structs, one per placement_hash (deduplicated)\n  ARRAY_AGG(\n    STRUCT(\n      placement_hash,\n      p.template        AS template,\n      p.placementId     AS placementId,\n      p.match           AS match,\n      p.hostname\n    )\n  ) AS placements,\n  \n  -- Transaction fields for AI_AD offers\n  txn.transaction_state,\n  txn.transaction_created_ms,\n  txn.transaction_updated_ms,\n  txn.millipoints,\n  txn.adViewId,\n  txn.userId AS transaction_user_id,\n  \n  -- Composite key for distinct counting\n  CONCAT(COALESCE(be.request_id, fe.request_id), '|', be.offer_id) AS req_offer,\n  \n  -- Tenant fields (combined from backend and AI)\n  COALESCE(be.tenant_id, fe.ai_tenant_id) AS tenant_id,\n  COALESCE(be.tenant_client_id, fe.ai_tenant_client_id) AS tenant_client_id,\n  fe.tenant_rewards_enabled\n\nFROM\n  `piedotorg-production.backend_analytics.intent_engine_offer_group_match` AS be\nLEFT JOIN\n  unified_frontend_offers AS fe\nON be.request_id = fe.request_id \n  AND be.offer_id = fe.offer_id\n  -- Match on tenant_client_id for AI offers\n  AND (fe.source_type != 'ai' OR be.tenant_client_id = fe.ai_tenant_client_id)\n\nLEFT JOIN UNNEST(be.placement_hashes) AS placement_hash\n\nLEFT JOIN\n  deduplicated_placements AS p\nON\n  p.placementHash = placement_hash\n  and p.offerGroupId = be.offergroup_id\n\nLEFT JOIN \n  `piedotorg-production.backend_analytics.intent_engine_cooldown_triggered` c\nON \n  TIMESTAMP_TRUNC(TIMESTAMP_MILLIS(be.timestamp_ms), SECOND) BETWEEN cooldown_start AND cooldown_end \n  AND be.device_id = c.device_id \n  AND p.offerGroupId = be.offergroup_id\n\nLEFT JOIN\n  campaign_data cd\nON\n  be.campaign_id = cd.campaignId\n  AND be.merchant_id = cd.merchantId\n  AND (\n    DATE(TIMESTAMP_MILLIS(be.timestamp_ms)) >= DATE(cd.campaign_start_ts)\n    AND (cd.campaign_ended_ts IS NULL OR DATE(TIMESTAMP_MILLIS(be.timestamp_ms)) <= DATE(cd.campaign_ended_ts))\n  )\n\nLEFT JOIN\n  ai_ad_transactions txn\nON\n  be.offer_id = txn.offer_id\n  AND be.request_id = txn.request_id\n  AND be.intent_engine_type IN ('AI', 'MCP')\n\nGROUP BY\n  ALL ",
          "dependencies": [
            "campaigns_placements",
            "campaigns_campaigns",
            "transactions_adviews",
            "ext_intent_engine_offer",
            "ai_intent_engine_offer",
            "web_intent_engine_offer",
            "intent_engine_offer_group_match",
            "intent_engine_cooldown_triggered"
          ]
        }
      },
      {
        "id": "offer_template_hostname_day",
        "model": {
          "name": "offer_template_hostname_day",
          "filePath": "intent_engine/offer_template_hostname_day.sqlx",
          "type": "table",
          "schema": "intent_engine_dev",
          "tags": [
            "intent_engine",
            "marts",
            "offers",
            "aggregated"
          ],
          "description": "Daily aggregation of offer interactions by first template and first hostname for active campaigns",
          "config": {
            "type": "table",
            "schema": "intent_engine_dev",
            "tags": [
              "intent_engine",
              "marts",
              "offers",
              "aggregated"
            ],
            "description": "Daily aggregation of offer interactions by first template and first hostname for active campaigns",
            "bigquery": {
              "partitionBy": "dt",
              "clusterBy": [
                "first_template",
                "first_hostname",
                "dt"
              ]
            }
          },
          "sqlContent": "\n\nSELECT\n  DATE(ts) AS dt,\n  \n  -- Extract first template and hostname, handling NULLs explicitly\n  CASE \n    WHEN ARRAY_LENGTH(placements) > 0 THEN placements[OFFSET(0)].template\n    ELSE NULL \n  END AS first_template,\n  \n  CASE \n    WHEN ARRAY_LENGTH(placements) > 0 THEN placements[OFFSET(0)].hostname  \n    ELSE NULL\n  END AS first_hostname,\n  \n  -- Show metrics (prompt/login_prompt surfaces only, top offers)\n  COUNT(CASE WHEN action = 'show' AND surface IN ('prompt', 'login_prompt') AND top_offer = true THEN 1 END) AS shows,\n  COUNT(DISTINCT CASE WHEN action = 'show' AND surface IN ('prompt', 'login_prompt') AND top_offer = true THEN device_id END) AS show_devices,\n  COUNT(DISTINCT CASE WHEN action = 'show' AND surface IN ('prompt', 'login_prompt') AND top_offer = true THEN anonymous_id END) AS show_anonymous_ids,\n  \n  -- Click metrics (prompt/login_prompt surfaces only, top offers)\n  COUNT(CASE WHEN action = 'click' AND surface IN ('prompt', 'login_prompt') AND top_offer = true THEN 1 END) AS clicks,\n  COUNT(DISTINCT CASE WHEN action = 'click' AND surface IN ('prompt', 'login_prompt') AND top_offer = true THEN device_id END) AS click_devices,\n  COUNT(DISTINCT CASE WHEN action = 'click' AND surface IN ('prompt', 'login_prompt') AND top_offer = true THEN anonymous_id END) AS click_anonymous_ids,\n  \n  -- Redeem metrics (prompt/login_prompt surfaces only, top offers)\n  COUNT(CASE WHEN action = 'redeem' AND surface IN ('prompt', 'login_prompt') AND top_offer = true THEN 1 END) AS redeems,\n  COUNT(DISTINCT CASE WHEN action = 'redeem' AND surface IN ('prompt', 'login_prompt') AND top_offer = true THEN device_id END) AS redeem_devices,\n  COUNT(DISTINCT CASE WHEN action = 'redeem' AND surface IN ('prompt', 'login_prompt') AND top_offer = true THEN anonymous_id END) AS redeem_anonymous_ids,\n  \n  -- Error metrics (error_prompt surface, top offers)\n  COUNT(CASE WHEN action = 'show' AND surface = 'error_prompt' AND top_offer = true THEN 1 END) AS errors,\n  COUNT(DISTINCT CASE WHEN action = 'show' AND surface = 'error_prompt' AND top_offer = true THEN device_id END) AS error_devices,\n  COUNT(DISTINCT CASE WHEN action = 'show' AND surface = 'error_prompt' AND top_offer = true THEN anonymous_id END) AS error_anonymous_ids,\n  \n  COUNT(*) AS total_events,\n  \n  -- Calculate rates (handle division by zero)\n  SAFE_DIVIDE(COUNT(CASE WHEN action = 'click' AND surface IN ('prompt', 'login_prompt') AND top_offer = true THEN 1 END), \n              COUNT(CASE WHEN action = 'show' AND surface IN ('prompt', 'login_prompt') AND top_offer = true THEN 1 END)) AS click_through_rate,\n  SAFE_DIVIDE(COUNT(CASE WHEN action = 'redeem' AND surface IN ('prompt', 'login_prompt') AND top_offer = true THEN 1 END), \n              COUNT(CASE WHEN action = 'show' AND surface IN ('prompt', 'login_prompt') AND top_offer = true THEN 1 END)) AS redeem_rate\n\nFROM `piedotorg-production.intent_engine_dev.offer_expanded_view`\n\nWHERE \n  -- Filter to active campaigns only\n  campaign_active = true\n  AND campaign_state = 'ACTIVE'\n  \nGROUP BY\n  dt,\n  first_template,\n  first_hostname",
          "dependencies": [
            "offer_expanded_view"
          ]
        }
      },
      {
        "id": "offer_unified_view",
        "model": {
          "name": "offer_unified_view",
          "filePath": "intent_engine/offer_unified_view.sqlx",
          "type": "table",
          "schema": "intent_engine_dev",
          "tags": [
            "intent_engine",
            "unified_view",
            "offers",
            "funnel"
          ],
          "description": "Unified table of the complete offer funnel from backend consideration through frontend actions to conversion. Each row represents one action in the funnel.",
          "config": {
            "type": "table",
            "schema": "intent_engine_dev",
            "tags": [
              "intent_engine",
              "unified_view",
              "offers",
              "funnel"
            ],
            "description": "Unified table of the complete offer funnel from backend consideration through frontend actions to conversion. Each row represents one action in the funnel.",
            "bigquery": {
              "partitionBy": "DATE(event_ts)",
              "clusterBy": [
                "action",
                "merchant_id",
                "campaign_id"
              ]
            }
          },
          "sqlContent": "\n\n-- Unified offer funnel view combining all stages\nWITH \n-- 1. Backend Consideration Stage\nbackend_consideration AS (\n  SELECT\n    'backend_match' AS source_table,\n    action,\n    CAST(NULL AS STRING) AS attribution_model,\n    \n    -- Timestamps\n    backend_ts AS event_ts,\n    backend_ts,\n    \n    -- Core Identifiers\n    request_id,\n    offer_id,\n    req_offer,\n    \n    -- Campaign & Merchant\n    campaign_id,\n    merchant_id,\n    campaign_boost,\n    campaign_active,\n    campaign_state,\n    campaign_budget,\n    \n    -- User Identifiers\n    user_id,\n    CAST(NULL AS STRING) AS anonymous_id,\n    device_id,\n    \n    -- Offer Details\n    offer_content,\n    offer_click_url,\n    offer_cta,\n    offer_award,\n    offer_distribution,\n    top_offer,\n    \n    -- Offer Group Details\n    offergroup_id,\n    offergroup_min_bid,\n    offergroup_max_bid,\n    offergroup_bid_type,\n    \n    -- Tenant Details\n    tenant_id,\n    tenant_client_id,\n    \n    -- Platform & Source\n    intent_engine_type,\n    CAST(NULL AS STRING) AS source_type,\n    client,\n    \n    -- Frontend Specific (NULL for backend except placement info)\n    CAST(NULL AS INT64) AS tag_id,\n    CAST(NULL AS INT64) AS ext_tag_id,\n    CAST(NULL AS STRING) AS surface,\n    CAST(NULL AS STRING) AS outbound_url,\n    first_placement_template,\n    first_placement_id,\n    first_placement_match,\n    first_placement_hostname,\n    placement_count,\n    \n    -- Search context\n    keywords,\n    \n    -- Conversion Specific (NULL for backend)\n    CAST(NULL AS STRING) AS transaction_id,\n    CAST(NULL AS DATETIME) AS transaction_ts,\n    CAST(NULL AS STRING) AS transaction_type,\n    CAST(NULL AS FLOAT64) AS external_sale_value_dollars,\n    CAST(NULL AS FLOAT64) AS external_commission_dollars,\n    CAST(NULL AS INT64) AS millipoints,\n    CAST(NULL AS STRING) AS attribution_confidence,\n    CAST(NULL AS INT64) AS attribution_window_hours,\n    CAST(NULL AS INT64) AS time_to_conversion_hours\n    \n  FROM `piedotorg-production.fact_tables_dev.fact_intent_engine_offer_group_match`\n),\n\n-- 2. Frontend Actions Stage (impressions, clicks, dismissals)\nfrontend_actions AS (\n  SELECT\n    'frontend_offer' AS source_table,\n    -- Use surface-specific action names for error and login prompts\n    CASE \n      WHEN surface = 'error_prompt' THEN 'error_prompt'\n      WHEN surface = 'login_prompt' THEN 'login_prompt'\n      ELSE action\n    END AS action,\n    CAST(NULL AS STRING) AS attribution_model,\n    \n    -- Timestamps\n    event_ts,\n    backend_ts,\n    \n    -- Core Identifiers\n    request_id,\n    offer_id,\n    req_offer,\n    \n    -- Campaign & Merchant\n    campaign_id,\n    merchant_id,\n    campaign_boost,\n    campaign_active,\n    campaign_state,\n    campaign_budget,\n    \n    -- User Identifiers\n    user_id,\n    anonymous_id,\n    device_id,\n    \n    -- Offer Details\n    offer_content,\n    CAST(NULL AS STRING) AS offer_click_url,\n    offer_cta,\n    offer_award,\n    CAST(NULL AS INT64) AS offer_distribution,\n    top_offer,\n    \n    -- Offer Group Details\n    offergroup_id,\n    offergroup_min_bid,\n    offergroup_max_bid,\n    offergroup_bid_type,\n    \n    -- Tenant Details\n    tenant_id,\n    tenant_client_id,\n    \n    -- Platform & Source\n    intent_engine_type,\n    source_type,\n    CAST(NULL AS STRING) AS client,\n    \n    -- Frontend Specific\n    tag_id,\n    ext_tag_id,\n    surface,\n    outbound_url,\n    first_placement_template,\n    first_placement_id,\n    first_placement_match,\n    first_placement_hostname,\n    placement_count,\n    \n    -- Search context\n    keywords,  -- Keywords from mapping via int_fe_offer\n    \n    -- Conversion Specific (NULL for frontend)\n    CAST(NULL AS STRING) AS transaction_id,\n    CAST(NULL AS DATETIME) AS transaction_ts,\n    CAST(NULL AS STRING) AS transaction_type,\n    CAST(NULL AS FLOAT64) AS external_sale_value_dollars,\n    CAST(NULL AS FLOAT64) AS external_commission_dollars,\n    CAST(NULL AS INT64) AS millipoints,\n    CAST(NULL AS STRING) AS attribution_confidence,\n    CAST(NULL AS INT64) AS attribution_window_hours,\n    CAST(NULL AS INT64) AS time_to_conversion_hours\n    \n  FROM `piedotorg-production.fact_tables_dev.int_fe_offer`\n),\n\n-- 3. Conversion Stage (attributed transactions)\nconversions AS (\n  SELECT\n    'attribution_model' AS source_table,\n    'conversion' AS action,\n    attribution_model,\n    \n    -- Timestamps\n    CAST(transaction_ts AS TIMESTAMP) AS event_ts,\n    CAST(attribution_event_ts AS TIMESTAMP) AS backend_ts,\n    \n    -- Core Identifiers\n    request_id,\n    offer_id,\n    req_offer,\n    \n    -- Campaign & Merchant\n    campaign_id,\n    merchant_id,\n    CAST(NULL AS INT64) AS campaign_boost,\n    CAST(NULL AS BOOLEAN) AS campaign_active,\n    CAST(NULL AS STRING) AS campaign_state,\n    CAST(NULL AS INT64) AS campaign_budget,\n    \n    -- User Identifiers\n    user_id,\n    anonymous_id,\n    device_id,\n    \n    -- Offer Details\n    offer_content,\n    CAST(NULL AS STRING) AS offer_click_url,\n    CAST(NULL AS STRING) AS offer_cta,\n    offer_award,\n    CAST(NULL AS INT64) AS offer_distribution,\n    CAST(NULL AS BOOLEAN) AS top_offer,\n    \n    -- Offer Group Details (NULL for conversions)\n    CAST(NULL AS STRING) AS offergroup_id,\n    CAST(NULL AS INT64) AS offergroup_min_bid,\n    CAST(NULL AS INT64) AS offergroup_max_bid,\n    CAST(NULL AS STRING) AS offergroup_bid_type,\n    \n    -- Tenant Details\n    tenant_id,\n    CAST(NULL AS STRING) AS tenant_client_id,\n    \n    -- Platform & Source\n    intent_engine_type,\n    source_type,\n    CAST(NULL AS STRING) AS client,\n    \n    -- Frontend Specific (conversions have placement from click/view events)\n    CAST(NULL AS INT64) AS tag_id,\n    ext_tag_id,\n    CAST(NULL AS STRING) AS surface,\n    CAST(NULL AS STRING) AS outbound_url,\n    first_placement_template,\n    first_placement_id,\n    first_placement_match,\n    first_placement_hostname,\n    placement_count,\n    \n    -- Search context\n    CAST(NULL AS STRING) AS keywords,  -- Conversions don't have keywords directly\n    \n    -- Conversion Specific\n    transaction_id,\n    transaction_ts,\n    transaction_type,\n    external_sale_value_dollars,\n    external_commission_dollars,\n    millipoints,\n    attribution_confidence,\n    attribution_window_hours,\n    time_to_conversion_hours\n    \n  FROM `piedotorg-production.fact_tables_dev.fact_offer_attribution_models`\n)\n\n-- Union all stages\nSELECT * FROM backend_consideration\nUNION ALL\nSELECT * FROM frontend_actions\nUNION ALL\nSELECT * FROM conversions",
          "dependencies": [
            "fact_intent_engine_offer_group_match",
            "int_fe_offer",
            "fact_offer_attribution_models"
          ]
        }
      },
      {
        "id": "transactions_expanded_view",
        "model": {
          "name": "transactions_expanded_view",
          "filePath": "sources/transactions_expanded_view.sqlx",
          "type": "table",
          "schema": "data_science_dev",
          "tags": [
            "transactions",
            "sources",
            "commerce"
          ],
          "description": "Table of affiliate transactions with enhanced data joins and enrichments - converting to table",
          "config": {
            "type": "table",
            "schema": "data_science_dev",
            "tags": [
              "transactions",
              "sources",
              "commerce"
            ],
            "description": "Table of affiliate transactions with enhanced data joins and enrichments - converting to table",
            "bigquery": {
              "partitionBy": "DATE(created_coalesce_ts)",
              "clusterBy": [
                "merchantId",
                "campaignId",
                "type"
              ]
            }
          },
          "sqlContent": "\n\n-- Affiliate transactions expanded view\n-- Debug: Migrated from BigQuery data_science.transactions_expanded_view\nWITH\n  base_v2_fe_data as (\n    select \n    distinct \n    anonymous_id,\n    device_id,\n    user_id userId,\n    ext_tag_id,\n    offer_Id, -- this is offer_id linked to campaigns offergroups etc.\n    request_id requestId,\n    campaign_id,\n    top_offer,\n    \"v2\" as offers_version,\n  --  null as keyword_matched\n    from `piedotorg-production.intent_engine_dev.offer_expanded_view`\n   -- where top_offer  -- since we're only interested in top offers that are surfaced\n  ),\n\n  base_tag_cte AS (\n  SELECT\n    ext_tag_id,\n    requestid as tagged_request_Id,\n    offer_id as tagged_offer_id, -- tagged offer_id\n    campaign_id as tagged_campaign_id, --tagged campaign_id\n    timestamp AS tag_timestamp,\n    context_app_name,\n    context_app_version,\n    url,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt\n  FROM\n    `piedotorg-production.extension_production_views.ext_affiliate_tag` left join base_v2_fe_data as v2_fe_data\n    using (ext_tag_id)\n    where top_offer or top_offer is null \n  GROUP BY\n    ALL ),\n\n  base_v1_fe_data as (\n    SELECT\n      DISTINCT anonymous_id,\n--    device_id,\n    user_id userId,\n    offer_Id AS adofferId, -- Q: is this how V1 rewards are linked to transactions_adoffers?\n    \"v1\" as offers_version,\n    CASE WHEN metadata_keyword_matched IS NOT NULL THEN TRUE ELSE FALSE END AS keyword_matched\n  FROM\n    `piedotorg-production.extension_production_views.ext_rewards_transaction`\n  WHERE\n    action IN (\"click\", \"login\") \n  ),\n\n    \n  base_redirect_cte AS (\n  SELECT\n    anonymousid anonymous_id,\n    \"standard\" AS redirect_type,\n    subsrc,\n    extTagId ext_tag_id,\n    CAST(tagId AS INT64) AS tag_id,  -- AI offers use tagId\n    trackId,\n    affiliateLinkId,\n    sessionid,\n    CAST(NULL AS string) AS productid,\n    feature,\n    merchantId,\n    IFNULL(timestamp, TIMESTAMP_MILLIS(sessionid)) AS redirect_timestamp,\n    ROW_NUMBER() OVER (PARTITION BY trackId ORDER BY timestamp DESC) AS redirect_row_num\n  FROM\n    `piedotorg-production.backend_analytics.outbound_redirect`\n  QUALIFY\n    redirect_row_num = 1 ),\n    \n  base_product_redirect_cte AS (\n  SELECT\n    anonymousid anonymous_id,\n    \"product\" AS redirect_type,\n    subsrc,\n    CAST(extTagId AS INT64) ext_tag_id,\n    CAST(tagId AS INT64) AS tag_id,  -- AI offers use tagId\n    trackId,\n    affiliateLinkId,\n    CAST(sessionid AS int64) sessionId,\n    productid,\n    feature,\n    merchantId,\n    IFNULL(timestamp, TIMESTAMP_MILLIS(sessionid)) AS redirect_timestamp,\n    ROW_NUMBER() OVER (PARTITION BY trackId ORDER BY timestamp DESC) AS redirect_row_num\n  FROM\n    `piedotorg-production.backend_analytics.product_outbound_redirect`\n  QUALIFY\n    redirect_row_num = 1 ),\n    \n  all_redirect_cte AS (\n  SELECT\n    *\n  FROM\n    base_redirect_cte\n  UNION ALL\n  SELECT\n    *\n  FROM\n    base_product_redirect_cte),\n    \n  base_aff_cte AS (\n  SELECT\n    transactionId,\n    trackId,\n    TIMESTAMP_MILLIS(externalCreated) AS aff_trx_created_ts,\n    externalStatus,\n    externalCommission,\n    externalSaleValue,\n    provider\n  FROM\n    `piedotorg-production.analytics_etl.transactions_affiliatetransactions` ),\n    \n  base_trx_cte AS (\n  SELECT\n    type,\n    userId,\n    state,\n    millipoints,\n    TIMESTAMP_MILLIS(confirmed) AS confirmed_ts,\n    TIMESTAMP_MILLIS(created) AS trx_trx_created_ts,\n    merchantId,\n    transactionId\n  FROM\n    `piedotorg-production.analytics_etl.transactions_transactions`),\n    \n  offer_campaign_data AS (\n  SELECT\n    campaignId,\n    budget,\n    merchantId,\n    MIN(TIMESTAMP_MILLIS(created)) AS campaign_created_ts,\n    MAX(TIMESTAMP_MILLIS(updated)) AS campaign_updated_ts,\n    MAX(CASE\n        WHEN active = FALSE THEN TIMESTAMP_MILLIS(updated)\n    END\n      ) AS campaign_ended_ts,\n    MAX(active) AS active\n  FROM\n    `piedotorg-production.analytics_etl.transactions_campaigns`\n  GROUP BY\n    ALL ),\n    \n  base_offers_cte AS (\n  SELECT\n    DISTINCT \n    -- Fields from transactions_adoffers table\n    adOfferType, -- this will be campaign_v2 for v2 Q: what is it for v1?\n    adOfferId, --individual transaction adofferId\n    millipoints, --this is millipoints burned from user balance\n    requestId,\n    offerId,\n    offerGroupId,\n    COALESCE(v1_fe_data.keyword_matched, FALSE) AS keyword_matched,\n    transactionId,\n    state AS adofferstate,\n    COALESCE(campaignId,campaignIdV2) AS campaignId,\n   -- budgetUsedInMillipoints, -- deprecated, \n    TIMESTAMP_MILLIS(created) AS ad_offers_created_ts,\n    TIMESTAMP_MILLIS(claimed) AS offer_claimed_ts,\n    -- Fields from offer_campaign_data table\n    campaign_created_ts,\n    campaign_ended_ts,\n    active,\n    COALESCE(v1_fe_data.anonymous_id, v2_fe_data.anonymous_id) AS anonymous_id, -- we pull this from ext_rewards_transaction for v1 rewards transactions\n    v2_fe_data.device_id AS device_id,\n    userId\n  FROM\n    `piedotorg-production.analytics_etl.transactions_adoffers` ta\n  LEFT JOIN\n    offer_campaign_data\n  USING\n    (campaignId)\n  LEFT JOIN\n    base_v1_fe_data as v1_fe_data\n  USING\n    (adofferId, userId) \n         LEFT JOIN base_v2_fe_data as v2_fe_data\n     USING (requestId, userId)\n  ),\n  aff_trx_join AS (\n  SELECT\n    * EXCEPT(merchantId),\n    COALESCE(all_redirect_cte.merchantid, base_trx_cte.merchantid) AS merchantId\n  FROM\n    base_aff_cte\n  LEFT JOIN\n    all_redirect_cte\n  USING\n    (trackId)\n  FULL OUTER JOIN\n    base_trx_cte\n  USING\n    (transactionId)\n  LEFT JOIN\n    base_tag_cte\n  USING\n    (ext_tag_id) ),\n    \n  user_id_anon_map AS (\n  SELECT\n    DISTINCT most_common_anonymous_id most_common_anonymous_id,\n    user_id userid\n  FROM\n    `piedotorg-production.users.user_anon_mapping`),\n    \n  aff_offers_join AS (\n  SELECT\n    * EXCEPT(anonymous_id, millipoints),\n    COALESCE(aff_trx_join.millipoints) millipoints,\n    coalesce(base_offers_cte.millipoints) as balance_burned_millipoints, -- Note we'll need to track user balance burns a bit better especially for AD_VIEW transactions\n    COALESCE(aff_trx_join.anonymous_id, base_offers_cte.anonymous_id, user_id_anon_map.most_common_anonymous_id) AS anonymous_id,\n    COALESCE(aff_trx_created_ts, offer_claimed_ts, trx_trx_created_ts, redirect_timestamp) AS created_coalesce_ts\n  FROM\n    aff_trx_join\n  FULL OUTER JOIN\n    base_offers_cte\n  USING\n    (transactionId, userId) \n  LEFT JOIN \n    user_id_anon_map \n  USING \n    (userId) )\n\n-- Debug: Final SELECT with alias fields for backward compatibility\nSELECT\n  * EXCEPT(ext_tag_id, tag_id),\n  -- Coalesce ext_tag_id and tag_id for backward compatibility\n  COALESCE(ext_tag_id, tag_id) AS ext_tag_id,\n  tag_id,  -- Keep tag_id separate for AI-specific analysis\n  created_coalesce_ts AS timestamp,\n  userId user_id,\n  merchantId merchant_id\nFROM\n  aff_offers_join ",
          "dependencies": [
            "offer_expanded_view",
            "ext_affiliate_tag",
            "ext_rewards_transaction",
            "outbound_redirect",
            "product_outbound_redirect",
            "transactions_affiliatetransactions",
            "transactions_transactions",
            "transactions_campaigns",
            "transactions_adoffers",
            "user_anon_mapping"
          ]
        }
      },
      {
        "id": "unified_user_feedback",
        "model": {
          "name": "unified_user_feedback",
          "filePath": "unified_user_feedback.sqlx",
          "type": "table",
          "schema": "data_science_dev",
          "tags": [
            "feedback",
            "analytics",
            "users"
          ],
          "description": "Unified view of user feedback from uninstall surveys, bug reports, extension feedback, and low-rated reviews",
          "config": {
            "type": "table",
            "schema": "data_science_dev",
            "tags": [
              "feedback",
              "analytics",
              "users"
            ],
            "description": "Unified view of user feedback from uninstall surveys, bug reports, extension feedback, and low-rated reviews",
            "bigquery": {
              "partitionBy": "DATE(timestamp)",
              "clusterBy": [
                "anonymous_id",
                "feedback_source"
              ]
            }
          },
          "sqlContent": "\n\nWITH processed_uninstall AS (\n  SELECT\n    id as feedback_id,\n    CASE \n      WHEN extension_type = 'adblock' THEN extension_adblock_anonymous_id\n      WHEN extension_type = 'shopping' THEN extension_shopping_anonymous_id\n      WHEN extension_type = 'unified' THEN extension_unified_anonymous_id\n      ELSE anonymous_id  -- fallback\n    END as anonymous_id,\n    CONCAT('extension-', extension_type) as context_app_name,\n    'uninstall' as feedback_source,\n    timestamp,\n    additional_info as feedback_text,\n    cast(selected_options as STRING) as feedback_category,\n    version as context_app_version,\n    platform,\n    context_page_referrer as referrer_url,\n    CAST(version AS STRING) as app_version,\n    context_user_agent as user_agent,\n    `piedotorg-production.data_science.parse_useragent`(context_user_agent).browser.name as context_browser\n  FROM `piedotorg-production.website_production.web_uninstall`\n  WHERE action = \"submit\"\n),\n\nprocessed_bug_reports AS (\n  SELECT\n    id as feedback_id,\n    -- CASE \n    --   WHEN extension_type = 'adblock' THEN extension_adblock_anonymous_id\n    --   WHEN extension_type = 'shopping' THEN extension_shopping_anonymous_id\n    --   WHEN extension_type = 'unified' THEN extension_unified_anonymous_id\n    --   ELSE anonymous_id  -- fallback\n    -- END \n    --until we have the proper way\n    cast(coalesce(extension_adblock_anonymous_id,extension_shopping_anonymous_id,extension_unified_anonymous_id) as string) as anonymous_id,\n   -- CONCAT('extension-', extension_type)\n    cast(null as string) as context_app_name,\n    'bug_report' as feedback_source,\n    timestamp,\n    additional_info as feedback_text,\n    selected_option as feedback_category,\n    'null' as context_app_version,\n    context_user_agent_data_platform as platform,\n    context_page_referrer as referrer_url,\n    CAST(NULL AS STRING) as app_version,\n    context_user_agent as user_agent,\n    `piedotorg-production.data_science.parse_useragent`(context_user_agent).browser.name as context_browser\n  FROM `piedotorg-production.website_production.web_report_bug`\n  WHERE action = \"submit\"\n),\n\nprocessed_extension_feedback AS (\n  SELECT\n    id as feedback_id,\n    anonymous_id,\n    context_app_name,  -- already in the correct format\n    concat('ext_feedback|', ifnull(surface,\"\"))  as feedback_source,\n    timestamp,\n    text as feedback_text,\n    type as feedback_category,\n    context_app_version,\n    platform,\n    referer_url as referrer_url,\n    CAST(context_app_version AS STRING) as app_version,\n    context_user_agent as user_agent,\n    `piedotorg-production.data_science.parse_useragent`(context_user_agent).browser.name as context_browser\n  FROM `piedotorg-production.extension_production_views.ext_feedback`\n),\n\nprocessed_reviews AS (\n  SELECT\n    id as feedback_id,\n    '' as anonymous_id,  -- Reviews don't have anonymous_id\n    CONCAT('extension-', extension_type) as context_app_name,\n    'low_rated_review' as feedback_source,\n    timestamp,\n    text as feedback_text,\n    CAST(rating AS STRING) as feedback_category,\n    'null' as context_app_version,\n    platform,\n    cast(NULL as string) as referrer_url,\n    cast(NULL as string)  as app_version,\n    cast(NULL as string) user_agent,\n    cast(NULL as string) as context_browser  -- Reviews don't have user agent\n  FROM `piedotorg-production.extensions_data.reviews`\n  WHERE rating <= 3\n)\n\nSELECT * FROM processed_uninstall\nUNION ALL\nSELECT * FROM processed_bug_reports\nUNION ALL\nSELECT * FROM processed_extension_feedback \nUNION ALL\nSELECT * FROM processed_reviews ",
          "dependencies": [
            "web_uninstall",
            "web_report_bug",
            "ext_feedback",
            "reviews"
          ]
        }
      },
      {
        "id": "f_user_commerce",
        "model": {
          "name": "f_user_commerce",
          "filePath": "user_features/f_user_commerce.sqlx",
          "type": "incremental",
          "schema": "user_features_dev",
          "tags": [
            "users",
            "features",
            "commerce"
          ],
          "description": "Daily aggregated commerce activity including affiliate tags, order confirmations, and redirects",
          "config": {
            "type": "incremental",
            "schema": "user_features_dev",
            "tags": [
              "users",
              "features",
              "commerce"
            ],
            "description": "Daily aggregated commerce activity including affiliate tags, order confirmations, and redirects",
            "uniqueKey": [
              "dt",
              "anonymous_id"
            ],
            "bigquery": {
              "partitionBy": "dt",
              "updatePartitionFilter": "dt >= date_sub(current_date(), interval 3 day)"
            }
          },
          "sqlContent": "\n\n-- Feature table: Daily commerce aggregations per user\n-- Debug: Processing affiliate tags, confirmations, and redirects\nWITH affiliate_tags_base AS (\n  SELECT\n    anonymous_id,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt,\n    COUNT(*) AS total_affiliate_tags,\n    COUNT(DISTINCT session_id) AS total_tag_sessions\n  FROM `piedotorg-production.extension_production_views.ext_affiliate_tag`\n  \n  \n  \n  GROUP BY anonymous_id, dt\n),\n\norder_confirmations_base AS (\n  SELECT\n    anonymous_id,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt,\n    COUNT(*) AS total_order_confirmations,\n    COUNT(DISTINCT session_id) AS order_confirmation_sessions,\n    COUNTIF(tagged IS TRUE) AS tagged_order_confirmations\n  FROM `piedotorg-production.extension_production_views.ext_order_confirmation`\n  \n  \n  \n  GROUP BY anonymous_id, dt\n),\n\nredirects_base AS (\n  SELECT\n    anonymousid AS anonymous_id,\n    DATE(IFNULL(timestamp, TIMESTAMP_MILLIS(sessionid)), \"America/Los_Angeles\") AS dt,\n    \n    -- Overall redirect metrics\n    COUNT(*) AS total_redirects,\n    COUNT(DISTINCT sessionid) AS total_redirect_sessions,\n    \n    -- Redirect source breakdown\n    COUNTIF(subsrc = \"rewards_transaction_popup\") AS rewards_transaction_popup_redirects,\n    COUNTIF(subsrc = \"coupon_popup\") AS coupon_popup_shopping_redirects,\n    COUNTIF(subsrc = \"cashback_popup_adblock\") AS cashback_popup_adblock_redirects,\n    COUNTIF(subsrc = \"rewards_popup\") AS rewards_popup_shopping_redirects,\n    COUNTIF(subsrc = \"popover_coupon_list\") AS popover_coupon_list_redirects,\n    COUNTIF(subsrc = \"pie_offer_login_retargeting\") AS login_retargeting_redirects,\n    COUNTIF(subsrc = \"standdown\") AS standdown_redirects\n    \n  FROM `piedotorg-production.backend_analytics.outbound_redirect`\n  \n  \n  \n  GROUP BY anonymous_id, dt\n)\n\n-- Debug: Combining all commerce features\nSELECT\n  COALESCE(\n    affiliate_tags_base.anonymous_id, \n    order_confirmations_base.anonymous_id, \n    redirects_base.anonymous_id\n  ) AS anonymous_id,\n  COALESCE(\n    affiliate_tags_base.dt, \n    order_confirmations_base.dt, \n    redirects_base.dt\n  ) AS dt,\n  \n  -- Affiliate tag metrics\n  COALESCE(total_affiliate_tags, 0) AS total_affiliate_tags,\n  COALESCE(total_tag_sessions, 0) AS total_tag_sessions,\n  \n  -- Order confirmation metrics\n  COALESCE(total_order_confirmations, 0) AS total_order_confirmations,\n  COALESCE(order_confirmation_sessions, 0) AS order_confirmation_sessions,\n  COALESCE(tagged_order_confirmations, 0) AS tagged_order_confirmations,\n  \n  -- Redirect metrics\n  COALESCE(total_redirects, 0) AS total_redirects,\n  COALESCE(total_redirect_sessions, 0) AS total_redirect_sessions,\n  COALESCE(rewards_transaction_popup_redirects, 0) AS rewards_transaction_popup_redirects,\n  COALESCE(coupon_popup_shopping_redirects, 0) AS coupon_popup_shopping_redirects,\n  COALESCE(cashback_popup_adblock_redirects, 0) AS cashback_popup_adblock_redirects,\n  COALESCE(rewards_popup_shopping_redirects, 0) AS rewards_popup_shopping_redirects,\n  COALESCE(popover_coupon_list_redirects, 0) AS popover_coupon_list_redirects,\n  COALESCE(login_retargeting_redirects, 0) AS login_retargeting_redirects,\n  COALESCE(standdown_redirects, 0) AS standdown_redirects\n\nFROM affiliate_tags_base\nFULL OUTER JOIN order_confirmations_base\n  USING (anonymous_id, dt)\nFULL OUTER JOIN redirects_base\n  USING (anonymous_id, dt) ",
          "dependencies": [
            "ext_affiliate_tag",
            "ext_order_confirmation",
            "outbound_redirect"
          ],
          "uniqueKey": [
            "dt",
            "anonymous_id"
          ]
        }
      },
      {
        "id": "f_user_events",
        "model": {
          "name": "f_user_events",
          "filePath": "user_features/f_user_events.sqlx",
          "type": "incremental",
          "schema": "user_features_dev",
          "tags": [
            "users",
            "features",
            "events"
          ],
          "description": "Daily aggregated user events including standdowns, ad metrics, and settings",
          "config": {
            "type": "incremental",
            "schema": "user_features_dev",
            "tags": [
              "users",
              "features",
              "events"
            ],
            "description": "Daily aggregated user events including standdowns, ad metrics, and settings",
            "uniqueKey": [
              "dt",
              "anonymous_id"
            ],
            "bigquery": {
              "partitionBy": "dt",
              "updatePartitionFilter": "dt >= date_sub(current_date(), interval 3 day)"
            }
          },
          "sqlContent": "\n\n-- Feature table: Daily event aggregations per user\n-- Debug: Processing standdowns, ad metrics, and user settings\nWITH standdowns_base AS (\n  SELECT\n    anonymous_id,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt,\n    COUNT(*) AS total_standdowns,\n    COUNTIF(standdown_type = \"stop\") AS stop_standdowns,\n    COUNTIF(standdown_type = \"notag\") AS notag_standdowns,\n    COUNTIF(standdown_type = \"suppress\") AS suppress_standdowns\n  FROM `piedotorg-production.extension_production_views.ext_standdown_detected`\n  \n  \n  \n  GROUP BY anonymous_id, dt\n),\n\nad_metrics_base AS (\n  SELECT\n    anonymous_id,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt,\n    COUNT(*) AS total_pages_w_ads_seen,\n    SUM(ad_placements_seen) AS total_ad_placements_seen,\n    SUM(pixels_used_by_ads_total) AS total_pixels_seen\n  FROM `piedotorg-production.extension_production_views.ext_device_ad_metrics_rollup`\n  \n  \n  \n  GROUP BY anonymous_id, dt\n),\n\nuser_settings_base AS (\n  -- Debug: Getting latest user settings per day (last value wins)\n  SELECT\n    anonymous_id,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt,\n    LAST_VALUE(other_adblockers) OVER (\n      PARTITION BY anonymous_id, DATE(timestamp, \"America/Los_Angeles\") \n      ORDER BY timestamp ASC \n      ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING\n    ) AS other_adblockers\n  FROM `piedotorg-production.extension_production_views.ext_user_settings`\n  WHERE other_adblockers IS NOT NULL -- only rows with actual values\n  \n  \n  \n  QUALIFY ROW_NUMBER() OVER (\n    PARTITION BY anonymous_id, DATE(timestamp, \"America/Los_Angeles\") \n    ORDER BY timestamp DESC\n  ) = 1\n)\n\n-- Debug: Combining all event features\nSELECT\n  COALESCE(\n    standdowns_base.anonymous_id, \n    ad_metrics_base.anonymous_id, \n    user_settings_base.anonymous_id\n  ) AS anonymous_id,\n  COALESCE(\n    standdowns_base.dt, \n    ad_metrics_base.dt, \n    user_settings_base.dt\n  ) AS dt,\n  \n  -- Standdown metrics\n  COALESCE(total_standdowns, 0) AS total_standdowns,\n  COALESCE(stop_standdowns, 0) AS stop_standdowns,\n  COALESCE(notag_standdowns, 0) AS notag_standdowns,\n  COALESCE(suppress_standdowns, 0) AS suppress_standdowns,\n  \n  -- Ad metrics\n  COALESCE(total_pages_w_ads_seen, 0) AS total_pages_w_ads_seen,\n  COALESCE(total_ad_placements_seen, 0) AS total_ad_placements_seen,\n  COALESCE(total_pixels_seen, 0) AS total_pixels_seen,\n  \n  -- User settings\n  user_settings_base.other_adblockers\n\nFROM standdowns_base\nFULL OUTER JOIN ad_metrics_base\n  USING (anonymous_id, dt)\nFULL OUTER JOIN user_settings_base\n  USING (anonymous_id, dt) ",
          "dependencies": [
            "ext_standdown_detected",
            "ext_device_ad_metrics_rollup",
            "ext_user_settings"
          ],
          "uniqueKey": [
            "dt",
            "anonymous_id"
          ]
        }
      },
      {
        "id": "f_user_heartbeats",
        "model": {
          "name": "f_user_heartbeats",
          "filePath": "user_features/f_user_heartbeats.sqlx",
          "type": "incremental",
          "schema": "user_features_dev",
          "tags": [
            "users",
            "features",
            "events"
          ],
          "description": "Daily aggregated heartbeat data per user including device tracking and app versions",
          "config": {
            "type": "incremental",
            "schema": "user_features_dev",
            "tags": [
              "users",
              "features",
              "events"
            ],
            "description": "Daily aggregated heartbeat data per user including device tracking and app versions",
            "uniqueKey": [
              "dt",
              "anonymous_id"
            ],
            "bigquery": {
              "partitionBy": "dt",
              "updatePartitionFilter": "dt >= date_sub(current_date(), interval 3 day)"
            }
          },
          "sqlContent": "\n\n-- Feature table: Daily heartbeat aggregations per user\n-- Debug: Processing heartbeat data with device tracking and extension status\nSELECT    \n  anonymous_id,\n  DATE(timestamp, \"America/Los_Angeles\") AS dt,\n  \n  -- Heartbeat metrics\n  COUNT(*) AS total_heartbeats,\n  COUNTIF(has_both_extensions_enabled) > 0 AS has_both_extensions_enabled,\n  MAX(context_app_version) AS max_app_version,\n  \n  -- App and context data\n  ARRAY_AGG(DISTINCT context_app_name IGNORE NULLS) AS all_context_app_names,\n  \n  -- Device aggregations\n  ARRAY_AGG(DISTINCT context_device_id IGNORE NULLS) AS all_device_ids,\n  ARRAY_AGG(DISTINCT user_id IGNORE NULLS) AS all_user_ids,\n  \n  -- Context resolution for user identity (most frequent values)\n  APPROX_TOP_COUNT(context_country, 1)[OFFSET(0)].value AS context_country_hb,\n  APPROX_TOP_COUNT(context_user_agent, 1)[OFFSET(0)].value AS context_user_agent_hb\n\nFROM `piedotorg-production.extension_production_views.ext_heartbeat`\n\nWHERE\n  context_app_name IN ('extension-adblock', 'extension-shopping', 'extension-unified')\n  \n\nGROUP BY \n  anonymous_id,\n  dt ",
          "dependencies": [
            "ext_heartbeat"
          ],
          "uniqueKey": [
            "dt",
            "anonymous_id"
          ]
        }
      },
      {
        "id": "f_user_identity",
        "model": {
          "name": "f_user_identity",
          "filePath": "user_features/f_user_identity.sqlx",
          "type": "table",
          "schema": "user_features_dev",
          "tags": [
            "users",
            "features",
            "identity",
            "full_refresh"
          ],
          "description": "User identity resolution including app assignment and context from heartbeats and installs - uses installs_base_w_reinstall consistently",
          "config": {
            "type": "table",
            "schema": "user_features_dev",
            "tags": [
              "users",
              "features",
              "identity",
              "full_refresh"
            ],
            "description": "User identity resolution including app assignment and context from heartbeats and installs - uses installs_base_w_reinstall consistently"
          },
          "sqlContent": "\n\n-- Feature table: User identity resolution (FULL REFRESH)\n-- Debug: Clean user context resolution using consistent install table\nWITH heartbeat_context AS (\n  -- Debug: Getting most frequent country/UA from raw heartbeats per user/app\n  SELECT \n    anonymous_id,\n    context_app_name,\n    APPROX_TOP_COUNT(context_country, 1)[OFFSET(0)].value AS context_country_hb,\n    APPROX_TOP_COUNT(context_user_agent, 1)[OFFSET(0)].value AS context_user_agent_hb,\n    MAX(DATE(timestamp, \"America/Los_Angeles\")) AS last_heartbeat_date,\n    COUNT(*) AS total_heartbeats\n  FROM `piedotorg-production.extension_production_views.ext_heartbeat`\n  WHERE context_app_name IN ('extension-adblock', 'extension-shopping', 'extension-unified')\n    AND context_app_name IS NOT NULL\n  GROUP BY anonymous_id, context_app_name\n),\n\ninstall_context AS (\n  -- Debug: Getting context from installs_base_w_reinstall per user/app\n  SELECT \n    anonymous_id,\n    CONCAT(\"extension-\", extension_type) AS context_app_name,\n    APPROX_TOP_COUNT(context_country, 1)[OFFSET(0)].value AS context_country_install,\n    APPROX_TOP_COUNT(context_user_agent, 1)[OFFSET(0)].value AS context_user_agent_install,\n    MAX(DATE(timestamp, \"America/Los_Angeles\")) AS last_install_date\n  FROM `piedotorg-production.growth_marketing.installs_base_w_reinstall`\n  WHERE extension_type IS NOT NULL\n    AND anonymous_id IS NOT NULL\n  GROUP BY anonymous_id, extension_type\n),\n\nuser_app_assignments AS (\n  -- Debug: Combine heartbeat and install data to assign users to their primary app\n  SELECT\n    COALESCE(heartbeat_context.anonymous_id, install_context.anonymous_id) AS anonymous_id,\n    COALESCE(heartbeat_context.context_app_name, install_context.context_app_name) AS context_app_name,\n    COALESCE(\n      install_context.context_country_install, \n      heartbeat_context.context_country_hb\n    ) AS context_country,\n    COALESCE(\n      install_context.context_user_agent_install, \n      heartbeat_context.context_user_agent_hb  \n    ) AS context_user_agent,\n    -- Use most recent activity (heartbeat or install) to determine primary app\n    ROW_NUMBER() OVER (\n      PARTITION BY COALESCE(heartbeat_context.anonymous_id, install_context.anonymous_id)\n      ORDER BY GREATEST(\n        COALESCE(heartbeat_context.last_heartbeat_date, DATE('1970-01-01')),\n        COALESCE(install_context.last_install_date, DATE('1970-01-01'))\n      ) DESC\n    ) AS row_num\n  FROM heartbeat_context\n  FULL OUTER JOIN install_context \n    USING (anonymous_id, context_app_name)\n)\n\n-- Debug: Final user identity with most recent app assignment\nSELECT\n  anonymous_id,\n  context_app_name,\n  context_country,\n  context_user_agent\nFROM user_app_assignments\nWHERE row_num = 1 -- Most recent app assignment per user ",
          "dependencies": [
            "ext_heartbeat",
            "installs_base_w_reinstall"
          ]
        }
      },
      {
        "id": "f_user_installs",
        "model": {
          "name": "f_user_installs",
          "filePath": "user_features/f_user_installs.sqlx",
          "type": "incremental",
          "schema": "user_features_dev",
          "tags": [
            "users",
            "features",
            "installs"
          ],
          "description": "Daily aggregated install and uninstall events per user",
          "config": {
            "type": "incremental",
            "schema": "user_features_dev",
            "tags": [
              "users",
              "features",
              "installs"
            ],
            "description": "Daily aggregated install and uninstall events per user",
            "uniqueKey": [
              "dt",
              "anonymous_id"
            ],
            "bigquery": {
              "partitionBy": "dt",
              "updatePartitionFilter": "dt >= date_sub(current_date(), interval 3 day)"
            }
          },
          "sqlContent": "\n\n-- Feature table: Daily install/uninstall aggregations per user\n-- Debug: Processing installs, reinstalls, and uninstalls\nWITH installs_base AS (\n  SELECT\n    anonymous_id,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt,\n    COUNT(*) AS total_installs\n  FROM `piedotorg-production.growth_marketing.installs_base_w_reinstall`\n  \n  \n  \n  GROUP BY anonymous_id, dt\n),\n\nserver_uninstalls_base AS (\n  SELECT\n    CASE\n      WHEN extension_type = \"adblock\" THEN extension_adblock_anonymous_id\n      WHEN extension_type = \"shopping\" THEN extension_shopping_anonymous_id  \n      WHEN extension_type = \"unified\" THEN extension_unified_anonymous_id\n      ELSE NULL\n    END AS anonymous_id,\n    CONCAT(\"extension-\", extension_type) AS context_app_name,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt,\n    COUNT(*) AS server_uninstalls\n  FROM `piedotorg-production.website_production.web_server_uninstall`\n  \n  WHERE \n    \n    CASE\n      WHEN extension_type = \"adblock\" THEN extension_adblock_anonymous_id\n      WHEN extension_type = \"shopping\" THEN extension_shopping_anonymous_id\n      WHEN extension_type = \"unified\" THEN extension_unified_anonymous_id\n      ELSE NULL\n    END IS NOT NULL\n  \n  GROUP BY anonymous_id, context_app_name, dt\n),\n\nweb_uninstalls_base AS (\n  SELECT\n    CASE\n      WHEN extension_type = \"adblock\" THEN extension_adblock_anonymous_id\n      WHEN extension_type = \"shopping\" THEN extension_shopping_anonymous_id\n      WHEN extension_type = \"unified\" THEN extension_unified_anonymous_id  \n      ELSE NULL\n    END AS anonymous_id,\n    CONCAT(\"extension-\", extension_type) AS context_app_name,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt,\n    COUNT(*) AS web_uninstalls\n  FROM `piedotorg-production.website_production.web_uninstall`\n  \n  WHERE \n    \n    CASE\n      WHEN extension_type = \"adblock\" THEN extension_adblock_anonymous_id\n      WHEN extension_type = \"shopping\" THEN extension_shopping_anonymous_id\n      WHEN extension_type = \"unified\" THEN extension_unified_anonymous_id\n      ELSE NULL\n    END IS NOT NULL\n  \n  GROUP BY anonymous_id, context_app_name, dt\n),\n\nuninstalls_combined AS (\n  -- Debug: Combining server and web uninstalls per user/day\n  SELECT\n    anonymous_id,\n    dt,\n    SUM(server_uninstalls) AS total_server_uninstalls,\n    SUM(web_uninstalls) AS total_web_uninstalls,\n    -- Get maximum uninstalls across all app types for a user on a given day\n    MAX(COALESCE(server_uninstalls, 0) + COALESCE(web_uninstalls, 0)) AS max_daily_uninstalls\n  FROM (\n    SELECT anonymous_id, dt, server_uninstalls, 0 AS web_uninstalls\n    FROM server_uninstalls_base\n    \n    UNION ALL\n    \n    SELECT anonymous_id, dt, 0 AS server_uninstalls, web_uninstalls\n    FROM web_uninstalls_base\n  )\n  GROUP BY anonymous_id, dt\n)\n\n-- Debug: Combining all install/uninstall features\nSELECT\n  COALESCE(installs_base.anonymous_id, uninstalls_combined.anonymous_id) AS anonymous_id,\n  COALESCE(installs_base.dt, uninstalls_combined.dt) AS dt,\n  \n  -- Install metrics\n  COALESCE(total_installs, 0) AS total_installs,\n  \n  -- Uninstall metrics\n  COALESCE(total_server_uninstalls, 0) AS total_server_uninstalls,\n  COALESCE(total_web_uninstalls, 0) AS total_web_uninstalls,\n  COALESCE(max_daily_uninstalls, 0) AS max_daily_uninstalls -- replicates GREATEST_ARRAY logic\n\nFROM installs_base\nFULL OUTER JOIN uninstalls_combined\n  USING (anonymous_id, dt) ",
          "dependencies": [
            "installs_base_w_reinstall",
            "web_server_uninstall",
            "web_uninstall"
          ],
          "uniqueKey": [
            "dt",
            "anonymous_id"
          ]
        }
      },
      {
        "id": "f_user_interactions",
        "model": {
          "name": "f_user_interactions",
          "filePath": "user_features/f_user_interactions.sqlx",
          "type": "incremental",
          "schema": "user_features_dev",
          "tags": [
            "users",
            "features",
            "events"
          ],
          "description": "Daily aggregated user interactions including clicks, shows, and savings actions",
          "config": {
            "type": "incremental",
            "schema": "user_features_dev",
            "tags": [
              "users",
              "features",
              "events"
            ],
            "description": "Daily aggregated user interactions including clicks, shows, and savings actions",
            "uniqueKey": [
              "dt",
              "anonymous_id"
            ],
            "bigquery": {
              "partitionBy": "dt",
              "updatePartitionFilter": "dt >= date_sub(current_date(), interval 3 day)"
            }
          },
          "sqlContent": "\n\n-- Feature table: Daily user interaction aggregations\n-- Debug: Processing all click/show/savings interactions with detailed breakdowns\nSELECT\n  anonymous_id,\n  DATE(timestamp, \"America/Los_Angeles\") AS dt,\n  \n  -- Overall interaction metrics\n  COUNTIF(action = \"click\") AS total_clicks,\n  COUNTIF(action = \"show\") AS total_shows,\n  COUNTIF(action = \"close\") AS total_closes,\n  \n  -- Session-based metrics\n  COUNT(DISTINCT IF(action = \"click\", session_id, NULL)) AS total_click_sessions,\n  COUNT(DISTINCT IF(action = \"show\", session_id, NULL)) AS total_show_sessions,\n  \n  -- Adblock cashback popup interactions\n  COUNTIF(action = \"show\" AND automation_type = \"cashback_adblock\") AS shows_adblock_cashback_popup,\n  COUNTIF(action = \"click\" AND automation_type = \"cashback_adblock\") AS clicks_adblock_cashback_popup,\n  COUNTIF(action = \"close\" AND automation_type = \"cashback_adblock\") AS closes_adblock_cashback_popup,\n  \n  -- Popover interactions\n  COUNTIF(action = \"click\" AND surface IN (\"popover\", \"popover_adblock\")) AS clicks_popover,\n  COUNTIF(action = \"show\" AND surface IN (\"popover\", \"popover_adblock\")) AS shows_popover,\n  \n  -- Popover rewards specific\n  COUNTIF(action = \"click\" AND surface IN (\"popover\", \"popover_adblock\") AND is_rewards) AS clicks_popover_rewards,\n  COUNTIF(action = \"show\" AND surface IN (\"popover\", \"popover_adblock\") AND is_rewards) AS shows_popover_rewards,\n  \n  -- Savings coupons with rewards breakdown (c1_r1 = coupons + rewards, c1_r0 = coupons only)\n  COUNTIF(action = \"show\" AND automation_type = \"savings_coupons\" AND is_rewards) AS c1_r1_shows,\n  COUNTIF(action = \"show\" AND automation_type = \"savings_coupons\" AND NOT is_rewards) AS c1_r0_shows,\n  COUNTIF(action = \"click\" AND automation_type = \"savings_coupons\" AND is_rewards) AS c1_r1_clicks,\n  COUNTIF(action = \"click\" AND automation_type = \"savings_coupons\" AND NOT is_rewards) AS c1_r0_clicks,\n  COUNTIF(action = \"close\" AND automation_type = \"savings_coupons\" AND is_rewards) AS c1_r1_closes,\n  COUNTIF(action = \"close\" AND automation_type = \"savings_coupons\" AND NOT is_rewards) AS c1_r0_closes\n\nFROM `piedotorg-production.extension_production_views.ext_savings`\n\n\n\nGROUP BY \n  anonymous_id,\n  dt ",
          "dependencies": [
            "ext_savings"
          ],
          "uniqueKey": [
            "dt",
            "anonymous_id"
          ]
        }
      },
      {
        "id": "f_user_sessions",
        "model": {
          "name": "f_user_sessions",
          "filePath": "user_features/f_user_sessions.sqlx",
          "type": "incremental",
          "schema": "user_features_dev",
          "tags": [
            "users",
            "features",
            "sessions"
          ],
          "description": "Daily aggregated session and cart activity per user",
          "config": {
            "type": "incremental",
            "schema": "user_features_dev",
            "tags": [
              "users",
              "features",
              "sessions"
            ],
            "description": "Daily aggregated session and cart activity per user",
            "uniqueKey": [
              "dt",
              "anonymous_id"
            ],
            "bigquery": {
              "partitionBy": "dt",
              "updatePartitionFilter": "dt >= date_sub(current_date(), interval 3 day)"
            }
          },
          "sqlContent": "\n\n-- Feature table: Daily session and cart aggregations per user\n-- Debug: Processing session starts and cart visits together\nWITH sessions_base AS (\n  SELECT\n    anonymous_id,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt,\n    COUNT(*) AS total_sessions_started,\n    COUNTIF(merchant_id != \"pie\") AS non_pie_sessions_started\n  FROM `piedotorg-production.extension_production_views.ext_session_started`\n  \n  \n  \n  GROUP BY anonymous_id, dt\n),\n\ncart_base AS (\n  SELECT\n    anonymous_id,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt,\n    COUNT(*) AS total_carts_visited,\n    COUNT(DISTINCT session_id) AS total_cart_sessions\n  FROM `piedotorg-production.extension_production_views.ext_context_detect`\n  \n  \n  \n  GROUP BY anonymous_id, dt\n)\n\n-- Debug: Full outer join to capture all user activity\nSELECT\n  COALESCE(sessions_base.anonymous_id, cart_base.anonymous_id) AS anonymous_id,\n  COALESCE(sessions_base.dt, cart_base.dt) AS dt,\n  \n  -- Session metrics\n  COALESCE(total_sessions_started, 0) AS total_sessions_started,\n  COALESCE(non_pie_sessions_started, 0) AS non_pie_sessions_started,\n  \n  -- Cart metrics  \n  COALESCE(total_carts_visited, 0) AS total_carts_visited,\n  COALESCE(total_cart_sessions, 0) AS total_cart_sessions\n  \nFROM sessions_base\nFULL OUTER JOIN cart_base\n  USING (anonymous_id, dt) ",
          "dependencies": [
            "ext_session_started",
            "ext_context_detect"
          ],
          "uniqueKey": [
            "dt",
            "anonymous_id"
          ]
        }
      },
      {
        "id": "f_user_transactions",
        "model": {
          "name": "f_user_transactions",
          "filePath": "user_features/f_user_transactions.sqlx",
          "type": "incremental",
          "schema": "user_features_dev",
          "tags": [
            "users",
            "features",
            "commerce"
          ],
          "description": "Daily aggregated transaction data per user including revenue, millipoints, and transaction types - incremental with all-time lookback for late confirmations",
          "config": {
            "type": "incremental",
            "schema": "user_features_dev",
            "tags": [
              "users",
              "features",
              "commerce"
            ],
            "description": "Daily aggregated transaction data per user including revenue, millipoints, and transaction types - incremental with all-time lookback for late confirmations",
            "uniqueKey": [
              "dt",
              "anonymous_id"
            ],
            "bigquery": {
              "partitionBy": "dt"
            }
          },
          "sqlContent": "\n\n-- Feature table: Daily transaction aggregations per user\n-- Debug: Processing all transaction types with detailed revenue and millipoint tracking\nWITH transaction_base AS (\n  SELECT\n    anonymous_id,\n    userId,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt,\n    \n    -- Overall transaction counts\n    COUNT(*) AS total_transactions,\n    COUNTIF(t.state = \"CONFIRMED\") AS confirmed_transactions,\n\n    -- Millipoints (rewards currency)\n    SUM(t.millipoints) AS total_millipoints, -- includes payouts\n    SUM(IF(t.state = \"CONFIRMED\", t.millipoints, 0)) AS total_millipoints_confirmed,\n    SUM(IF(adOfferType != \"PAYOUT\", t.millipoints, 0)) AS earned_millipoints, -- excludes payouts\n    \n    -- Revenue calculations (affiliate + ad offers)\n    SUM(externalSaleValue) AS gmv_cents,\n    SUM(externalCommission) AS commission_cents,\n    SUM(IF(externalStatus = \"CONFIRMED\", externalSaleValue, 0)) AS confirmed_gmv_cents,\n    SUM(IF(externalStatus = \"CONFIRMED\", externalCommission, 0)) AS confirmed_commission_cents,\n\n    -- Transaction type breakdowns\n    COUNTIF(type = \"AD_OFFER\") AS total_ad_offers_transactions,\n    COUNTIF(adOfferType = \"RETARGETING\") AS retargeting_offers_transactions,\n    COUNTIF(adOfferType = \"SEARCH\") AS search_offers_transactions,\n    COUNTIF(type = \"AD_VIEW\") AS ad_view_transactions,\n    COUNTIF(type = \"MANUAL\") AS manual_transactions,\n    COUNTIF(type = \"ONBOARDING\") AS onboarding_transactions,\n    COUNTIF(type = \"PAYOUT\") AS payout_transactions,\n    COUNTIF(type = \"AFFILIATE\") AS affiliate_transactions,\n    COUNTIF(type = \"REFERRAL\") AS referral_transactions,\n\n    -- Millipoints by transaction type\n    SUM(IF(type = \"AD_OFFER\", t.millipoints, 0)) AS ad_offer_millipoints,\n    SUM(IF(adOfferType = \"RETARGETING\", t.millipoints, 0)) AS retargeting_millipoints,\n    SUM(IF(adOfferType = \"SEARCH\", t.millipoints, 0)) AS search_millipoints,\n    SUM(IF(type = \"AD_VIEW\", t.millipoints, 0)) AS ad_view_millipoints,\n    SUM(IF(type = \"MANUAL\", t.millipoints, 0)) AS manual_millipoints,\n    SUM(IF(type = \"REFERRAL\", t.millipoints, 0)) AS referral_millipoints,\n    SUM(IF(type = \"ONBOARDING\", t.millipoints, 0)) AS onboarding_millipoints,\n    SUM(IF(type = \"PAYOUT\", t.millipoints, 0)) AS payout_millipoints,\n    SUM(IF(type = \"AFFILIATE\", t.millipoints, 0)) AS affiliate_millipoints\n\n  FROM `piedotorg-production.data_science_dev.transactions_expanded_view` t\n  \n  where timestamp is not null\n  GROUP BY anonymous_id, userId, dt\n\n),\n\nrewards_transaction_base AS (\n  SELECT\n    anonymous_id,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt,\n    \n    -- Rewards popup interactions\n    COUNTIF(action = \"show\" AND surface = \"rewards_transaction_popup\") AS rewards_shows,\n    COUNTIF(action IN (\"click\", \"login\") AND surface = \"rewards_transaction_popup\") AS rewards_clicks,\n    COUNTIF(action = \"close\" AND surface = \"rewards_transaction_popup\") AS rewards_closes,\n    COUNTIF(action = \"no_show\" AND surface = \"rewards_transaction_popup\") AS rewards_no_shows,\n    COUNTIF(action = \"show\" AND surface = \"rewards_transaction_toast_success\") AS rewards_success_toasts\n    \n  FROM `piedotorg-production.extension_production_views.ext_rewards_transaction`\n  \n  GROUP BY anonymous_id, dt\n),\n\nuser_balances_base AS (\n  SELECT\n    userId,\n    dt,\n    end_balance AS ir_balance -- current IR (rewards) balance\n  FROM `piedotorg-production.users.user_balances`\n)\n\n-- Debug: Combining all transaction-related features with proper aggregation\nSELECT\n  COALESCE(transaction_base.anonymous_id, rewards_transaction_base.anonymous_id) AS anonymous_id,\n  COALESCE(transaction_base.dt, rewards_transaction_base.dt) AS dt,\n  MAX(transaction_base.userId) AS userId, -- Use MAX to handle potential nulls\n  \n  -- Transaction metrics\n  COALESCE(MAX(total_transactions), 0) AS total_transactions,\n  COALESCE(MAX(confirmed_transactions), 0) AS confirmed_transactions,\n  COALESCE(MAX(total_millipoints), 0) AS total_millipoints,\n  COALESCE(MAX(total_millipoints_confirmed), 0) AS total_millipoints_confirmed,\n  COALESCE(MAX(earned_millipoints), 0) AS earned_millipoints,\n  \n  -- Revenue metrics (Note: ad_offer budget revenue removed - now tracked separately in campaigns_campaignbudgetevents)\n  COALESCE(MAX(commission_cents), 0) AS total_revenue_cents,\n  COALESCE(MAX(gmv_cents), 0) AS gmv_cents,\n  COALESCE(MAX(commission_cents), 0) AS commission_cents,\n  COALESCE(MAX(confirmed_gmv_cents), 0) AS confirmed_gmv_cents,\n  COALESCE(MAX(confirmed_commission_cents), 0) AS confirmed_commission_cents,\n  \n  -- Transaction type counts\n  COALESCE(MAX(total_ad_offers_transactions), 0) AS total_ad_offers_transactions,\n  COALESCE(MAX(ad_offer_millipoints), 0) AS ad_offer_millipoints,\n  COALESCE(MAX(retargeting_offers_transactions), 0) AS retargeting_offers_transactions,\n  COALESCE(MAX(retargeting_millipoints), 0) AS retargeting_millipoints,\n  COALESCE(MAX(search_offers_transactions), 0) AS search_offers_transactions,\n  COALESCE(MAX(search_millipoints), 0) AS search_millipoints,\n  COALESCE(MAX(ad_view_transactions), 0) AS ad_view_transactions,\n  COALESCE(MAX(ad_view_millipoints), 0) AS ad_view_millipoints,\n  COALESCE(MAX(manual_transactions), 0) AS manual_transactions,\n  COALESCE(MAX(manual_millipoints), 0) AS manual_millipoints,\n  COALESCE(MAX(onboarding_transactions), 0) AS onboarding_transactions,\n  COALESCE(MAX(onboarding_millipoints), 0) AS onboarding_millipoints,\n  COALESCE(MAX(payout_transactions), 0) AS payout_transactions,\n  COALESCE(MAX(payout_millipoints), 0) AS payout_millipoints,\n  COALESCE(MAX(affiliate_transactions), 0) AS affiliate_transactions,\n  COALESCE(MAX(affiliate_millipoints), 0) AS affiliate_millipoints,\n  COALESCE(MAX(referral_millipoints), 0) AS referral_millipoints,\n  \n  -- Rewards transaction popup metrics\n  COALESCE(MAX(rewards_shows), 0) AS rewards_shows,\n  COALESCE(MAX(rewards_clicks), 0) AS rewards_clicks,\n  COALESCE(MAX(rewards_closes), 0) AS rewards_closes,\n  COALESCE(MAX(rewards_no_shows), 0) AS rewards_no_shows,\n  COALESCE(MAX(rewards_success_toasts), 0) AS rewards_success_toasts,\n  \n  -- Balance data\n  MAX(user_balances_base.ir_balance) AS ir_balance\n  \nFROM transaction_base\nFULL OUTER JOIN rewards_transaction_base\n  USING (anonymous_id, dt)\nLEFT JOIN user_balances_base\n  ON transaction_base.userId = user_balances_base.userId \n  AND transaction_base.dt = user_balances_base.dt \n\nGROUP BY \n  COALESCE(transaction_base.anonymous_id, rewards_transaction_base.anonymous_id),\n  COALESCE(transaction_base.dt, rewards_transaction_base.dt) ",
          "dependencies": [
            "transactions_expanded_view",
            "ext_rewards_transaction",
            "user_balances"
          ],
          "uniqueKey": [
            "dt",
            "anonymous_id"
          ]
        }
      },
      {
        "id": "f_user_video_events",
        "model": {
          "name": "f_user_video_events",
          "filePath": "user_features/f_user_video_events.sqlx",
          "type": "incremental",
          "schema": "user_features_dev",
          "tags": [
            "users",
            "features",
            "video_events"
          ],
          "description": "Daily aggregated video events including YouTube and Twitch adblock activity",
          "config": {
            "type": "incremental",
            "schema": "user_features_dev",
            "tags": [
              "users",
              "features",
              "video_events"
            ],
            "description": "Daily aggregated video events including YouTube and Twitch adblock activity",
            "uniqueKey": [
              "dt",
              "anonymous_id"
            ],
            "bigquery": {
              "partitionBy": "dt",
              "updatePartitionFilter": "dt >= date_sub(current_date(), interval 3 day)"
            }
          },
          "sqlContent": "\n\n-- Feature table: Daily video event aggregations per user\n-- Debug: Processing YouTube and Twitch adblock events\nWITH youtube_ads_base AS (\n  SELECT\n    anonymous_id,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt,\n    COUNT(*) AS total_youtube_ads_seen\n  FROM `piedotorg-production.extension_production_views.adblock_youtube_ad_seen`\n  \n  \n  \n  GROUP BY anonymous_id, dt\n),\n\nyoutube_errors_base AS (\n  SELECT\n    anonymous_id,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt,\n    COUNT(*) AS total_youtube_errors\n  FROM `piedotorg-production.extension_production_views.adblock_youtube_error_msg`\n  \n  \n  \n  GROUP BY anonymous_id, dt\n),\n\nyoutube_embeds_base AS (\n  SELECT\n    anonymous_id,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt,\n    COUNT(*) AS total_youtube_embeds\n  FROM `piedotorg-production.extension_production_views.adblock_youtube_video_embed`\n  \n  \n  \n  GROUP BY anonymous_id, dt\n),\n\nyoutube_success_base AS (\n  SELECT\n    anonymous_id,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt,\n    COUNT(*) AS total_youtube_successes\n  FROM `piedotorg-production.extension_production_views.adblock_youtube_video_success`\n  \n  \n  \n  GROUP BY anonymous_id, dt\n),\n\ntwitch_ads_base AS (\n  SELECT\n    anonymous_id,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt,\n    COUNT(*) AS total_twitch_ads_seen\n  FROM `piedotorg-production.extension_production_views.adblock_twitch_ad_seen`\n  \n  \n  \n  GROUP BY anonymous_id, dt\n),\n\ngeneral_errors_base AS (\n  SELECT\n    anonymous_id,\n    DATE(timestamp, \"America/Los_Angeles\") AS dt,\n    COUNT(*) AS total_adblock_errors\n  FROM `piedotorg-production.extension_production_views.adblock_error_msg`\n  \n  \n  \n  GROUP BY anonymous_id, dt\n)\n\n-- Debug: Combining all video event features\nSELECT\n  COALESCE(\n    youtube_ads_base.anonymous_id,\n    youtube_errors_base.anonymous_id, \n    youtube_embeds_base.anonymous_id,\n    youtube_success_base.anonymous_id,\n    twitch_ads_base.anonymous_id,\n    general_errors_base.anonymous_id\n  ) AS anonymous_id,\n  COALESCE(\n    youtube_ads_base.dt,\n    youtube_errors_base.dt,\n    youtube_embeds_base.dt, \n    youtube_success_base.dt,\n    twitch_ads_base.dt,\n    general_errors_base.dt\n  ) AS dt,\n  \n  -- YouTube metrics\n  COALESCE(total_youtube_ads_seen, 0) AS total_youtube_ads_seen,\n  COALESCE(total_youtube_errors, 0) AS total_youtube_errors,\n  COALESCE(total_youtube_embeds, 0) AS total_youtube_embeds,  \n  COALESCE(total_youtube_successes, 0) AS total_youtube_successes,\n  \n  -- Twitch metrics  \n  COALESCE(total_twitch_ads_seen, 0) AS total_twitch_ads_seen,\n  \n  -- Error metrics\n  COALESCE(total_adblock_errors, 0) AS total_adblock_errors\n\nFROM youtube_ads_base\nFULL OUTER JOIN youtube_errors_base\n  USING (anonymous_id, dt)\nFULL OUTER JOIN youtube_embeds_base\n  USING (anonymous_id, dt)\nFULL OUTER JOIN youtube_success_base\n  USING (anonymous_id, dt)\nFULL OUTER JOIN twitch_ads_base\n  USING (anonymous_id, dt)\nFULL OUTER JOIN general_errors_base\n  USING (anonymous_id, dt) ",
          "dependencies": [
            "adblock_youtube_ad_seen",
            "adblock_youtube_error_msg",
            "adblock_youtube_video_embed",
            "adblock_youtube_video_success",
            "adblock_twitch_ad_seen",
            "adblock_error_msg"
          ],
          "uniqueKey": [
            "dt",
            "anonymous_id"
          ]
        }
      },
      {
        "id": "int_transaction_mapping",
        "model": {
          "name": "int_transaction_mapping",
          "filePath": "user_intermediate/int_transaction_mapping.sqlx",
          "type": "table",
          "schema": "user_intermediate_dev",
          "tags": [
            "users",
            "intermediate",
            "commerce",
            "full_refresh"
          ],
          "description": "Maps affiliate transactions to anonymous IDs via redirect tracking - requires full historical context for proper linking",
          "config": {
            "type": "table",
            "schema": "user_intermediate_dev",
            "tags": [
              "users",
              "intermediate",
              "commerce",
              "full_refresh"
            ],
            "description": "Maps affiliate transactions to anonymous IDs via redirect tracking - requires full historical context for proper linking"
          },
          "sqlContent": "\n\n-- Intermediate table: Transaction to anonymous ID mapping (FULL REFRESH)\n-- Debug: Complex transaction linking that requires full historical context\nWITH base_transactions AS (\n  SELECT\n    transactionId,\n    trackId,\n    TIMESTAMP_MILLIS(externalCreated) AS transaction_created,\n    externalCommission,\n    externalstatus,\n    externalSaleValue,\n    provider\n  FROM `piedotorg-production.analytics_etl.transactions_affiliatetransactions`\n),\n\nbase_redirects AS (\n  SELECT\n    anonymousid AS anonymous_id,\n    extTagId AS ext_tag_id,\n    trackId,\n    affiliateLinkId,\n    sessionid,\n    merchantId,\n    IFNULL(timestamp, TIMESTAMP_MILLIS(sessionid)) AS redirect_timestamp\n  FROM `piedotorg-production.backend_analytics.outbound_redirect`\n)\n\n-- Debug: Linking transactions to users via trackId from redirects\nSELECT\n  base_transactions.transactionId,\n  base_redirects.anonymous_id,\n  base_transactions.externalstatus,\n  SUM(base_transactions.externalCommission) AS commission_cents,\n  SUM(base_transactions.externalSaleValue) AS gmv_cents,\n  MIN(base_transactions.transaction_created) AS first_transaction_created,\n  MAX(base_transactions.transaction_created) AS last_transaction_created,\n  COUNT(*) AS transaction_count\nFROM base_transactions\nLEFT JOIN base_redirects\n  USING (trackId)\nWHERE base_redirects.anonymous_id IS NOT NULL -- Only transactions we can link to users\nGROUP BY \n  transactionId,\n  anonymous_id,\n  externalstatus ",
          "dependencies": [
            "transactions_affiliatetransactions",
            "outbound_redirect"
          ]
        }
      },
      {
        "id": "int_user_cohort_logic",
        "model": {
          "name": "int_user_cohort_logic",
          "filePath": "user_intermediate/int_user_cohort_logic.sqlx",
          "type": "incremental",
          "schema": "user_intermediate_dev",
          "tags": [
            "users",
            "intermediate",
            "identity"
          ],
          "description": "User cohort logic calculations including cohort dates and days since cohort - incremental with all-time lookback for consistency",
          "config": {
            "type": "incremental",
            "schema": "user_intermediate_dev",
            "tags": [
              "users",
              "intermediate",
              "identity"
            ],
            "description": "User cohort logic calculations including cohort dates and days since cohort - incremental with all-time lookback for consistency",
            "uniqueKey": [
              "dt",
              "anonymous_id"
            ],
            "bigquery": {
              "partitionBy": "dt"
            }
          },
          "sqlContent": "\n\n-- Intermediate table: User cohort logic (INCREMENTAL)\n-- Debug: Complex cohort calculations with all-time lookback for consistency\nWITH install_dates AS (\n  -- Debug: Get earliest install per anonymous_id (by timestamp, not alphabetical)\n  SELECT\n    anonymous_id,\n    DATE(first_install_ts, \"America/Los_Angeles\") AS install_day_pst,\n    first_install_ts AS install_timestamp,\n    puci\n  FROM (\n    SELECT\n      anonymous_id,\n      first_install_ts,\n      puci,\n      ROW_NUMBER() OVER (PARTITION BY anonymous_id ORDER BY first_install_ts ASC) AS rn\n    FROM `piedotorg-production.growth_marketing.installs_base_w_reinstall`\n    WHERE is_first_install = true\n  )\n  WHERE rn = 1\n),\n\nfirst_heartbeat_dates AS (\n  -- Debug: Calculate first heartbeat date per user across all days\n  SELECT\n    anonymous_id,\n    MIN(CASE WHEN total_heartbeats > 0 THEN dt ELSE NULL END) AS first_heartbeat_date\n  FROM `piedotorg-production.user_intermediate_dev.int_user_daily_base`\n  GROUP BY anonymous_id\n),\n\nuninstall_tracking AS (\n  -- Debug: Track most recent uninstall date per user\n  SELECT\n    anonymous_id,\n    MAX(CASE WHEN max_daily_uninstalls > 0 THEN dt ELSE NULL END) AS most_recent_uninstall_date\n  FROM `piedotorg-production.user_intermediate_dev.int_user_daily_base`\n  GROUP BY anonymous_id\n)\n\n-- Debug: Final cohort logic with all calculations\nSELECT\n  base.*,\n  \n  -- Install and heartbeat dates\n  install_dates.install_day_pst,\n  install_dates.install_timestamp,\n  install_dates.puci,\n  first_heartbeat_dates.first_heartbeat_date,\n  uninstall_tracking.most_recent_uninstall_date,\n  \n  -- Cohort date calculation (earliest of install or first heartbeat)\n  LEAST(\n    COALESCE(install_dates.install_day_pst, DATE('2099-12-31')),\n    COALESCE(first_heartbeat_dates.first_heartbeat_date, DATE('2099-12-31'))\n  ) AS cohort_date,\n  \n  -- Days since cohort calculation\n  DATE_DIFF(\n    base.dt,\n    LEAST(\n      COALESCE(install_dates.install_day_pst, DATE('2099-12-31')),\n      COALESCE(first_heartbeat_dates.first_heartbeat_date, DATE('2099-12-31'))\n    ),\n    DAY\n  ) AS days_since_cohort_date\n\nFROM `piedotorg-production.user_intermediate_dev.int_user_daily_base` base\nLEFT JOIN install_dates\n  USING (anonymous_id)\nLEFT JOIN first_heartbeat_dates\n  USING (anonymous_id)\nLEFT JOIN uninstall_tracking\n  USING (anonymous_id) ",
          "dependencies": [
            "int_user_daily_base",
            "installs_base_w_reinstall"
          ],
          "uniqueKey": [
            "dt",
            "anonymous_id"
          ]
        }
      },
      {
        "id": "int_user_daily_base",
        "model": {
          "name": "int_user_daily_base",
          "filePath": "user_intermediate/int_user_daily_base.sqlx",
          "type": "incremental",
          "schema": "user_intermediate_dev",
          "tags": [
            "users",
            "intermediate",
            "daily"
          ],
          "description": "Core daily user table, combining all user activity into a single wide table - incremental with all-time lookback for transaction updates",
          "config": {
            "type": "incremental",
            "schema": "user_intermediate_dev",
            "tags": [
              "users",
              "intermediate",
              "daily"
            ],
            "description": "Core daily user table, combining all user activity into a single wide table - incremental with all-time lookback for transaction updates",
            "uniqueKey": [
              "dt",
              "anonymous_id"
            ],
            "bigquery": {
              "partitionBy": "dt"
            }
          },
          "sqlContent": "\n\n-- Intermediate table: Daily user base aggregations\n-- Debug: Combining all feature tables into comprehensive daily user view\nWITH heartbeat_agg AS (\n  SELECT\n    anonymous_id,\n    dt,\n    SUM(total_heartbeats) AS total_heartbeats,\n    LOGICAL_OR(has_both_extensions_enabled) AS has_both_extensions_enabled,\n    MAX(max_app_version) AS max_app_version,\n    ARRAY_CONCAT_AGG(all_device_ids) AS all_device_ids,\n    ARRAY_CONCAT_AGG(all_user_ids) AS all_user_ids\n  FROM `piedotorg-production.user_features_dev.f_user_heartbeats`\n  GROUP BY anonymous_id, dt\n),\n\n-- Pre-compute COALESCE values to ensure consistency between SELECT and GROUP BY\nbase_data AS (\n  SELECT\n    COALESCE(\n      COALESCE(\n        heartbeat_agg.anonymous_id,\n        f_user_sessions.anonymous_id,\n        f_user_interactions.anonymous_id,\n        f_user_transactions.anonymous_id,\n        f_user_commerce.anonymous_id,\n        f_user_installs.anonymous_id,\n        f_user_events.anonymous_id,\n        f_user_video_events.anonymous_id\n      ),\n      'null_anonymous_id' -- Simple constant for all NULL anonymous_id cases\n    ) AS final_anonymous_id,\n    \n    COALESCE(\n      heartbeat_agg.dt,\n      f_user_sessions.dt,\n      f_user_interactions.dt,\n      f_user_transactions.dt,\n      f_user_commerce.dt,\n      f_user_installs.dt,\n      f_user_events.dt,\n      f_user_video_events.dt\n    ) AS final_dt,\n    \n    -- Keep all original data for aggregation\n    heartbeat_agg,\n    f_user_sessions,\n    f_user_interactions,\n    f_user_transactions,\n    f_user_commerce,\n    f_user_installs,\n    f_user_events,\n    f_user_video_events,\n    f_user_identity\n    \n  FROM heartbeat_agg\n  FULL OUTER JOIN `piedotorg-production.user_features_dev.f_user_sessions` f_user_sessions\n    USING (anonymous_id, dt)\n  FULL OUTER JOIN `piedotorg-production.user_features_dev.f_user_interactions` f_user_interactions\n    USING (anonymous_id, dt)\n  FULL OUTER JOIN `piedotorg-production.user_features_dev.f_user_transactions` f_user_transactions\n    USING (anonymous_id, dt)\n  FULL OUTER JOIN `piedotorg-production.user_features_dev.f_user_commerce` f_user_commerce\n    USING (anonymous_id, dt)\n  FULL OUTER JOIN `piedotorg-production.user_features_dev.f_user_installs` f_user_installs\n    USING (anonymous_id, dt)\n  FULL OUTER JOIN `piedotorg-production.user_features_dev.f_user_events` f_user_events\n    USING (anonymous_id, dt)\n  FULL OUTER JOIN `piedotorg-production.user_features_dev.f_user_video_events` f_user_video_events\n    USING (anonymous_id, dt)\n  LEFT JOIN `piedotorg-production.user_features_dev.f_user_identity` f_user_identity\n    USING (anonymous_id)\n)\n\n-- Debug: Final aggregation using pre-computed keys\nSELECT\n  final_anonymous_id AS anonymous_id,\n  final_dt AS dt,\n  \n  -- User identity data\n  MAX(f_user_identity.context_app_name) AS context_app_name,\n  MAX(f_user_identity.context_country) AS context_country,\n  MAX(f_user_identity.context_user_agent) AS context_user_agent,\n  MAX(f_user_transactions.userId) AS userId,\n  \n  -- Heartbeat metrics\n  COALESCE(MAX(heartbeat_agg.total_heartbeats), 0) AS total_heartbeats,\n  COALESCE(LOGICAL_OR(heartbeat_agg.has_both_extensions_enabled), FALSE) AS has_both_extensions_enabled,\n  MAX(heartbeat_agg.max_app_version) AS max_app_version,\n  ARRAY_CONCAT_AGG(heartbeat_agg.all_device_ids) AS all_device_ids,\n  ARRAY_CONCAT_AGG(heartbeat_agg.all_user_ids) AS all_user_ids,\n  \n  -- Session metrics\n  COALESCE(MAX(f_user_sessions.total_sessions_started), 0) AS total_sessions_started,\n  COALESCE(MAX(f_user_sessions.non_pie_sessions_started), 0) AS non_pie_sessions_started,\n  COALESCE(MAX(f_user_sessions.total_carts_visited), 0) AS total_carts_visited,\n  COALESCE(MAX(f_user_sessions.total_cart_sessions), 0) AS total_cart_sessions,\n  \n  -- Interaction metrics\n  COALESCE(MAX(f_user_interactions.total_clicks), 0) AS total_clicks,\n  COALESCE(MAX(f_user_interactions.total_shows), 0) AS total_shows,\n  COALESCE(MAX(f_user_interactions.total_click_sessions), 0) AS total_click_sessions,\n  COALESCE(MAX(f_user_interactions.total_show_sessions), 0) AS total_show_sessions,\n  COALESCE(MAX(f_user_interactions.shows_adblock_cashback_popup), 0) AS shows_adblock_cashback_popup,\n  COALESCE(MAX(f_user_interactions.clicks_adblock_cashback_popup), 0) AS clicks_adblock_cashback_popup,\n  COALESCE(MAX(f_user_interactions.closes_adblock_cashback_popup), 0) AS closes_adblock_cashback_popup,\n  COALESCE(MAX(f_user_interactions.clicks_popover), 0) AS clicks_popover,\n  COALESCE(MAX(f_user_interactions.shows_popover), 0) AS shows_popover,\n  COALESCE(MAX(f_user_interactions.clicks_popover_rewards), 0) AS clicks_popover_rewards,\n  COALESCE(MAX(f_user_interactions.shows_popover_rewards), 0) AS shows_popover_rewards,\n  COALESCE(MAX(f_user_interactions.c1_r1_shows), 0) AS c1_r1_shows,\n  COALESCE(MAX(f_user_interactions.c1_r0_shows), 0) AS c1_r0_shows,\n  COALESCE(MAX(f_user_interactions.c1_r1_clicks), 0) AS c1_r1_clicks,\n  COALESCE(MAX(f_user_interactions.c1_r0_clicks), 0) AS c1_r0_clicks,\n  COALESCE(MAX(f_user_interactions.c1_r1_closes), 0) AS c1_r1_closes,\n  COALESCE(MAX(f_user_interactions.c1_r0_closes), 0) AS c1_r0_closes,\n  \n  -- Transaction metrics\n  COALESCE(MAX(f_user_transactions.total_transactions), 0) AS total_transactions,\n  COALESCE(MAX(f_user_transactions.confirmed_transactions), 0) AS confirmed_transactions,\n  COALESCE(MAX(f_user_transactions.total_millipoints), 0) AS total_millipoints,\n  COALESCE(MAX(f_user_transactions.total_millipoints_confirmed), 0) AS total_millipoints_confirmed,\n  COALESCE(MAX(f_user_transactions.earned_millipoints), 0) AS earned_millipoints,\n  COALESCE(MAX(f_user_transactions.total_revenue_cents), 0) AS total_revenue_cents,\n  COALESCE(MAX(f_user_transactions.gmv_cents), 0) AS gmv_cents,\n  COALESCE(MAX(f_user_transactions.commission_cents), 0) AS commission_cents,\n  COALESCE(MAX(f_user_transactions.confirmed_gmv_cents), 0) AS confirmed_gmv_cents,\n  COALESCE(MAX(f_user_transactions.confirmed_commission_cents), 0) AS confirmed_commission_cents,\n  \n  -- Transaction type metrics (Note: ad_offer_revenue_cents removed - budget data now tracked separately in campaigns_campaignbudgetevents)\n  COALESCE(MAX(f_user_transactions.total_ad_offers_transactions), 0) AS total_ad_offers_transactions,\n  COALESCE(MAX(f_user_transactions.ad_offer_millipoints), 0) AS ad_offer_millipoints,\n  COALESCE(MAX(f_user_transactions.retargeting_offers_transactions), 0) AS retargeting_offers_transactions,\n  COALESCE(MAX(f_user_transactions.retargeting_millipoints), 0) AS retargeting_millipoints,\n  COALESCE(MAX(f_user_transactions.search_offers_transactions), 0) AS search_offers_transactions,\n  COALESCE(MAX(f_user_transactions.search_millipoints), 0) AS search_millipoints,\n  COALESCE(MAX(f_user_transactions.ad_view_transactions), 0) AS ad_view_transactions,\n  COALESCE(MAX(f_user_transactions.ad_view_millipoints), 0) AS ad_view_millipoints,\n  COALESCE(MAX(f_user_transactions.manual_transactions), 0) AS manual_transactions,\n  COALESCE(MAX(f_user_transactions.manual_millipoints), 0) AS manual_millipoints,\n  COALESCE(MAX(f_user_transactions.onboarding_transactions), 0) AS onboarding_transactions,\n  COALESCE(MAX(f_user_transactions.onboarding_millipoints), 0) AS onboarding_millipoints,\n  COALESCE(MAX(f_user_transactions.payout_transactions), 0) AS payout_transactions,\n  COALESCE(MAX(f_user_transactions.payout_millipoints), 0) AS payout_millipoints,\n  COALESCE(MAX(f_user_transactions.affiliate_transactions), 0) AS affiliate_transactions,\n  COALESCE(MAX(f_user_transactions.affiliate_millipoints), 0) AS affiliate_millipoints,\n  COALESCE(MAX(f_user_transactions.referral_millipoints), 0) AS referral_millipoints,\n  \n  -- Rewards transaction metrics\n  COALESCE(MAX(f_user_transactions.rewards_shows), 0) AS rewards_shows,\n  COALESCE(MAX(f_user_transactions.rewards_clicks), 0) AS rewards_clicks,\n  COALESCE(MAX(f_user_transactions.rewards_closes), 0) AS rewards_closes,\n  COALESCE(MAX(f_user_transactions.rewards_no_shows), 0) AS rewards_no_shows,\n  COALESCE(MAX(f_user_transactions.rewards_success_toasts), 0) AS rewards_success_toasts,\n  MAX(f_user_transactions.ir_balance) AS ir_balance,\n  \n  -- Commerce metrics\n  COALESCE(MAX(f_user_commerce.total_affiliate_tags), 0) AS total_affiliate_tags,\n  COALESCE(MAX(f_user_commerce.total_tag_sessions), 0) AS total_tag_sessions,\n  COALESCE(MAX(f_user_commerce.total_order_confirmations), 0) AS total_order_confirmations,\n  COALESCE(MAX(f_user_commerce.order_confirmation_sessions), 0) AS order_confirmation_sessions,\n  COALESCE(MAX(f_user_commerce.tagged_order_confirmations), 0) AS tagged_order_confirmations,\n  COALESCE(MAX(f_user_commerce.total_redirects), 0) AS total_redirects,\n  COALESCE(MAX(f_user_commerce.total_redirect_sessions), 0) AS total_redirect_sessions,\n  COALESCE(MAX(f_user_commerce.rewards_transaction_popup_redirects), 0) AS rewards_transaction_popup_redirects,\n  COALESCE(MAX(f_user_commerce.coupon_popup_shopping_redirects), 0) AS coupon_popup_shopping_redirects,\n  COALESCE(MAX(f_user_commerce.cashback_popup_adblock_redirects), 0) AS cashback_popup_adblock_redirects,\n  COALESCE(MAX(f_user_commerce.rewards_popup_shopping_redirects), 0) AS rewards_popup_shopping_redirects,\n  COALESCE(MAX(f_user_commerce.popover_coupon_list_redirects), 0) AS popover_coupon_list_redirects,\n  COALESCE(MAX(f_user_commerce.login_retargeting_redirects), 0) AS login_retargeting_redirects,\n  COALESCE(MAX(f_user_commerce.standdown_redirects), 0) AS standdown_redirects,\n  \n  -- Install/Uninstall metrics\n  COALESCE(MAX(f_user_installs.total_installs), 0) AS total_installs,\n  COALESCE(MAX(f_user_installs.total_server_uninstalls), 0) AS total_server_uninstalls,\n  COALESCE(MAX(f_user_installs.total_web_uninstalls), 0) AS total_web_uninstalls,\n  COALESCE(MAX(f_user_installs.max_daily_uninstalls), 0) AS max_daily_uninstalls,\n  \n  -- Event metrics\n  COALESCE(MAX(f_user_events.total_standdowns), 0) AS total_standdowns,\n  COALESCE(MAX(f_user_events.stop_standdowns), 0) AS stop_standdowns,\n  COALESCE(MAX(f_user_events.notag_standdowns), 0) AS notag_standdowns,\n  COALESCE(MAX(f_user_events.suppress_standdowns), 0) AS suppress_standdowns,\n  COALESCE(MAX(f_user_events.total_pages_w_ads_seen), 0) AS total_pages_w_ads_seen,\n  COALESCE(MAX(f_user_events.total_ad_placements_seen), 0) AS total_ad_placements_seen,\n  COALESCE(MAX(f_user_events.total_pixels_seen), 0) AS total_pixels_seen,\n  MAX(f_user_events.other_adblockers) AS other_adblockers,\n  \n  -- Video event metrics  \n  COALESCE(MAX(f_user_video_events.total_youtube_ads_seen), 0) AS total_youtube_ads_seen,\n  COALESCE(MAX(f_user_video_events.total_youtube_errors), 0) AS total_youtube_errors,\n  COALESCE(MAX(f_user_video_events.total_youtube_embeds), 0) AS total_youtube_embeds,\n  COALESCE(MAX(f_user_video_events.total_youtube_successes), 0) AS total_youtube_successes,\n  COALESCE(MAX(f_user_video_events.total_twitch_ads_seen), 0) AS total_twitch_ads_seen,\n  COALESCE(MAX(f_user_video_events.total_adblock_errors), 0) AS total_adblock_errors\n\nFROM base_data\n\nGROUP BY final_anonymous_id, final_dt ",
          "dependencies": [
            "f_user_heartbeats",
            "f_user_sessions",
            "f_user_interactions",
            "f_user_transactions",
            "f_user_commerce",
            "f_user_installs",
            "f_user_events",
            "f_user_identity",
            "f_user_video_events"
          ],
          "uniqueKey": [
            "dt",
            "anonymous_id"
          ]
        }
      },
      {
        "id": "user_day_funnel",
        "model": {
          "name": "user_day_funnel",
          "filePath": "users_final/user_day_funnel.sqlx",
          "type": "incremental",
          "schema": "users_dev",
          "tags": [
            "users",
            "final",
            "daily"
          ],
          "description": "Final comprehensive user day funnel table - incremental with all-time lookback for transaction accuracy",
          "config": {
            "type": "incremental",
            "schema": "users_dev",
            "tags": [
              "users",
              "final",
              "daily"
            ],
            "description": "Final comprehensive user day funnel table - incremental with all-time lookback for transaction accuracy",
            "uniqueKey": [
              "dt",
              "anonymous_id"
            ],
            "bigquery": {
              "partitionBy": "dt"
            }
          },
          "sqlContent": "\n\n-- Final table: User day funnel\n-- Debug: Final comprehensive user funnel replicating original logic with full feature set\nSELECT\n  -- Core identifiers\n  dt,\n  anonymous_id,\n  userId,\n  context_app_name,\n  context_country,\n  context_user_agent,\n  other_adblockers,\n  \n  -- Heartbeat metrics\n  total_heartbeats,\n  max_app_version,\n  has_both_extensions_enabled,\n  \n  -- Session metrics\n  total_sessions_started,\n  non_pie_sessions_started,\n  total_carts_visited,\n  total_cart_sessions,\n  \n  -- Interaction metrics\n  total_clicks,\n  total_shows,\n  total_click_sessions,\n  total_show_sessions,\n  \n  -- Affiliate/Commerce metrics\n  total_affiliate_tags AS total_tags,\n  total_tag_sessions,\n  total_redirects,\n  total_redirect_sessions,\n  \n  -- IR Balance\n  ir_balance,\n  \n  -- Install/Uninstall metrics\n  max_daily_uninstalls AS uninstalls, -- replicates GREATEST_ARRAY logic\n  total_server_uninstalls AS server_uninstalls,\n  total_web_uninstalls AS web_uninstalls,\n  total_installs AS num_installs,\n  \n  -- Transaction metrics\n  total_transactions,\n  confirmed_transactions,\n  total_millipoints,\n  total_millipoints_confirmed,\n  earned_millipoints,\n  total_revenue_cents,\n  \n  -- Affiliate transaction metrics\n  gmv_cents,\n  commission_cents,\n  confirmed_gmv_cents,\n  confirmed_commission_cents,\n  \n  -- Ad offer metrics (Note: all_adoffer_revenue_cents removed - budget data now tracked separately in campaigns_campaignbudgetevents)\n  total_ad_offers_transactions AS all_offers_trx,\n  ad_offer_millipoints AS all_adoffer_millipoints,\n  \n  -- Retargeting metrics\n  retargeting_offers_transactions AS retargeting_offers_trx,\n  retargeting_millipoints,\n  \n  -- Search metrics\n  search_offers_transactions AS search_offers_trx,\n  search_millipoints,\n  \n  -- Ad view metrics\n  ad_view_transactions AS ad_view_trx,\n  ad_view_millipoints,\n  \n  -- Manual metrics\n  manual_transactions AS manual_trx,\n  manual_millipoints,\n  \n  -- Onboarding metrics\n  onboarding_transactions AS onboarding_trx,\n  onboarding_millipoints,\n  \n  -- Payout metrics\n  payout_transactions AS payout_trx,\n  payout_millipoints,\n  \n  -- Affiliate metrics\n  affiliate_transactions AS total_affiliate_transactions,\n  affiliate_millipoints,\n  \n  -- Referral metrics\n  referral_millipoints,\n  \n  -- Rewards transaction metrics\n  rewards_shows,\n  rewards_clicks,\n  rewards_closes,\n  rewards_no_shows,\n  \n  -- Order confirmation metrics\n  order_confirmation_sessions,\n  total_order_confirmations,\n  \n  -- Standdown metrics\n  total_standdowns AS all_standdowns,\n  stop_standdowns,\n  notag_standdowns,\n  suppress_standdowns,\n  \n  -- Ad metrics\n  total_pages_w_ads_seen,\n  total_ad_placements_seen,\n  \n  -- Video event metrics\n  total_youtube_ads_seen,\n  total_youtube_errors,\n  total_youtube_embeds,\n  total_youtube_successes,\n  total_twitch_ads_seen,\n  total_adblock_errors,\n  \n  -- Device arrays\n  all_device_ids,\n  all_user_ids,\n  \n  -- Cohort calculations\n  first_heartbeat_date,\n  install_timestamp,\n  install_day_pst,\n  puci,\n  cohort_date,\n  days_since_cohort_date,\n  most_recent_uninstall_date AS most_recent_uninstall\n\nFROM `piedotorg-production.user_intermediate_dev.int_user_cohort_logic` ",
          "dependencies": [
            "int_user_cohort_logic",
            "int_user_daily_base",
            "installs_base_w_reinstall"
          ],
          "uniqueKey": [
            "dt",
            "anonymous_id"
          ]
        }
      },
      {
        "id": "ai_intent_engine_offer",
        "model": {
          "name": "ai_intent_engine_offer",
          "filePath": "sources/ai_intent_engine_offer.sqlx",
          "type": "table",
          "schema": "backend_analytics",
          "tags": [],
          "description": "AI-powered personalized offers delivered through Pie's Intent Engine system with detailed engagement metrics",
          "config": {
            "type": "table",
            "schema": "backend_analytics",
            "tags": [],
            "description": "AI-powered personalized offers delivered through Pie's Intent Engine system with detailed engagement metrics"
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "amazon_dsp_campaign_funnel",
        "model": {
          "name": "amazon_dsp_campaign_funnel",
          "filePath": "sources/amazon_dsp_campaign_funnel.sqlx",
          "type": "table",
          "schema": "growth_marketing",
          "tags": [],
          "description": "Amazon DSP campaign performance data with daily aggregation",
          "config": {
            "type": "table",
            "schema": "growth_marketing",
            "tags": [],
            "description": "Amazon DSP campaign performance data with daily aggregation"
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "apple_search_campaign_funnel",
        "model": {
          "name": "apple_search_campaign_funnel",
          "filePath": "sources/apple_search_campaign_funnel.sqlx",
          "type": "table",
          "schema": "growth_marketing",
          "tags": [],
          "description": "Apple Search Ads campaign performance data with daily aggregation",
          "config": {
            "type": "table",
            "schema": "growth_marketing",
            "tags": [],
            "description": "Apple Search Ads campaign performance data with daily aggregation"
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "campaigns_campaignbudgetevents",
        "model": {
          "name": "campaigns_campaignbudgetevents",
          "filePath": "sources/campaigns_campaignbudgetevents.sqlx",
          "type": "table",
          "schema": "analytics_etl",
          "tags": [],
          "description": "Campaign budget events tracking budget usage for offers and campaigns",
          "config": {
            "type": "table",
            "schema": "analytics_etl",
            "tags": [],
            "description": "Campaign budget events tracking budget usage for offers and campaigns"
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "campaigns_campaigns",
        "model": {
          "name": "campaigns_campaigns",
          "filePath": "sources/campaigns_campaigns.sqlx",
          "type": "table",
          "schema": "analytics_etl",
          "tags": [],
          "description": "Campaign configuration data including state, budget, and lifecycle timestamps",
          "config": {
            "type": "table",
            "schema": "analytics_etl",
            "tags": [],
            "description": "Campaign configuration data including state, budget, and lifecycle timestamps"
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "campaigns_placements",
        "model": {
          "name": "campaigns_placements",
          "filePath": "sources/campaigns_placements.sqlx",
          "type": "table",
          "schema": "analytics_etl",
          "tags": [],
          "description": "Campaign placements with placement hash, template, and match data",
          "config": {
            "type": "table",
            "schema": "analytics_etl",
            "tags": [],
            "description": "Campaign placements with placement hash, template, and match data"
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "dpr_manual_external",
        "model": {
          "name": "dpr_manual_external",
          "filePath": "sources/dpr_manual_external.sqlx",
          "type": "table",
          "schema": "growth_marketing",
          "tags": [],
          "description": "Manual external CPI (cost per install) data for bizdev partnerships",
          "config": {
            "type": "table",
            "schema": "growth_marketing",
            "tags": [],
            "description": "Manual external CPI (cost per install) data for bizdev partnerships"
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "dpr_manual_mapping",
        "model": {
          "name": "dpr_manual_mapping",
          "filePath": "sources/dpr_manual_mapping.sqlx",
          "type": "table",
          "schema": "growth_marketing",
          "tags": [],
          "description": "Manual mapping table for placement metadata including platform, media source, and funnel classification",
          "config": {
            "type": "table",
            "schema": "growth_marketing",
            "tags": [],
            "description": "Manual mapping table for placement metadata including platform, media source, and funnel classification"
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "dpr_manual_publisher_cpms",
        "model": {
          "name": "dpr_manual_publisher_cpms",
          "filePath": "sources/dpr_manual_publisher_cpms.sqlx",
          "type": "table",
          "schema": "growth_marketing",
          "tags": [],
          "config": {
            "type": "table",
            "schema": "growth_marketing",
            "tags": []
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "dpr_manual_spend",
        "model": {
          "name": "dpr_manual_spend",
          "filePath": "sources/dpr_manual_spend.sqlx",
          "type": "table",
          "schema": "growth_marketing",
          "tags": [],
          "description": "Manual influencer and partnership spend data with amortization settings",
          "config": {
            "type": "table",
            "schema": "growth_marketing",
            "tags": [],
            "description": "Manual influencer and partnership spend data with amortization settings"
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "adblock_error_msg",
        "model": {
          "name": "adblock_error_msg",
          "filePath": "sources/ext_adblock_error_msg.sqlx",
          "type": "table",
          "schema": "extension_production_views",
          "tags": [],
          "config": {
            "type": "table",
            "schema": "extension_production_views",
            "tags": []
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "adblock_twitch_ad_seen",
        "model": {
          "name": "adblock_twitch_ad_seen",
          "filePath": "sources/ext_adblock_twitch_ad_seen.sqlx",
          "type": "table",
          "schema": "extension_production_views",
          "tags": [],
          "config": {
            "type": "table",
            "schema": "extension_production_views",
            "tags": []
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "adblock_youtube_ad_seen",
        "model": {
          "name": "adblock_youtube_ad_seen",
          "filePath": "sources/ext_adblock_youtube_ad_seen.sqlx",
          "type": "table",
          "schema": "extension_production_views",
          "tags": [],
          "config": {
            "type": "table",
            "schema": "extension_production_views",
            "tags": []
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "adblock_youtube_error_msg",
        "model": {
          "name": "adblock_youtube_error_msg",
          "filePath": "sources/ext_adblock_youtube_error_msg.sqlx",
          "type": "table",
          "schema": "extension_production_views",
          "tags": [],
          "config": {
            "type": "table",
            "schema": "extension_production_views",
            "tags": []
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "adblock_youtube_video_embed",
        "model": {
          "name": "adblock_youtube_video_embed",
          "filePath": "sources/ext_adblock_youtube_video_embed.sqlx",
          "type": "table",
          "schema": "extension_production_views",
          "tags": [],
          "config": {
            "type": "table",
            "schema": "extension_production_views",
            "tags": []
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "adblock_youtube_video_success",
        "model": {
          "name": "adblock_youtube_video_success",
          "filePath": "sources/ext_adblock_youtube_video_success.sqlx",
          "type": "table",
          "schema": "extension_production_views",
          "tags": [],
          "config": {
            "type": "table",
            "schema": "extension_production_views",
            "tags": []
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "ext_affiliate_tag",
        "model": {
          "name": "ext_affiliate_tag",
          "filePath": "sources/ext_affiliate_tag.sqlx",
          "type": "table",
          "schema": "extension_production_views",
          "tags": [],
          "config": {
            "type": "table",
            "schema": "extension_production_views",
            "tags": []
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "ext_context_detect",
        "model": {
          "name": "ext_context_detect",
          "filePath": "sources/ext_context_detect.sqlx",
          "type": "table",
          "schema": "extension_production_views",
          "tags": [],
          "config": {
            "type": "table",
            "schema": "extension_production_views",
            "tags": []
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "ext_device_ad_metrics_rollup",
        "model": {
          "name": "ext_device_ad_metrics_rollup",
          "filePath": "sources/ext_device_ad_metrics_rollup.sqlx",
          "type": "table",
          "schema": "extension_production_views",
          "tags": [],
          "config": {
            "type": "table",
            "schema": "extension_production_views",
            "tags": []
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "ext_feedback",
        "model": {
          "name": "ext_feedback",
          "filePath": "sources/ext_feedback.sqlx",
          "type": "table",
          "schema": "extension_production_views",
          "tags": [],
          "config": {
            "type": "table",
            "schema": "extension_production_views",
            "tags": []
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "ext_heartbeat",
        "model": {
          "name": "ext_heartbeat",
          "filePath": "sources/ext_heartbeat.sqlx",
          "type": "table",
          "schema": "extension_production_views",
          "tags": [],
          "config": {
            "type": "table",
            "schema": "extension_production_views",
            "tags": []
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "ext_intent_engine_offer",
        "model": {
          "name": "ext_intent_engine_offer",
          "filePath": "sources/ext_intent_engine_offer.sqlx",
          "type": "table",
          "schema": "shopping_extension_production",
          "tags": [],
          "description": "Extension intent engine offer events and interactions",
          "config": {
            "type": "table",
            "schema": "shopping_extension_production",
            "tags": [],
            "description": "Extension intent engine offer events and interactions"
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "ext_order_confirmation",
        "model": {
          "name": "ext_order_confirmation",
          "filePath": "sources/ext_order_confirmation.sqlx",
          "type": "table",
          "schema": "extension_production_views",
          "tags": [],
          "config": {
            "type": "table",
            "schema": "extension_production_views",
            "tags": []
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "ext_rewards_transaction",
        "model": {
          "name": "ext_rewards_transaction",
          "filePath": "sources/ext_rewards_transaction.sqlx",
          "type": "table",
          "schema": "extension_production_views",
          "tags": [],
          "config": {
            "type": "table",
            "schema": "extension_production_views",
            "tags": []
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "ext_savings",
        "model": {
          "name": "ext_savings",
          "filePath": "sources/ext_savings.sqlx",
          "type": "table",
          "schema": "extension_production_views",
          "tags": [],
          "config": {
            "type": "table",
            "schema": "extension_production_views",
            "tags": []
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "ext_session_started",
        "model": {
          "name": "ext_session_started",
          "filePath": "sources/ext_session_started.sqlx",
          "type": "table",
          "schema": "extension_production_views",
          "tags": [],
          "config": {
            "type": "table",
            "schema": "extension_production_views",
            "tags": []
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "ext_standdown_detected",
        "model": {
          "name": "ext_standdown_detected",
          "filePath": "sources/ext_standdown_detected.sqlx",
          "type": "table",
          "schema": "extension_production_views",
          "tags": [],
          "config": {
            "type": "table",
            "schema": "extension_production_views",
            "tags": []
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "ext_user_settings",
        "model": {
          "name": "ext_user_settings",
          "filePath": "sources/ext_user_settings.sqlx",
          "type": "table",
          "schema": "extension_production_views",
          "tags": [],
          "config": {
            "type": "table",
            "schema": "extension_production_views",
            "tags": []
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "google_campaign_funnel",
        "model": {
          "name": "google_campaign_funnel",
          "filePath": "sources/google_campaign_funnel.sqlx",
          "type": "table",
          "schema": "growth_marketing",
          "tags": [],
          "description": "Google Ads campaign performance data with daily aggregation",
          "config": {
            "type": "table",
            "schema": "growth_marketing",
            "tags": [],
            "description": "Google Ads campaign performance data with daily aggregation"
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "installs_base",
        "model": {
          "name": "installs_base",
          "filePath": "sources/installs_base.sqlx",
          "type": "table",
          "schema": "growth_marketing",
          "tags": [],
          "config": {
            "type": "table",
            "schema": "growth_marketing",
            "tags": []
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "installs_base_w_reinstall",
        "model": {
          "name": "installs_base_w_reinstall",
          "filePath": "sources/installs_base_w_reinstall.sqlx",
          "type": "table",
          "schema": "growth_marketing",
          "tags": [],
          "config": {
            "type": "table",
            "schema": "growth_marketing",
            "tags": []
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "intent_engine_cooldown_triggered",
        "model": {
          "name": "intent_engine_cooldown_triggered",
          "filePath": "sources/intent_engine_cooldown_triggered.sqlx",
          "type": "table",
          "schema": "backend_analytics",
          "tags": [],
          "description": "Intent engine cooldown events with device and time range data",
          "config": {
            "type": "table",
            "schema": "backend_analytics",
            "tags": [],
            "description": "Intent engine cooldown events with device and time range data"
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "intent_engine_offer_group_match",
        "model": {
          "name": "intent_engine_offer_group_match",
          "filePath": "sources/intent_engine_offer_group_match.sqlx",
          "type": "table",
          "schema": "backend_analytics",
          "tags": [],
          "description": "Intent engine offer group matching events with placement and campaign data",
          "config": {
            "type": "table",
            "schema": "backend_analytics",
            "tags": [],
            "description": "Intent engine offer group matching events with placement and campaign data"
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "meta_campaign_funnel",
        "model": {
          "name": "meta_campaign_funnel",
          "filePath": "sources/meta_campaign_funnel.sqlx",
          "type": "table",
          "schema": "growth_marketing",
          "tags": [],
          "description": "Meta (Facebook/Instagram) campaign performance data with daily aggregation",
          "config": {
            "type": "table",
            "schema": "growth_marketing",
            "tags": [],
            "description": "Meta (Facebook/Instagram) campaign performance data with daily aggregation"
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "msft_campaign_funnel",
        "model": {
          "name": "msft_campaign_funnel",
          "filePath": "sources/msft_campaign_funnel.sqlx",
          "type": "table",
          "schema": "growth_marketing",
          "tags": [],
          "description": "Microsoft Ads campaign performance data with daily aggregation",
          "config": {
            "type": "table",
            "schema": "growth_marketing",
            "tags": [],
            "description": "Microsoft Ads campaign performance data with daily aggregation"
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "outbound_redirect",
        "model": {
          "name": "outbound_redirect",
          "filePath": "sources/outbound_redirect.sqlx",
          "type": "table",
          "schema": "backend_analytics",
          "tags": [],
          "config": {
            "type": "table",
            "schema": "backend_analytics",
            "tags": []
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "product_outbound_redirect",
        "model": {
          "name": "product_outbound_redirect",
          "filePath": "sources/product_outbound_redirect.sqlx",
          "type": "table",
          "schema": "backend_analytics",
          "tags": [],
          "description": "Product outbound redirect events for tracking product-specific affiliate links",
          "config": {
            "type": "table",
            "schema": "backend_analytics",
            "tags": [],
            "description": "Product outbound redirect events for tracking product-specific affiliate links"
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "reviews",
        "model": {
          "name": "reviews",
          "filePath": "sources/reviews.sqlx",
          "type": "table",
          "schema": "extensions_data",
          "tags": [],
          "config": {
            "type": "table",
            "schema": "extensions_data",
            "tags": []
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "tiktok_ads_campaign_funnel",
        "model": {
          "name": "tiktok_ads_campaign_funnel",
          "filePath": "sources/tiktok_ads_campaign_funnel.sqlx",
          "type": "table",
          "schema": "growth_marketing",
          "tags": [],
          "description": "TikTok Ads campaign performance data with daily aggregation",
          "config": {
            "type": "table",
            "schema": "growth_marketing",
            "tags": [],
            "description": "TikTok Ads campaign performance data with daily aggregation"
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "transactions_adoffers",
        "model": {
          "name": "transactions_adoffers",
          "filePath": "sources/transactions_adoffers.sqlx",
          "type": "table",
          "schema": "analytics_etl",
          "tags": [],
          "description": "Ad offers data including campaign associations and budget usage",
          "config": {
            "type": "table",
            "schema": "analytics_etl",
            "tags": [],
            "description": "Ad offers data including campaign associations and budget usage"
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "transactions_adviews",
        "model": {
          "name": "transactions_adviews",
          "filePath": "sources/transactions_adviews.sqlx",
          "type": "table",
          "schema": "analytics_etl",
          "tags": [],
          "description": "Ad view transactions including FAIR_AD and AI_AD types with metadata about creators, offers, and display context",
          "config": {
            "type": "table",
            "schema": "analytics_etl",
            "tags": [],
            "description": "Ad view transactions including FAIR_AD and AI_AD types with metadata about creators, offers, and display context"
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "transactions_affiliatetransactions",
        "model": {
          "name": "transactions_affiliatetransactions",
          "filePath": "sources/transactions_affiliatetransactions.sqlx",
          "type": "table",
          "schema": "analytics_etl",
          "tags": [],
          "config": {
            "type": "table",
            "schema": "analytics_etl",
            "tags": []
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "transactions_campaigns",
        "model": {
          "name": "transactions_campaigns",
          "filePath": "sources/transactions_campaigns.sqlx",
          "type": "table",
          "schema": "analytics_etl",
          "tags": [],
          "description": "Campaign data including budget, merchant info, and campaign lifecycle",
          "config": {
            "type": "table",
            "schema": "analytics_etl",
            "tags": [],
            "description": "Campaign data including budget, merchant info, and campaign lifecycle"
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "transactions_transactions",
        "model": {
          "name": "transactions_transactions",
          "filePath": "sources/transactions_transactions.sqlx",
          "type": "table",
          "schema": "analytics_etl",
          "tags": [],
          "description": "Core transactions table with transaction details and states",
          "config": {
            "type": "table",
            "schema": "analytics_etl",
            "tags": [],
            "description": "Core transactions table with transaction details and states"
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "user_anon_mapping",
        "model": {
          "name": "user_anon_mapping",
          "filePath": "sources/user_anon_mapping.sqlx",
          "type": "table",
          "schema": "users",
          "tags": [],
          "description": "Mapping between user IDs and anonymous IDs for user identity resolution",
          "config": {
            "type": "table",
            "schema": "users",
            "tags": [],
            "description": "Mapping between user IDs and anonymous IDs for user identity resolution"
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "user_balances",
        "model": {
          "name": "user_balances",
          "filePath": "sources/user_balances.sqlx",
          "type": "table",
          "schema": "users",
          "tags": [],
          "config": {
            "type": "table",
            "schema": "users",
            "tags": []
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "web_intent_engine_offer",
        "model": {
          "name": "web_intent_engine_offer",
          "filePath": "sources/web_intent_engine_offer.sqlx",
          "type": "table",
          "schema": "website_production",
          "tags": [],
          "description": "Website intent engine offer events and interactions from Pie's web platform",
          "config": {
            "type": "table",
            "schema": "website_production",
            "tags": [],
            "description": "Website intent engine offer events and interactions from Pie's web platform"
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "web_report_bug",
        "model": {
          "name": "web_report_bug",
          "filePath": "sources/web_report_bug.sqlx",
          "type": "table",
          "schema": "website_production",
          "tags": [],
          "config": {
            "type": "table",
            "schema": "website_production",
            "tags": []
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "web_server_uninstall",
        "model": {
          "name": "web_server_uninstall",
          "filePath": "sources/web_server_uninstall.sqlx",
          "type": "table",
          "schema": "website_production",
          "tags": [],
          "config": {
            "type": "table",
            "schema": "website_production",
            "tags": []
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "web_uninstall",
        "model": {
          "name": "web_uninstall",
          "filePath": "sources/web_uninstall.sqlx",
          "type": "table",
          "schema": "website_production",
          "tags": [],
          "config": {
            "type": "table",
            "schema": "website_production",
            "tags": []
          },
          "sqlContent": "",
          "dependencies": []
        }
      },
      {
        "id": "growth_marketing_all_campaigns_assertions_uniqueKey_0",
        "model": {
          "name": "growth_marketing_all_campaigns_assertions_uniqueKey_0",
          "filePath": "growth/all_campaigns.sqlx",
          "type": "table",
          "schema": "dataform_dev_assertions",
          "tags": [
            "growth",
            "campaigns",
            "daily",
            "marketing"
          ],
          "config": {
            "type": "table",
            "schema": "dataform_dev_assertions",
            "tags": [
              "growth",
              "campaigns",
              "daily",
              "marketing"
            ]
          },
          "sqlContent": "\nSELECT\n  *\nFROM (\n  SELECT\n    date, puci, ad_set_name,\n    COUNT(1) AS index_row_count\n  FROM `piedotorg-production.growth_marketing.all_campaigns`\n  GROUP BY date, puci, ad_set_name\n  ) AS data\nWHERE index_row_count > 1\n",
          "dependencies": [
            "all_campaigns"
          ]
        }
      },
      {
        "id": "growth_marketing_all_campaigns_assertions_rowConditions",
        "model": {
          "name": "growth_marketing_all_campaigns_assertions_rowConditions",
          "filePath": "growth/all_campaigns.sqlx",
          "type": "table",
          "schema": "dataform_dev_assertions",
          "tags": [
            "growth",
            "campaigns",
            "daily",
            "marketing"
          ],
          "config": {
            "type": "table",
            "schema": "dataform_dev_assertions",
            "tags": [
              "growth",
              "campaigns",
              "daily",
              "marketing"
            ]
          },
          "sqlContent": "\nSELECT\n  'date IS NOT NULL' AS failing_row_condition,\n  *\nFROM `piedotorg-production.growth_marketing.all_campaigns`\nWHERE NOT (date IS NOT NULL)\nUNION ALL\nSELECT\n  'puci IS NOT NULL' AS failing_row_condition,\n  *\nFROM `piedotorg-production.growth_marketing.all_campaigns`\nWHERE NOT (puci IS NOT NULL)\nUNION ALL\nSELECT\n  'source IS NOT NULL' AS failing_row_condition,\n  *\nFROM `piedotorg-production.growth_marketing.all_campaigns`\nWHERE NOT (source IS NOT NULL)\n",
          "dependencies": [
            "all_campaigns"
          ]
        }
      },
      {
        "id": "all_campaigns_no_duplicates_after_2025",
        "model": {
          "name": "all_campaigns_no_duplicates_after_2025",
          "filePath": "growth/all_campaigns_validation.sqlx",
          "type": "table",
          "schema": "growth_marketing",
          "tags": [
            "growth",
            "validation",
            "data_quality"
          ],
          "description": "Validates that there are no duplicate puci/date combinations after 2025-01-01",
          "config": {
            "type": "table",
            "schema": "growth_marketing",
            "tags": [
              "growth",
              "validation",
              "data_quality"
            ],
            "description": "Validates that there are no duplicate puci/date combinations after 2025-01-01"
          },
          "sqlContent": "\n\n-- This assertion will fail if any puci/date combination has more than 1 row after 2025\nSELECT\n  date,\n  puci,\n  COUNT(*) as row_count,\n  ARRAY_AGG(source ORDER BY source) as sources,\n  ARRAY_AGG(cost ORDER BY source) as costs\nFROM `piedotorg-production.growth_marketing.all_campaigns`\nWHERE date >= '2025-01-01'\nGROUP BY date, puci\nHAVING COUNT(*) > 1",
          "dependencies": [
            "all_campaigns"
          ]
        }
      },
      {
        "id": "growth_marketing_dev_bizdev_spend_assertions_rowConditions",
        "model": {
          "name": "growth_marketing_dev_bizdev_spend_assertions_rowConditions",
          "filePath": "growth/bizdev_spend.sqlx",
          "type": "table",
          "schema": "dataform_dev_assertions",
          "tags": [
            "growth",
            "bizdev",
            "daily"
          ],
          "config": {
            "type": "table",
            "schema": "dataform_dev_assertions",
            "tags": [
              "growth",
              "bizdev",
              "daily"
            ]
          },
          "sqlContent": "\nSELECT\n  'date IS NOT NULL' AS failing_row_condition,\n  *\nFROM `piedotorg-production.growth_marketing_dev.bizdev_spend`\nWHERE NOT (date IS NOT NULL)\nUNION ALL\nSELECT\n  'puci IS NOT NULL' AS failing_row_condition,\n  *\nFROM `piedotorg-production.growth_marketing_dev.bizdev_spend`\nWHERE NOT (puci IS NOT NULL)\nUNION ALL\nSELECT\n  'placement IS NOT NULL' AS failing_row_condition,\n  *\nFROM `piedotorg-production.growth_marketing_dev.bizdev_spend`\nWHERE NOT (placement IS NOT NULL)\nUNION ALL\nSELECT\n  'product IS NOT NULL' AS failing_row_condition,\n  *\nFROM `piedotorg-production.growth_marketing_dev.bizdev_spend`\nWHERE NOT (product IS NOT NULL)\n",
          "dependencies": [
            "bizdev_spend"
          ]
        }
      },
      {
        "id": "backend_frontend_ratio_monitor",
        "model": {
          "name": "backend_frontend_ratio_monitor",
          "filePath": "intent_engine/assertions/backend_frontend_ratio_monitor.sqlx",
          "type": "table",
          "schema": "intent_engine_dev",
          "tags": [
            "data_quality",
            "intent_engine",
            "offers",
            "monitoring"
          ],
          "description": "Monitors the ratio of backend events without frontend interactions - alerts if ratio deviates significantly from expected ~8-10%",
          "config": {
            "type": "table",
            "schema": "intent_engine_dev",
            "tags": [
              "data_quality",
              "intent_engine",
              "offers",
              "monitoring"
            ],
            "description": "Monitors the ratio of backend events without frontend interactions - alerts if ratio deviates significantly from expected ~8-10%"
          },
          "sqlContent": "\n\n-- Monitor backend→frontend conversion rate with offer_presented dimension\n-- Expected: Events marked offer_presented=true should have frontend matches\n-- Events marked offer_presented=false/NULL are legitimate consideration-only events\n-- Excludes AI offers which naturally have high consideration rates (~35%)\n\nWITH backend_frontend_stats AS (\n  SELECT \n    intent_engine_type,\n    \n    -- Total events breakdown\n    COUNT(*) as total_backend_events,\n    COUNT(CASE WHEN offer_presented = true THEN 1 END) as presented_events,\n    COUNT(CASE WHEN offer_presented != true OR offer_presented IS NULL THEN 1 END) as consideration_only_events,\n    \n    -- Frontend match breakdown\n    COUNT(CASE WHEN source_type IS NOT NULL THEN 1 END) as events_with_frontend_match,\n    COUNT(CASE WHEN offer_presented = true AND source_type IS NOT NULL THEN 1 END) as presented_with_frontend_match,\n    COUNT(CASE WHEN offer_presented = true AND source_type IS NULL THEN 1 END) as presented_without_frontend_match,\n    \n    -- Key ratios\n    ROUND(COUNT(CASE WHEN offer_presented = true AND source_type IS NULL THEN 1 END) * 100.0 / \n          NULLIF(COUNT(CASE WHEN offer_presented = true THEN 1 END), 0), 2) as presented_orphaned_pct,\n    ROUND(COUNT(CASE WHEN source_type IS NULL THEN 1 END) * 100.0 / COUNT(*), 2) as total_orphaned_pct\n    \n  FROM `piedotorg-production.intent_engine_dev.offer_expanded_view`\n  WHERE DATE(ts) >= DATE_SUB(CURRENT_DATE(), INTERVAL 1 DAY)\n    AND intent_engine_type NOT IN ('AI', 'MCP')  -- Exclude AI offers\n  GROUP BY intent_engine_type\n)\n\n-- Alert on data quality issues: presented events without frontend matches\nSELECT \n  intent_engine_type,\n  total_backend_events,\n  presented_events,\n  consideration_only_events,\n  events_with_frontend_match,\n  presented_with_frontend_match,\n  presented_without_frontend_match,\n  presented_orphaned_pct,\n  total_orphaned_pct,\n  CASE \n    WHEN presented_orphaned_pct > 5 THEN \n      CONCAT('DATA QUALITY ISSUE: ', CAST(presented_orphaned_pct AS STRING), \n             '% of presented events have no frontend match for ', intent_engine_type, ' (expected ~0%)')\n    WHEN intent_engine_type IN ('WEBSITE', 'WEBSITE_ONBOARDING') AND presented_events = 0 THEN\n      CONCAT('BACKEND LOGGING ISSUE: 0 events marked as presented for ', intent_engine_type, \n             ' but frontend events exist')\n    ELSE NULL\n  END as alert_message\nFROM backend_frontend_stats\nWHERE \n  presented_orphaned_pct > 5  -- Data quality issue: presented but no frontend match\n  OR (intent_engine_type IN ('WEBSITE', 'WEBSITE_ONBOARDING') AND presented_events = 0)  -- Backend logging issue",
          "dependencies": [
            "offer_expanded_view"
          ]
        }
      },
      {
        "id": "chatgpt_null_tag_monitor",
        "model": {
          "name": "chatgpt_null_tag_monitor",
          "filePath": "intent_engine/assertions/chatgpt_null_tag_monitor.sqlx",
          "type": "table",
          "schema": "intent_engine_dev_assertions",
          "tags": [],
          "description": "Monitor for ChatGPT transactions without tag attribution from Sept 4, 2025 onward. These indicate direct affiliate purchases bypassing the offer system.",
          "config": {
            "type": "table",
            "schema": "intent_engine_dev_assertions",
            "tags": [],
            "description": "Monitor for ChatGPT transactions without tag attribution from Sept 4, 2025 onward. These indicate direct affiliate purchases bypassing the offer system."
          },
          "sqlContent": "\n\n-- Alert if we see ChatGPT transactions without ext_tag_id from Sept 4, 2025 onward\n-- This helps monitor if ChatGPT feature is properly routing through offer system\nSELECT \n  transactionId,\n  userId,\n  merchantId,\n  DATE(created_coalesce_ts) as transaction_date,\n  type,\n  state,\n  externalSaleValue,\n  trackId,\n  affiliateLinkId,\n  'ChatGPT transaction without tag - bypassed offer system' as alert_reason\nFROM `piedotorg-production.data_science_dev.transactions_expanded_view`\nWHERE feature = 'chatgpt'\n  AND ext_tag_id IS NULL\n  AND DATE(created_coalesce_ts) >= '2025-09-04'\n  -- This query should return 0 rows if all ChatGPT transactions are properly tagged",
          "dependencies": [
            "transactions_expanded_view"
          ]
        }
      },
      {
        "id": "frontend_offers_have_backend_match",
        "model": {
          "name": "frontend_offers_have_backend_match",
          "filePath": "intent_engine/assertions/frontend_offers_have_backend_match.sqlx",
          "type": "table",
          "schema": "intent_engine_dev",
          "tags": [
            "data_quality",
            "intent_engine",
            "offers"
          ],
          "description": "Ensures all frontend offer events (ext + AI) have corresponding backend matching events",
          "config": {
            "type": "table",
            "schema": "intent_engine_dev",
            "tags": [
              "data_quality",
              "intent_engine",
              "offers"
            ],
            "description": "Ensures all frontend offer events (ext + AI) have corresponding backend matching events"
          },
          "sqlContent": "\n\n-- Assert that all frontend offer events have backend matches\n-- This validates our LEFT JOIN assumption in offer_expanded_view\n\nWITH unified_frontend_offers AS (\n  -- Extension offers\n  SELECT \n    request_id,\n    'ext' as source_type,\n    timestamp\n  FROM `piedotorg-production.shopping_extension_production.ext_intent_engine_offer`\n  WHERE DATE(timestamp) >= DATE_SUB(CURRENT_DATE(), INTERVAL 1 DAY)\n  \n  UNION ALL\n  \n  -- AI offers  \n  SELECT\n    request_id,\n    'ai' as source_type,\n    TIMESTAMP_MILLIS(timestamp_ms) as timestamp\n  FROM `piedotorg-production.backend_analytics.ai_intent_engine_offer`\n  WHERE DATE(TIMESTAMP_MILLIS(timestamp_ms)) >= DATE_SUB(CURRENT_DATE(), INTERVAL 1 DAY)\n),\n\norphaned_frontend_events AS (\n  SELECT \n    fe.request_id,\n    fe.source_type,\n    fe.timestamp as frontend_timestamp,\n    be.request_id IS NULL as is_orphaned\n  FROM unified_frontend_offers fe\n  LEFT JOIN `piedotorg-production.backend_analytics.intent_engine_offer_group_match` be\n    ON fe.request_id = be.request_id\n  WHERE be.request_id IS NULL  -- Only orphaned events\n)\n\n-- Assertion fails if ANY orphaned frontend events exist\nSELECT \n  request_id,\n  source_type,\n  frontend_timestamp,\n  CONCAT('Orphaned ', source_type, ' offer event with request_id: ', request_id) as error_message\nFROM orphaned_frontend_events",
          "dependencies": [
            "ext_intent_engine_offer",
            "ai_intent_engine_offer",
            "intent_engine_offer_group_match"
          ]
        }
      },
      {
        "id": "raw_vs_distinct_variance_monitor",
        "model": {
          "name": "raw_vs_distinct_variance_monitor",
          "filePath": "intent_engine/assertions/raw_vs_distinct_variance_monitor.sqlx",
          "type": "table",
          "schema": "dataform_dev_assertions",
          "tags": [],
          "description": "Monitor variance between raw and distinct counts for shows, clicks, redeems. Expected variance is 1.0-1.15 (up to 15%) for shows/redeems due to duplicate events. Clicks may be higher due to re-clicks. Alerts on variance above 15% or below 95%.",
          "config": {
            "type": "table",
            "schema": "dataform_dev_assertions",
            "tags": [],
            "description": "Monitor variance between raw and distinct counts for shows, clicks, redeems. Expected variance is 1.0-1.15 (up to 15%) for shows/redeems due to duplicate events. Clicks may be higher due to re-clicks. Alerts on variance above 15% or below 95%."
          },
          "sqlContent": "\n\n-- Monitor raw vs distinct count variance\n-- Expected: Some variance is normal due to:\n-- 1. Multiple frontend events per offer (show + view, multiple clicks, etc.)\n-- 2. User behavior patterns (re-clicks, multiple interactions)\n-- 3. Duplicate events from dual tracking systems\n-- Alert threshold set at 1.15 (15% variance) for normal operations\n\nWITH variance_check AS (\n  SELECT \n    dt,\n    campaign_id,\n    merchant_id,\n    period,\n    \n    -- Shows variance - expect ~1.0-1.15 with fixed GROUPING SETS\n    CASE \n      WHEN shows > 0 THEN SAFE_DIVIDE(shows_raw, shows)\n      ELSE 0\n    END as shows_ratio,\n    \n    -- Clicks variance - may be higher due to re-clicks  \n    CASE \n      WHEN clicks > 0 THEN SAFE_DIVIDE(clicks_raw, clicks)\n      ELSE 0\n    END as clicks_ratio,\n    \n    -- Redeems variance - should be close to shows ratio\n    CASE \n      WHEN redeems > 0 THEN SAFE_DIVIDE(redeems_raw, redeems)\n      ELSE 0\n    END as redeems_ratio,\n    \n    shows,\n    shows_raw,\n    clicks,\n    clicks_raw,\n    redeems,\n    redeems_raw\n    \n  FROM `piedotorg-production.intent_engine_dev.offer_campaign_ir_base`\n  WHERE DATE(dt) >= DATE_SUB(CURRENT_DATE(), INTERVAL 3 DAY)\n    AND period = 'day'  -- Daily aggregation only\n    AND intent_engine_type IN ('AI', 'MCP')  -- Focus on AI offers where we expect some variance\n    AND (shows > 0 OR clicks > 0 OR redeems > 0)  -- Only check rows with actual activity\n)\n\nSELECT \n  dt,\n  campaign_id, \n  merchant_id,\n  shows_ratio,\n  clicks_ratio,\n  redeems_ratio,\n  CONCAT('Shows: ', shows_raw, '/', shows, ' = ', ROUND(shows_ratio, 2), 'x') as shows_detail,\n  CONCAT('Clicks: ', clicks_raw, '/', clicks, ' = ', ROUND(clicks_ratio, 2), 'x') as clicks_detail,\n  CONCAT('Redeems: ', redeems_raw, '/', redeems, ' = ', ROUND(redeems_ratio, 2), 'x') as redeems_detail\nFROM variance_check\nWHERE \n  -- Alert on unexpectedly high variance (above 15% for shows/redeems, higher for clicks)\n  shows_ratio > 1.15 \n  OR clicks_ratio > 2.0  -- Clicks can be higher due to legitimate re-clicks\n  OR redeems_ratio > 1.15\n  -- Alert on unexpectedly low variance (below 0.95 suggests possible data loss)  \n  OR (shows_ratio < 0.95 AND shows > 5)\n  OR (clicks_ratio < 0.95 AND clicks > 5)\n  OR (redeems_ratio < 0.95 AND redeems > 5)",
          "dependencies": [
            "offer_campaign_ir_base"
          ]
        }
      },
      {
        "id": "tag_consistency_check",
        "model": {
          "name": "tag_consistency_check",
          "filePath": "intent_engine/assertions/tag_consistency_check.sqlx",
          "type": "table",
          "schema": "intent_engine_dev_assertions",
          "tags": [],
          "description": "Ensures that when both tag_id and ext_tag_id are present in transactions, they are always equal",
          "config": {
            "type": "table",
            "schema": "intent_engine_dev_assertions",
            "tags": [],
            "description": "Ensures that when both tag_id and ext_tag_id are present in transactions, they are always equal"
          },
          "sqlContent": "\n\n-- Check that transactions never have conflicting tag values\n-- When both tag_id and ext_tag_id exist, they must be equal\nSELECT \n  transactionId,\n  ext_tag_id,\n  tag_id,\n  trackId,\n  merchantId,\n  created_coalesce_ts\nFROM `piedotorg-production.data_science_dev.transactions_expanded_view`\nWHERE ext_tag_id IS NOT NULL \n  AND tag_id IS NOT NULL\n  AND ext_tag_id != tag_id  -- This should return 0 rows",
          "dependencies": [
            "transactions_expanded_view"
          ]
        }
      },
      {
        "id": "tenant_field_consistency_check",
        "model": {
          "name": "tenant_field_consistency_check",
          "filePath": "intent_engine/assertions/tenant_field_consistency.sqlx",
          "type": "table",
          "schema": "dataform_dev_assertions",
          "tags": [
            "intent_engine",
            "data_quality",
            "tenant_validation"
          ],
          "description": "Ensures tenant fields (tenant_id, tenant_client_id) are consistently present or absent across backend and AI offers for the same request_id",
          "config": {
            "type": "table",
            "schema": "dataform_dev_assertions",
            "tags": [
              "intent_engine",
              "data_quality",
              "tenant_validation"
            ],
            "description": "Ensures tenant fields (tenant_id, tenant_client_id) are consistently present or absent across backend and AI offers for the same request_id"
          },
          "sqlContent": "\n\n-- Check for requests where tenant fields are inconsistent between backend and AI offers\n-- Only checks requests that have BOTH backend and AI frontend events\n-- It's OK if both have NULL tenant data or both have tenant data, but not mixed\nWITH request_summary AS (\n  SELECT \n    request_id,\n    -- Check if this request has backend rows\n    MAX(CASE WHEN source_type IS NULL THEN 1 ELSE 0 END) AS has_backend_rows,\n    -- Check if this request has AI frontend events\n    MAX(CASE WHEN source_type = 'ai' THEN 1 ELSE 0 END) AS has_ai_rows,\n    -- Check if backend rows have tenant data\n    MAX(CASE WHEN source_type IS NULL AND (tenant_id IS NOT NULL OR tenant_client_id IS NOT NULL) THEN 1 ELSE 0 END) AS backend_has_tenant,\n    -- Check if AI rows have tenant data\n    MAX(CASE WHEN source_type = 'ai' AND (tenant_id IS NOT NULL OR tenant_client_id IS NOT NULL) THEN 1 ELSE 0 END) AS ai_has_tenant\n  FROM `piedotorg-production.intent_engine_dev.offer_expanded_view`\n  WHERE DATE(ts) >= CURRENT_DATE() - 7 -- Check last 7 days\n  GROUP BY request_id\n),\ninconsistent_requests AS (\n  SELECT \n    request_id,\n    backend_has_tenant,\n    ai_has_tenant,\n    CASE \n      WHEN backend_has_tenant = 1 AND ai_has_tenant = 0 THEN 'Backend has tenant, AI missing'\n      WHEN backend_has_tenant = 0 AND ai_has_tenant = 1 THEN 'AI has tenant, Backend missing'\n    END AS inconsistency_type\n  FROM request_summary\n  WHERE \n    -- Only check requests that have BOTH backend AND AI rows\n    has_backend_rows = 1 AND has_ai_rows = 1\n    -- Flag inconsistency: one has tenant data but the other doesn't\n    AND (\n      (backend_has_tenant = 1 AND ai_has_tenant = 0) \n      OR (backend_has_tenant = 0 AND ai_has_tenant = 1)\n    )\n)\nSELECT \n  request_id,\n  inconsistency_type,\n  backend_has_tenant,\n  ai_has_tenant\nFROM inconsistent_requests\nLIMIT 1 -- Assertion fails if any inconsistent records exist",
          "dependencies": [
            "offer_expanded_view"
          ]
        }
      },
      {
        "id": "check_missing_backend",
        "model": {
          "name": "check_missing_backend",
          "filePath": "fact_tables/check_missing_backend.sqlx",
          "type": "table",
          "schema": "fact_tables_dev",
          "tags": [],
          "config": {
            "type": "table",
            "schema": "fact_tables_dev",
            "tags": []
          },
          "sqlContent": "",
          "dependencies": [
            "offer_expanded_view"
          ]
        }
      }
    ],
    "edges": [
      {
        "source": "ai_intent_engine_offer",
        "target": "fact_ai_intent_engine"
      },
      {
        "source": "request_offer_campaign_mapping",
        "target": "fact_ai_intent_engine"
      },
      {
        "source": "ext_intent_engine_offer",
        "target": "fact_ext_intent_engine_offer"
      },
      {
        "source": "request_offer_campaign_mapping",
        "target": "fact_ext_intent_engine_offer"
      },
      {
        "source": "intent_engine_offer_group_match",
        "target": "fact_intent_engine_offer_group_match"
      },
      {
        "source": "request_offer_campaign_mapping",
        "target": "fact_intent_engine_offer_group_match"
      },
      {
        "source": "transactions_expanded_view",
        "target": "fact_offer_attribution_models"
      },
      {
        "source": "int_fe_offer",
        "target": "fact_offer_attribution_models"
      },
      {
        "source": "web_intent_engine_offer",
        "target": "fact_web_intent_engine_offer"
      },
      {
        "source": "request_offer_campaign_mapping",
        "target": "fact_web_intent_engine_offer"
      },
      {
        "source": "ai_intent_engine_offer",
        "target": "int_fe_offer"
      },
      {
        "source": "ext_intent_engine_offer",
        "target": "int_fe_offer"
      },
      {
        "source": "web_intent_engine_offer",
        "target": "int_fe_offer"
      },
      {
        "source": "request_offer_campaign_mapping",
        "target": "int_fe_offer"
      },
      {
        "source": "intent_engine_offer_group_match",
        "target": "request_offer_campaign_mapping"
      },
      {
        "source": "campaigns_placements",
        "target": "request_offer_campaign_mapping"
      },
      {
        "source": "campaigns_campaigns",
        "target": "request_offer_campaign_mapping"
      },
      {
        "source": "dpr_manual_spend",
        "target": "all_campaigns"
      },
      {
        "source": "dpr_manual_publisher_cpms",
        "target": "all_campaigns"
      },
      {
        "source": "apple_search_campaign_funnel",
        "target": "all_campaigns"
      },
      {
        "source": "google_campaign_funnel",
        "target": "all_campaigns"
      },
      {
        "source": "msft_campaign_funnel",
        "target": "all_campaigns"
      },
      {
        "source": "amazon_dsp_campaign_funnel",
        "target": "all_campaigns"
      },
      {
        "source": "meta_campaign_funnel",
        "target": "all_campaigns"
      },
      {
        "source": "tiktok_ads_campaign_funnel",
        "target": "all_campaigns"
      },
      {
        "source": "bizdev_spend",
        "target": "all_campaigns"
      },
      {
        "source": "dpr_manual_mapping",
        "target": "all_campaigns"
      },
      {
        "source": "dpr_manual_external",
        "target": "bizdev_spend"
      },
      {
        "source": "installs_base_w_reinstall",
        "target": "bizdev_spend"
      },
      {
        "source": "dpr_manual_publisher_cpms",
        "target": "int_publisher_cpms"
      },
      {
        "source": "offer_expanded_view",
        "target": "offer_campaign_ir_base"
      },
      {
        "source": "campaigns_campaigns",
        "target": "offer_campaign_ir_base"
      },
      {
        "source": "transactions_expanded_view",
        "target": "offer_campaign_ir_base"
      },
      {
        "source": "offer_campaign_ir_base",
        "target": "offer_campaign_ir_day"
      },
      {
        "source": "offer_campaign_ir_base",
        "target": "offer_campaign_ir_day_ai_only"
      },
      {
        "source": "offer_campaign_ir_base",
        "target": "offer_campaign_ir_hour"
      },
      {
        "source": "offer_campaign_ir_base",
        "target": "offer_campaign_ir_hour_ai_only"
      },
      {
        "source": "campaigns_placements",
        "target": "offer_expanded_view"
      },
      {
        "source": "campaigns_campaigns",
        "target": "offer_expanded_view"
      },
      {
        "source": "transactions_adviews",
        "target": "offer_expanded_view"
      },
      {
        "source": "ext_intent_engine_offer",
        "target": "offer_expanded_view"
      },
      {
        "source": "ai_intent_engine_offer",
        "target": "offer_expanded_view"
      },
      {
        "source": "web_intent_engine_offer",
        "target": "offer_expanded_view"
      },
      {
        "source": "intent_engine_offer_group_match",
        "target": "offer_expanded_view"
      },
      {
        "source": "intent_engine_cooldown_triggered",
        "target": "offer_expanded_view"
      },
      {
        "source": "offer_expanded_view",
        "target": "offer_template_hostname_day"
      },
      {
        "source": "fact_intent_engine_offer_group_match",
        "target": "offer_unified_view"
      },
      {
        "source": "int_fe_offer",
        "target": "offer_unified_view"
      },
      {
        "source": "fact_offer_attribution_models",
        "target": "offer_unified_view"
      },
      {
        "source": "offer_expanded_view",
        "target": "transactions_expanded_view"
      },
      {
        "source": "ext_affiliate_tag",
        "target": "transactions_expanded_view"
      },
      {
        "source": "ext_rewards_transaction",
        "target": "transactions_expanded_view"
      },
      {
        "source": "outbound_redirect",
        "target": "transactions_expanded_view"
      },
      {
        "source": "product_outbound_redirect",
        "target": "transactions_expanded_view"
      },
      {
        "source": "transactions_affiliatetransactions",
        "target": "transactions_expanded_view"
      },
      {
        "source": "transactions_transactions",
        "target": "transactions_expanded_view"
      },
      {
        "source": "transactions_campaigns",
        "target": "transactions_expanded_view"
      },
      {
        "source": "transactions_adoffers",
        "target": "transactions_expanded_view"
      },
      {
        "source": "user_anon_mapping",
        "target": "transactions_expanded_view"
      },
      {
        "source": "web_uninstall",
        "target": "unified_user_feedback"
      },
      {
        "source": "web_report_bug",
        "target": "unified_user_feedback"
      },
      {
        "source": "ext_feedback",
        "target": "unified_user_feedback"
      },
      {
        "source": "reviews",
        "target": "unified_user_feedback"
      },
      {
        "source": "ext_affiliate_tag",
        "target": "f_user_commerce"
      },
      {
        "source": "ext_order_confirmation",
        "target": "f_user_commerce"
      },
      {
        "source": "outbound_redirect",
        "target": "f_user_commerce"
      },
      {
        "source": "ext_standdown_detected",
        "target": "f_user_events"
      },
      {
        "source": "ext_device_ad_metrics_rollup",
        "target": "f_user_events"
      },
      {
        "source": "ext_user_settings",
        "target": "f_user_events"
      },
      {
        "source": "ext_heartbeat",
        "target": "f_user_heartbeats"
      },
      {
        "source": "ext_heartbeat",
        "target": "f_user_identity"
      },
      {
        "source": "installs_base_w_reinstall",
        "target": "f_user_identity"
      },
      {
        "source": "installs_base_w_reinstall",
        "target": "f_user_installs"
      },
      {
        "source": "web_server_uninstall",
        "target": "f_user_installs"
      },
      {
        "source": "web_uninstall",
        "target": "f_user_installs"
      },
      {
        "source": "ext_savings",
        "target": "f_user_interactions"
      },
      {
        "source": "ext_session_started",
        "target": "f_user_sessions"
      },
      {
        "source": "ext_context_detect",
        "target": "f_user_sessions"
      },
      {
        "source": "transactions_expanded_view",
        "target": "f_user_transactions"
      },
      {
        "source": "ext_rewards_transaction",
        "target": "f_user_transactions"
      },
      {
        "source": "user_balances",
        "target": "f_user_transactions"
      },
      {
        "source": "adblock_youtube_ad_seen",
        "target": "f_user_video_events"
      },
      {
        "source": "adblock_youtube_error_msg",
        "target": "f_user_video_events"
      },
      {
        "source": "adblock_youtube_video_embed",
        "target": "f_user_video_events"
      },
      {
        "source": "adblock_youtube_video_success",
        "target": "f_user_video_events"
      },
      {
        "source": "adblock_twitch_ad_seen",
        "target": "f_user_video_events"
      },
      {
        "source": "adblock_error_msg",
        "target": "f_user_video_events"
      },
      {
        "source": "transactions_affiliatetransactions",
        "target": "int_transaction_mapping"
      },
      {
        "source": "outbound_redirect",
        "target": "int_transaction_mapping"
      },
      {
        "source": "int_user_daily_base",
        "target": "int_user_cohort_logic"
      },
      {
        "source": "installs_base_w_reinstall",
        "target": "int_user_cohort_logic"
      },
      {
        "source": "f_user_heartbeats",
        "target": "int_user_daily_base"
      },
      {
        "source": "f_user_sessions",
        "target": "int_user_daily_base"
      },
      {
        "source": "f_user_interactions",
        "target": "int_user_daily_base"
      },
      {
        "source": "f_user_transactions",
        "target": "int_user_daily_base"
      },
      {
        "source": "f_user_commerce",
        "target": "int_user_daily_base"
      },
      {
        "source": "f_user_installs",
        "target": "int_user_daily_base"
      },
      {
        "source": "f_user_events",
        "target": "int_user_daily_base"
      },
      {
        "source": "f_user_identity",
        "target": "int_user_daily_base"
      },
      {
        "source": "f_user_video_events",
        "target": "int_user_daily_base"
      },
      {
        "source": "int_user_cohort_logic",
        "target": "user_day_funnel"
      },
      {
        "source": "int_user_daily_base",
        "target": "user_day_funnel"
      },
      {
        "source": "installs_base_w_reinstall",
        "target": "user_day_funnel"
      },
      {
        "source": "all_campaigns",
        "target": "growth_marketing_all_campaigns_assertions_uniqueKey_0"
      },
      {
        "source": "all_campaigns",
        "target": "growth_marketing_all_campaigns_assertions_rowConditions"
      },
      {
        "source": "all_campaigns",
        "target": "all_campaigns_no_duplicates_after_2025"
      },
      {
        "source": "bizdev_spend",
        "target": "growth_marketing_dev_bizdev_spend_assertions_rowConditions"
      },
      {
        "source": "offer_expanded_view",
        "target": "backend_frontend_ratio_monitor"
      },
      {
        "source": "transactions_expanded_view",
        "target": "chatgpt_null_tag_monitor"
      },
      {
        "source": "ext_intent_engine_offer",
        "target": "frontend_offers_have_backend_match"
      },
      {
        "source": "ai_intent_engine_offer",
        "target": "frontend_offers_have_backend_match"
      },
      {
        "source": "intent_engine_offer_group_match",
        "target": "frontend_offers_have_backend_match"
      },
      {
        "source": "offer_campaign_ir_base",
        "target": "raw_vs_distinct_variance_monitor"
      },
      {
        "source": "transactions_expanded_view",
        "target": "tag_consistency_check"
      },
      {
        "source": "offer_expanded_view",
        "target": "tenant_field_consistency_check"
      },
      {
        "source": "offer_expanded_view",
        "target": "check_missing_backend"
      }
    ]
  },
  "metadata": {
    "generatedAt": "2025-09-05T05:40:05.069Z",
    "version": "1.0.0",
    "projectPath": "/Users/jonahnakagawa/github/dataform"
  }
}